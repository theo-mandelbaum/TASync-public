"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_accumulation-chart_renderer_dataLabel_js-d3a4f4-fa819650"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/dataLabel.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/dataLabel.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccumulationDataLabel: () => (/* binding */ AccumulationDataLabel)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _model_acc_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/acc-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/model/acc-base.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _accumulation_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./accumulation-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/accumulation-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * AccumulationChart DataLabel module file\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * The `AccumulationDataLabel` module is used to render data labels for the Accumulation chart.\n */\nvar AccumulationDataLabel = /** @class */ (function (_super) {\n    __extends(AccumulationDataLabel, _super);\n    function AccumulationDataLabel(accumulation) {\n        var _this = _super.call(this, accumulation) || this;\n        _this.rightSideRenderingPoints = [];\n        _this.leftSideRenderingPoints = [];\n        _this.id = accumulation.element.id + '_datalabel_Series_';\n        return _this;\n    }\n    /**\n     * Method to get datalabel text location.\n     *\n     * @private\n     * @param {AccPoints} point - The data point for which to calculate the label text location.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\n     * @param {Size} textSize - The size of the text to be displayed.\n     * @param {AccPoints[]} points - The array of data points in the series.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points) {\n        var radius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\n            this.getLabelDistance(point, dataLabel);\n        //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n        if (this.accumulation.title) {\n            var titleSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.datalabelFont);\n            this.titleRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(this.accumulation.availableSize.width / 2 - titleSize.width / 2, this.accumulation.margin.top, titleSize.width, titleSize.height);\n        }\n        this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);\n        point.labelAngle = point.midAngle;\n        point.labelPosition = dataLabel.position;\n        if (this.accumulation.enableSmartLabels) {\n            this.getSmartLabel(point, dataLabel, textSize, points);\n        }\n    };\n    /**\n     * Method to get datalabel bound.\n     */\n    AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {\n        if (endAngle === void 0) { endAngle = 0; }\n        var labelAngle = endAngle || point.midAngle;\n        var space = 20;\n        var location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(labelAngle, labelRadius, this.isCircular() ? this.center :\n            this.getLabelLocation(point, position));\n        location.y = (position === 'Inside') ? (location.y - textSize.height / 2) : location.y;\n        location.x = (position === 'Inside') ? (location.x - textSize.width / 2) : location.x;\n        point.labelRegion = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(location.x, location.y, textSize.width + (margin * 2), textSize.height + (margin * 2));\n        if (position === 'Outside') {\n            point.labelRegion.y -= point.labelRegion.height / 2;\n            if (labelAngle >= 90 && labelAngle <= 270) {\n                point.labelRegion.x -= (point.labelRegion.width + space);\n            }\n            else {\n                point.labelRegion.x += space;\n            }\n        }\n    };\n    /**\n     * Method to get data label collection.\n     *\n     * @param {AccPoints} point - The data point for which to calculate the label collection.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.calculateLabelCollection = function (point, dataLabel) {\n        if (point.argsData.template !== null) {\n            return null;\n        }\n        var position = point.labelPosition || dataLabel.position;\n        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\n            this.getLabelDistance(point, dataLabel);\n        var radius = (!this.isVariousRadius() ?\n            (this.accumulation.pieSeriesModule.radius - this.accumulation.pieSeriesModule.innerRadius) :\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point));\n        var location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(point.midAngle, labelRadius, this.isCircular() ? this.center :\n            this.getLabelLocation(point, position));\n        var padding = 20;\n        var maxWidth = dataLabel.maxWidth;\n        if (!maxWidth) {\n            if (position === 'Outside') {\n                maxWidth = this.isCircular() ? (location.x >= this.center.x) ? (this.areaRect.x + this.areaRect.width - location.x) :\n                    (location.x - this.areaRect.x) : (location.x >= point.region.x) ?\n                    (this.areaRect.x + this.areaRect.width - location.x) : (location.x - this.areaRect.x);\n            }\n            else {\n                maxWidth = this.isCircular() ? (radius - padding) : point.region.width;\n            }\n        }\n        if ((point.label.indexOf('<br>') !== -1)) {\n            point.labelCollection = point.label.split('<br>');\n        }\n        else if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {\n            point.labelCollection[0] = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(maxWidth, point.label, point.argsData.font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);\n        }\n        else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {\n            point.labelCollection = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textWrap)(point.label, maxWidth, point.argsData.font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);\n        }\n        else {\n            point.labelCollection[0] = point.label;\n        }\n    };\n    /**\n     * To calculate label collection text size.\n     *\n     * @param {string[]} labelCollection - The collection of label texts.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\n     * @returns {Size} - The size of the label text collection.\n     * @private\n     */\n    AccumulationDataLabel.prototype.getTextSize = function (labelCollection, dataLabel) {\n        var height = 0;\n        var font = dataLabel.font;\n        var width = dataLabel.maxWidth ? dataLabel.maxWidth : 0;\n        var textSize;\n        for (var i = 0; i < labelCollection.length; i++) {\n            textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(labelCollection[i], font, this.accumulation.themeStyle.datalabelFont);\n            width = Math.max(textSize.width, width);\n            height += textSize.height;\n        }\n        if (dataLabel.textOverflow === 'Clip' && dataLabel.textWrap !== 'Normal' && dataLabel.maxWidth) {\n            width = dataLabel.maxWidth;\n        }\n        return (new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Size(width, height));\n    };\n    /**\n     * Method to get datalabel smart position.\n     *\n     * @param {AccPoints} point - The data point for which to calculate the label smart position.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\n     * @param {Size} textSize - The size of the text.\n     * @param {AccPoints[]} points - The collection of data points.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points) {\n        var circular = this.isCircular();\n        var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n        var connectorLength = circular ? (dataLabel.connectorStyle.length || '4%') :\n            '0px';\n        labelRadius += (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(connectorLength, labelRadius);\n        var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n        if (dataLabel.position === 'Inside') {\n            // `4` is padding adding to height and width of label region.\n            point.labelRegion.height -= 4;\n            point.labelRegion.width -= 4;\n            if (previousPoint && previousPoint.labelRegion && !dataLabel.enableRotation &&\n                ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, previousPoint.labelRegion)\n                    || this.isOverlapping(point, points)) || !circular && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.containsRect)(point.region, point.labelRegion)) {\n                point.labelPosition = 'Outside';\n                if (!circular) {\n                    labelRadius = this.getLabelDistance(point, dataLabel);\n                }\n                this.calculateLabelCollection(point, dataLabel);\n                textSize = this.getTextSize(point.labelCollection, dataLabel);\n                textSize.height += 4; // 4 for calculation with padding for smart label shape\n                textSize.width += 4;\n                this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);\n                previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n                if (previousPoint && ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, previousPoint.labelRegion) ||\n                    this.isConnectorLineOverlapping(point, previousPoint))) {\n                    this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n                }\n            }\n        }\n        else {\n            if (previousPoint && previousPoint.labelRegion && ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, previousPoint.labelRegion)\n                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n            }\n        }\n        if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {\n            var position = 'OutsideLeft';\n            var space = 20;\n            var labelAngle = point.midAngle || 0;\n            var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n            var location_1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(labelAngle, -labelRadius_1, this.isCircular() ? this.center :\n                this.getLabelLocation(point, position));\n            point.labelRegion = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(location_1.x, location_1.y, textSize.width + (this.marginValue * 2), textSize.height + (this.marginValue * 2));\n            point.labelRegion.y -= point.labelRegion.height / 2;\n            point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;\n            if (previousPoint && previousPoint.labelRegion && ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, previousPoint.labelRegion)\n                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);\n            }\n        }\n    };\n    /**\n     * To find trimmed datalabel tooltip needed.\n     *\n     * @param {Event} e - The move event.\n     * @param {number} x - The x-coordinate.\n     * @param {number} y - The y-coordinate.\n     * @param {boolean} isTouch - Indicates if the interaction is touch-based.\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {\n        var _this = this;\n        if (e.target.textContent.indexOf('...') > -1) {\n            var targetId = e.target.id.split(this.id);\n            if (targetId.length === 2) {\n                var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);\n                var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);\n                if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {\n                    if (isTouch) {\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.removeElement)(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n                    }\n                    var point = (0,_model_acc_base__WEBPACK_IMPORTED_MODULE_3__.getSeriesFromIndex)(seriesIndex, (this.accumulation).visibleSeries).points[pointIndex];\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.showTooltip)(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.accumulation.element.id + '_Secondary_Element'), null, null, this.accumulation.initialClipRect);\n                }\n            }\n        }\n        else {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.removeElement)(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n        }\n        if (isTouch) {\n            clearTimeout(this.clearTooltip);\n            this.clearTooltip = +setTimeout(function () { (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.removeElement)(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip'); }, 1000);\n        }\n    };\n    /**\n     * To find previous valid label point.\n     *\n     * @param {AccPoints[]} points - The array of accumulation points.\n     * @param {number} index - The index of the current point.\n     * @param {AccumulationLabelPosition} position - The position of the label.\n     * @returns {AccPoints} - Find the previous value of accumulation point.\n     */\n    AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {\n        var point = points[0];\n        for (var i = index - 1; i >= 0; i--) {\n            point = points[i];\n            if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {\n                return point;\n            }\n        }\n        return null;\n    };\n    /**\n     * To find current point datalabel is overlapping with other points.\n     *\n     * @param {AccPoints} currentPoint - The current point.\n     * @param {AccPoints[]} points - The array of accumulation points.\n     * @returns {boolean} - It returns boolean value of overlapping.\n     */\n    AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {\n        for (var i = currentPoint.index - 1; i >= 0; i--) {\n            if (points[i].visible && points[i].labelVisible &&\n                points[i].labelRegion && currentPoint.labelRegion &&\n                currentPoint.labelVisible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, points[i].labelRegion)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * To get text trimmed while exceeds the accumulation chart area.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {Rect} rect - The area of the accumulation chart.\n     * @param {FontModel} font - The font settings.\n     * @param {string} position - The position of the data label.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position, dataLabel) {\n        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, rect)) {\n            var size = point.labelRegion.width;\n            if (position === 'Right') {\n                size = rect.x - point.labelRegion.x;\n            }\n            else if (position === 'Left') {\n                size = point.labelRegion.x - (rect.x + rect.width);\n                if (size < 0) {\n                    size += point.labelRegion.width;\n                    point.labelRegion.x = rect.x + rect.width;\n                }\n            }\n            else if (position === 'InsideRight') {\n                size = (rect.x + rect.width) - point.labelRegion.x;\n            }\n            else if (position === 'InsideLeft') {\n                size = (point.labelRegion.x + point.labelRegion.width) - rect.x;\n                if (size < point.labelRegion.width) {\n                    point.labelRegion.x = rect.x;\n                }\n            }\n            else if (this.accumulation.enableSmartLabels) {\n                this.setPointVisibileFalse(point);\n            }\n            if (point.labelVisible && point.labelRegion) {\n                if ((point.label.indexOf('<br>') !== -1)) {\n                    point.labelCollection = point.label.split('<br>');\n                }\n                else if (size < point.labelRegion.width) {\n                    if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {\n                        point.labelCollection[0] = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(size - (this.marginValue * 2), point.label, font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);\n                    }\n                    else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {\n                        point.labelCollection = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textWrap)(point.label, size - (this.marginValue * 2), font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);\n                    }\n                    point.labelRegion.width = size;\n                }\n                for (var i = 0; i < point.labelCollection.length; i++) {\n                    if (point.labelCollection[i].length === 3 && point.labelCollection[i].indexOf('...') > -1) {\n                        this.setPointVisibileFalse(point);\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * To set point label visible and region to disable.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {\n        point.labelVisible = false;\n        point.labelRegion = null;\n    };\n    /**\n     * To set point label visible to enable.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.setPointVisibleTrue = function (point) {\n        point.labelVisible = true;\n    };\n    /**\n     * To set datalabel angle position for outside labels.\n     *\n     * @param {AccPoints} previousPoint - The previous accumulation point.\n     * @param {AccPoints} point - The accumulation point.\n     * @param {number} border - The border size.\n     * @param {number} labelRadius - The radius for the labels.\n     * @param {Size} textsize - The size of the labels.\n     * @param {number} margin - The margin value.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {\n        if (!this.isCircular()) {\n            this.setSmartLabelForSegments(point, previousPoint);\n        }\n        else {\n            var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);\n            this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n            if (labelAngle > point.endAngle) {\n                labelAngle = point.midAngle;\n                //this.setPointVisibileFalse(point);\n            }\n            point.labelAngle = labelAngle;\n            while (point.labelVisible && ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle\n                || labelAngle <= point.midAngle * 0.9 || this.isConnectorLineOverlapping(point, previousPoint))) {\n                if (labelAngle > point.endAngle) {\n                    //this.setPointVisibileFalse(point);\n                    break;\n                }\n                point.labelAngle = labelAngle;\n                this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n                labelAngle += 0.1;\n            }\n        }\n    };\n    /**\n     * Sets smart label positions for funnel and pyramid series.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {AccPoints} prevPoint - The previous point.\n     * @returns {void} setSmartLabelForSegments.\n     */\n    AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint) {\n        var textRegion = point.labelRegion;\n        //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;\n        var overlapHeight = this.accumulation.type === 'Funnel' ?\n            prevPoint.labelRegion.y - (textRegion.y + textRegion.height) :\n            point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);\n        if (overlapHeight < 0) {\n            point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;\n        }\n    };\n    /**\n     * To find connector line overlapping.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {AccPoints} previous - The previous point.\n     * @returns {boolean} - To find connector line overlapping or not.\n     */\n    AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {\n        var position;\n        if (!this.isCircular() && point.labelRegion.x < point.region.x) {\n            position = 'outsideLeft';\n        }\n        var start = this.getLabelLocation(point, position);\n        var end = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(0, 0);\n        this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);\n        var previousstart = this.getLabelLocation(previous);\n        var previousend = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(0, 0);\n        this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);\n        return this.isLineRectangleIntersect(start, end, point.labelRegion) ||\n            this.isLineRectangleIntersect(start, end, previous.labelRegion) ||\n            this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);\n    };\n    /**\n     * To find two rectangle intersect.\n     *\n     * @param {ChartLocation} line1 - The first line.\n     * @param {ChartLocation} line2 - The second line.\n     * @param {Rect} rect - The rectangle to check against.\n     * @returns {boolean} - To find line rectangle intersect value.\n     */\n    AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {\n        var rectPoints = [\n            new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(Math.round(rect.x), Math.round(rect.y)),\n            new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(Math.round((rect.x + rect.width)), Math.round(rect.y)),\n            new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(Math.round((rect.x + rect.width)), Math.round((rect.y + rect.height))),\n            new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(Math.round(rect.x), Math.round((rect.y + rect.height)))\n        ];\n        line1.x = Math.round(line1.x);\n        line1.y = Math.round(line1.y);\n        line2.x = Math.round(line2.x);\n        line2.y = Math.round(line2.y);\n        for (var i = 0; i < rectPoints.length; i++) {\n            if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * To find two line intersect.\n     *\n     * @param {ChartLocation} point1 - The first point of the first line.\n     * @param {ChartLocation} point2 - The second point of the first line.\n     * @param {ChartLocation} point11 - The first point of the second line.\n     * @param {ChartLocation} point12 - The second point of the second line.\n     * @returns {boolean} - To find line intersect or not.\n     */\n    AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {\n        var a1 = point2.y - point1.y;\n        var b1 = point1.x - point2.x;\n        var c1 = a1 * point1.x + b1 * point1.y;\n        var a2 = point12.y - point11.y;\n        var b2 = point11.x - point12.x;\n        var c2 = a2 * point11.x + b2 * point11.y;\n        var delta = a1 * b2 - a2 * b1;\n        if (delta !== 0) {\n            var x = (b2 * c1 - b1 * c2) / delta;\n            var y = (a1 * c2 - a2 * c1) / delta;\n            var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);\n            lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);\n            lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);\n            lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);\n            return lies;\n        }\n        return false;\n    };\n    /**\n     * To get two rectangle overlapping angles.\n     *\n     * @param {Rect} first - The first rectangle.\n     * @param {Rect} second - The second rectangle.\n     * @param {number} angle - The angle.\n     * @param {number} padding - The padding.\n     * @returns {number} - Get overlapped angle.\n     */\n    AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {\n        var x = first.x;\n        if (angle >= 90 && angle <= 270) {\n            second.y = first.y - (padding + second.height / 2);\n            x = first.x + first.width;\n        }\n        else {\n            second.y = first.y + first.height + padding;\n        }\n        return (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getAngle)(this.center, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(x, second.y));\n    };\n    /**\n     * To get connector line path.\n     *\n     * @param {Rect} label - The label.\n     * @param {AccPoints} point - The accumulation point.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\n     * @param {number} end - The end.\n     * @returns {string} - Get connector line path.\n     */\n    AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {\n        if (end === void 0) { end = 0; }\n        var connector = dataLabel.connectorStyle;\n        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.labelRadius :\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\n            this.getLabelDistance(point, dataLabel);\n        //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n        var start = this.getConnectorStartPoint(point, connector);\n        var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;\n        var middle = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(0, 0);\n        var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);\n        if (connector.type === 'Curve') {\n            if (this.isCircular()) {\n                var r = labelRadius - (this.isVariousRadius() ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(point.sliceRadius, this.accumulation.pieSeriesModule.size / 2) :\n                    this.radius);\n                //let r: number = labelRadius - this.radius;\n                if (point.isLabelUpdated) {\n                    middle = this.getPerpendicularDistance(start, point);\n                }\n                else {\n                    middle = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(labelAngle, labelRadius - (r / 2), this.center);\n                    if (point.labelPosition === 'Outside' && dataLabel.position === 'Inside') {\n                        middle = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(labelAngle, labelRadius - r * 1.25, this.center);\n                    }\n                }\n                return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;\n            }\n            else {\n                return this.getPolyLinePath(start, endPoint);\n            }\n        }\n        else {\n            return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;\n        }\n    };\n    /**\n     * Finds the curved path for funnel/pyramid data label connectors.\n     *\n     * @param {ChartLocation} start - The start location.\n     * @param {ChartLocation} end - The end location.\n     * @returns {string} - Get poly line path.\n     */\n    AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {\n        var controlPoints = [start, end];\n        if (start.y === end.y) {\n            return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;\n        }\n        var path = 'M';\n        for (var i = 0; i <= 16; i++) {\n            var t = i / 16;\n            var points = this.getBezierPoint(t, controlPoints, 0, 2);\n            path += points.x + ',' + points.y;\n            if (i !== 16) {\n                path += ' L';\n            }\n        }\n        return path;\n    };\n    /**\n     * Finds the bezier point for funnel/pyramid data label connectors.\n     *\n     * @param {number} t - The parameter value.\n     * @param {ChartLocation[]} controlPoints - The control points for the bezier point.\n     * @param {number} index - The index of the point.\n     * @param {number} count - The total count of points.\n     * @returns {ChartLocation} - Get bazier point.\n     */\n    AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {\n        if (count === 1) {\n            return controlPoints[index];\n        }\n        var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);\n        var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);\n        var x = (p0.x) ? p0.x : p0.x;\n        var y = (p0.y) ? p0.y : p0.y;\n        var x1 = (p1.x) ? p1.x : p1.x;\n        var y1 = (p1.y) ? p1.y : p1.y;\n        var x2 = (1 - t) * x + t * x1;\n        var y2 = (1 - t) * y + t * y1;\n        if (p0.x) {\n            return { x: x2, y: y2 };\n        }\n        else {\n            return { x: x2, y: y2 };\n        }\n    };\n    /**\n     * To get label edges based on the center and label rect position.\n     *\n     * @param {Rect} labelshape - The label shape.\n     * @param {number} angle - The angle of the label.\n     * @param {ChartLocation} middle - The middle point of the label.\n     * @param {number} border - The border value.\n     * @param {AccPoints} point - The accumulation point.\n     * @returns {ChartLocation} - Get label edge value.\n     */\n    AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {\n        if (border === void 0) { border = 1; }\n        var edge = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(labelshape.x, labelshape.y);\n        var space = 10;\n        if (angle >= 90 && angle <= 270) {\n            edge.x += labelshape.width + border / 2 + space;\n            edge.y += labelshape.height / 2;\n            middle.x = edge.x + 10;\n            middle.y = edge.y;\n        }\n        else if (point && point.region && point.region.x > point.labelRegion.x) {\n            edge.x += border * 2 + labelshape.width + space;\n            edge.y += labelshape.height / 2;\n            middle.x = edge.x + 10;\n            middle.y = edge.y;\n        }\n        else {\n            edge.x -= space - border / 2;\n            edge.y += labelshape.height / 2;\n            middle.x = edge.x - 10;\n            middle.y = edge.y;\n        }\n        return edge;\n    };\n    /**\n     * Finds the distance between the label position and the edge/center of the funnel/pyramid.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\n     * @returns {number} - Get label distance.\n     */\n    AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {\n        if (point.labelPosition && dataLabel.position !== point.labelPosition || (dataLabel.connectorStyle.length && dataLabel.position === 'Outside')) {\n            var length_1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);\n            if (length_1 < this.accumulation.initialClipRect.width) {\n                return length_1;\n            }\n        }\n        var position = point.labelPosition || dataLabel.position;\n        var series = this.accumulation.visibleSeries[0];\n        var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;\n        var labelLocation;\n        switch (position) {\n            case 'Inside':\n                return 0;\n            case 'Outside':\n                labelLocation = point.symbolLocation.x + point.labelOffset.x;\n                return this.accumulation.initialClipRect.width - labelLocation - extraSpace;\n        }\n    };\n    /**\n     * Finds the label position / beginning of the connector(ouside funnel labels).\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {AccumulationLabelPosition | string} position - The data label position.\n     * @returns {ChartLocation} - Get label location.\n     */\n    AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {\n        if (position === void 0) { position = 'Outside'; }\n        if (this.accumulation.type !== 'Pie' && this.accumulation.series[0].funnelMode !== 'Trapezoidal') {\n            position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;\n            var location_2 = {\n                x: point.symbolLocation.x,\n                y: point.symbolLocation.y - point.labelOffset.y\n            };\n            switch (position) {\n                case 'Inside':\n                    location_2.y = point.region.y + point.region.height / 2;\n                    break;\n                case 'Outside':\n                    location_2.x += point.labelOffset.x;\n                    break;\n                case 'OutsideLeft':\n                    location_2.x -= point.labelOffset.x;\n            }\n            return location_2;\n        }\n        else if (this.accumulation.series[0].funnelMode === 'Trapezoidal' && this.accumulation.type === 'Funnel') {\n            var location_3 = {\n                x: point.symbolLocation.x,\n                y: point.symbolLocation.y\n            };\n            if (position === 'Outside') {\n                location_3.x = point.labelOffset.x;\n            }\n            return location_3;\n        }\n        else {\n            //return degreeToLocation(point.midAngle, this.radius, this.center);\n            return (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(point.midAngle, (this.isVariousRadius() ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\n                this.radius), this.center);\n        }\n    };\n    /**\n     * Finds the beginning of connector line.\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {ConnectorModel} connector - The connector line.\n     * @returns {ChartLocation} - Staring point of connector line.\n     */\n    AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {\n        // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :\n        //     this.getLabelLocation(point);\n        var position;\n        if (!this.isCircular() && point.region.x > point.labelRegion.x) {\n            position = 'OutsideLeft';\n        }\n        return this.isCircular() ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.degreeToLocation)(point.midAngle, (this.isVariousRadius() ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\n            this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);\n    };\n    /**\n     * To find area rect based on margin, available size.\n     *\n     * @private\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.findAreaRect = function () {\n        this.areaRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\n        var margin = this.accumulation.margin;\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subtractThickness)(this.areaRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.Thickness(margin.left, margin.right, margin.top, margin.bottom));\n    };\n    /**\n     * To render the data labels from series points.\n     *\n     * @param {AccPoints} point - The point for which to render the data label.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\n     * @param {Element} parent - The parent element to which the data labels are appended.\n     * @param {AccPoints[]} points - The collection of points in the series.\n     * @param {number} series - The index of the series.\n     * @param {HTMLElement} templateElement - The template element for the data label.\n     * @param {boolean} redraw - Indicates whether the data labels are being redrawn.\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {\n        var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';\n        var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });\n        var border = { width: dataLabel.border.width, color: dataLabel.border.color };\n        var argsFont = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)('properties', dataLabel.font), null, true));\n        point.label = this.getDatalabelText(dataLabel.format, this.accumulation, point.originalText || point.y.toString());\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.textRender, series: this.accumulation.visibleSeries[0], point: point,\n            text: point.label, border: border, color: dataLabel.fill, template: this.accumulation.enableHtmlSanitizer ?\n                this.accumulation.sanitize(dataLabel.template) : dataLabel.template, font: argsFont\n        };\n        this.accumulation.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.textRender, argsData);\n        point.argsData = argsData;\n        var isTemplate = argsData.template !== null;\n        point.labelVisible = !argsData.cancel;\n        point.text = point.label = argsData.text;\n        point.labelCollection = [];\n        this.marginValue = argsData.border.width ? (5 + argsData.border.width) : 1;\n        var childElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n            id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,\n            styles: 'position: absolute;background-color:' + argsData.color + ';' +\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getFontStyle)(dataLabel.font, this.accumulation.themeStyle.datalabelFont) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'\n        });\n        this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);\n    };\n    AccumulationDataLabel.prototype.getDatalabelText = function (labelFormat, chart, labelText) {\n        if (Number(labelText)) {\n            var customLabelFormat = labelFormat.match('{value}') !== null;\n            var format = chart.intl.getNumberFormat({\n                format: customLabelFormat ? '' : labelFormat,\n                useGrouping: chart.useGroupingSeparator\n            });\n            labelText = customLabelFormat ? labelFormat.replace('{value}', format(parseFloat(labelText))) : format(parseFloat(labelText));\n        }\n        return labelText;\n    };\n    /**\n     * To calculate label size.\n     *\n     * @param {boolean} isTemplate - Indicates whether the label is a template.\n     * @param {HTMLElement} childElement - The child element of the label.\n     * @param {AccPoints} point - The point associated with the label.\n     * @param {AccPoints[]} points - The collection of points.\n     * @param {IAccTextRenderEventArgs} argsData - The arguments data for text rendering.\n     * @param {Element} datalabelGroup - The group element for data labels.\n     * @param {string} id - The id of the label.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\n     * @param {boolean} redraw - Indicates whether the labels are being redrawn.\n     * @param {ClientRect} clientRect - The client rectangle.\n     * @param {boolean} isReactCallback - Indicates whether a React callback is being used.\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.calculateLabelSize = function (isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {\n        this.calculateLabelCollection(point, dataLabel);\n        var textSize = isTemplate ? (isReactCallback ? { width: clientRect.width, height: clientRect.height } :\n            this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel)) : this.getTextSize(point.labelCollection, dataLabel);\n        textSize.height += 4; // 4 for calculation with padding for smart label shape\n        textSize.width += 4;\n        point.textSize = textSize;\n        point.templateElement = childElement;\n        this.getDataLabelPosition(point, dataLabel, textSize, points);\n        if (point.labelRegion) {\n            this.correctLabelRegion(point.labelRegion, point.textSize);\n        }\n    };\n    /**\n     * To draw a data label.\n     *\n     * @param {AccumulationSeries} series - The series associated with the data label.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\n     * @param {HTMLElement} parent - The parent element of the data labels.\n     * @param {HTMLElement} templateElement - The template element for the data label.\n     * @param {boolean} redraw - Indicates whether the data labels are being redrawn.\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.drawDataLabels = function (series, dataLabel, parent, templateElement, redraw) {\n        var angle;\n        var degree;\n        var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);\n        modifiedPoints.sort(function (a, b) { return a.index - b.index; });\n        if (series.type === 'Pie' && this.accumulation.enableSmartLabels) {\n            this.extendedLabelsCalculation();\n        }\n        for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {\n            var point = modifiedPoints_1[_i];\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.argsData) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y)) {\n                this.finalizeDatalabels(point, modifiedPoints, dataLabel);\n                var pointElement = document.getElementById(this.accumulation.element.id + '_Series_0_Point_' + point.index);\n                var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\n                var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });\n                datalabelGroup.setAttribute('aria-hidden', 'true');\n                var dataLabelElement = void 0;\n                var location_4 = void 0;\n                var element = void 0;\n                if (point.visible && point.labelVisible) {\n                    angle = degree = dataLabel.angle;\n                    if (point.argsData.template) {\n                        this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);\n                    }\n                    else {\n                        location_4 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y\n                            + (point.textSize.height * 3 / (point.labelCollection.length * 4)) + this.marginValue);\n                        element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(id + 'shape_' + point.index);\n                        var startLocation = element ? new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;\n                        var textWidth = point.textSize.width;\n                        if (dataLabel.enableRotation) {\n                            if (angle === 0) {\n                                if (point.labelPosition === 'Outside') {\n                                    degree = 0;\n                                }\n                                else if (point.midAngle >= 90 && point.midAngle <= 260) {\n                                    degree = point.midAngle + 180;\n                                }\n                                else {\n                                    degree = point.midAngle;\n                                }\n                            }\n                            else {\n                                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                            }\n                        }\n                        else {\n                            degree = 0;\n                        }\n                        var rotate = 'rotate(' + degree + ',' + (location_4.x + (textWidth / 2)) + ',' + (location_4.y) + ')';\n                        point.transform = rotate;\n                        dataLabelElement = this.accumulation.renderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.RectOption(id + 'shape_' + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry, rotate, series.dataLabel.border.dashArray));\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(this.accumulation.renderer, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.TextOption(id + 'text_' + point.index, location_4.x, location_4.y, this.accumulation.enableRtl ? 'end' : 'start', point.labelCollection, rotate, 'auto', degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration, null, null, null, null, true, this.accumulation.themeStyle.datalabelFont);\n                        element = null;\n                    }\n                    if (pointElement && this.accumulation.highlightMode !== 'None') {\n                        datalabelGroup.setAttribute('class', pointElement.getAttribute('class') ? pointElement.getAttribute('class') : '');\n                        for (var i = 0; i < datalabelGroup.children.length; i++) {\n                            var existing = document.getElementById(datalabelGroup.children[i].id);\n                            if (existing) {\n                                datalabelGroup.children[i].style.opacity = existing.style.opacity;\n                            }\n                        }\n                    }\n                    if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && !this.accumulation.redraw && (dataLabel.position === 'Outside'\n                        || this.accumulation.enableSmartLabels)) {\n                        this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);\n                    }\n                    if (point.labelPosition === 'Outside') {\n                        var element_1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(id + 'connector_' + point.index);\n                        var previousDirection = element_1 ? element_1.getAttribute('d') : '';\n                        var pathElement = this.accumulation.renderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);\n                    }\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, parent, datalabelGroup, redraw);\n                }\n                else if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(datalabelGroup.id)) {\n                    ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(datalabelGroup.id)).parentNode.removeChild((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(datalabelGroup.id));\n                }\n            }\n        }\n        if (this.accumulation.type === 'Pie' && dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Clip') {\n            this.dataLabelClipPath(dataLabel, parent);\n        }\n    };\n    /**\n     * To calculate data label clip path.\n     *\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\n     * @param {HTMLElement} parent - The parent element of the data labels.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.dataLabelClipPath = function (dataLabel, parent) {\n        var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\n        var clippath = this.accumulation.renderer.createClipPath({ id: id + 'clipPath' });\n        var clipRect;\n        var radius = this.accumulation.pieSeriesModule.pieBaseRadius;\n        if (dataLabel.position === 'Inside') {\n            clipRect = this.accumulation.renderer.drawCircle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.CircleOption(id + 'clipPath_rect', 'transparent', { width: 0 }, 0, this.center.x, this.center.y, radius));\n        }\n        else if (dataLabel.maxWidth) {\n            var x = this.center.x - radius - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)((dataLabel.connectorStyle.length || '4%'), radius) - dataLabel.maxWidth;\n            var y = this.center.y - radius - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)((dataLabel.connectorStyle.length || '4%'), radius) - dataLabel.maxWidth;\n            var height = (radius + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)((dataLabel.connectorStyle.length || '4%'), radius) + dataLabel.maxWidth) * 2;\n            var width = height;\n            if (this.accumulation.legendSettings.visible) {\n                var legendModule = this.accumulation.accumulationLegendModule;\n                if (legendModule.position === 'Left') {\n                    width = (legendModule.legendBounds.x + legendModule.legendBounds.width - x) > 0 ?\n                        (width - (legendModule.legendBounds.width - x)) : width;\n                    x = (legendModule.legendBounds.x + legendModule.legendBounds.width) < x ? x :\n                        (legendModule.legendBounds.x + legendModule.legendBounds.width);\n                }\n                else if (legendModule.position === 'Right') {\n                    width = (x + width - legendModule.legendBounds.x) > 0 ? (width - (x + width - legendModule.legendBounds.x)) : width;\n                }\n            }\n            clipRect = this.accumulation.renderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.RectOption(id + 'clipPath_rect', 'transparent', { width: 0 }, 0, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(x, y, height, width), 0, 0));\n        }\n        if (dataLabel.position === 'Inside' || dataLabel.maxWidth) {\n            clippath.appendChild(clipRect);\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, this.accumulation.svgObject, clippath);\n            parent.style.cssText = 'clip-path:url(#' + clippath.id + ')';\n        }\n    };\n    /**\n     * In this method datalabels region checked with legebdBounds and areaBounds.\n     * Trimming of datalabel and point's visibility again changed here.\n     *\n     * @param {AccPoints} point - Current point in which trimming and visibility to be checked.\n     * @param {AccPoints[]} points - Finalized points.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - Datalabel model.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.finalizeDatalabels = function (point, points, dataLabel) {\n        if (this.isOverlapping(point, points) ||\n            (this.titleRect && point.labelRegion && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, this.titleRect))) {\n            if (this.isCircular() && point.labelPosition === 'Outside' && this.accumulation.enableSmartLabels) {\n                this.setPointVisibileFalse(point);\n            }\n        }\n        if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible &&\n            point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {\n            var rect = this.accumulation.accumulationLegendModule.legendBounds;\n            if (this.accumulation.visibleSeries[0].type !== 'Pie' && this.accumulation.legendSettings.position === 'Left'\n                && dataLabel.position === 'Outside') {\n                point.labelRegion.x = point.labelRegion.x + rect.width;\n            }\n            var padding = this.accumulation.legendSettings.border.width / 2;\n            this.textTrimming(point, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x - padding, rect.y - padding, rect.width + (2 * padding), rect.height + (2 * padding)), dataLabel.font, this.accumulation.accumulationLegendModule.position, dataLabel);\n        }\n        if (point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {\n            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :\n                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';\n            this.textTrimming(point, this.areaRect, dataLabel.font, position, dataLabel);\n        }\n        if (point.labelVisible && point.labelRegion && !dataLabel.maxWidth && dataLabel.textOverflow !== 'Clip' && this.accumulation.enableSmartLabels && ((point.labelRegion.y + point.labelRegion.height / 2 >\n            this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y) || (point.labelRegion.x < this.areaRect.x ||\n            point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width))) {\n            this.setPointVisibileFalse(point);\n        }\n    };\n    /**\n     * To find the template element size.\n     *\n     * @param {HTMLElement} element - To get a template element.\n     * @param {AccPoints} point - The accumulation point for the template.\n     * @param {IAccTextRenderEventArgs} argsData - The arguments for the accumulation points.\n     * @param {boolean} redraw - Indicates whether to redraw the template.\n     * @param {boolean} isTemplate - Indicates whether the element is a template.\n     * @param {AccPoints[]} points - The accumulation points for the template.\n     * @param {Element} datalabelGroup - The group element for the data labels.\n     * @param {string} id - The identifier for the template.\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\n     * @returns {Size} - The size of the template.\n     */\n    AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {\n        element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.createTemplate)(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + '_DataLabel', 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);\n        var clientRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.measureElementRect)(element, redraw);\n        return { width: clientRect.width, height: clientRect.height };\n    };\n    /**\n     * To set the template element style.\n     *\n     * @param {HTMLElement} childElement - The child element of the template.\n     * @param {AccPoints} point - The point data for the template.\n     * @param {Element} parent - The parent element of the template.\n     * @param {string} labelColor - The color of the label in the template.\n     * @param {string} fill - The fill color of the template.\n     * @param {boolean} redraw - Indicates whether to redraw the template.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {\n        childElement.style.left = (point.labelRegion.x) + 'px';\n        childElement.style.top = (point.labelRegion.y) + 'px';\n        childElement.style.color = labelColor || this.getSaturatedColor(point, point.labelPosition === 'Inside' ? fill : this.getLabelBackground(point));\n        if (this.accumulation.isBlazor) {\n            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :\n                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';\n            if (position === 'InsideRight') {\n                childElement.style.transform = 'translate(0%, -50%)';\n            }\n            else {\n                childElement.style.transform = 'translate(-100%, -50%)';\n            }\n        }\n        if (childElement.childElementCount) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, parent, childElement, redraw, true, 'left', 'top');\n            this.doTemplateAnimation(this.accumulation, childElement);\n        }\n    };\n    /**\n     * To find saturated color for datalabel\n     *\n     * @param {AccPoints} point - The accumulation point.\n     * @param {string} color - The original color.\n     * @returns {string} - Get a saturated color.\n     */\n    AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {\n        var saturatedColor;\n        if (this.marginValue >= 1) {\n            saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;\n        }\n        else {\n            saturatedColor = this.getLabelBackground(point);\n        }\n        saturatedColor = (saturatedColor === 'transparent') ? ((this.accumulation.theme.indexOf('Dark') > -1 || this.accumulation.theme.indexOf('HighContrast') > -1) ? 'black' : 'white') : saturatedColor;\n        var rgbValue = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.convertHexToColor)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.colorNameToHex)(saturatedColor));\n        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n        return this.accumulation.theme === 'Bootstrap5' ? '#212529' : this.accumulation.theme === 'Bootstrap5Dark' ? '#DEE2E6' : contrast >= 128 ? this.accumulation.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : this.accumulation.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white';\n    };\n    /**\n     * Animates the data label template.\n     *\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @param {Element} element - The element to animate.\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {\n        var series = accumulation.visibleSeries[0];\n        var delay = series.animation.delay + series.animation.duration;\n        if (((series.animation.enable && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode !== 'Disable') || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') && accumulation.animateSeries) {\n            element.style.visibility = 'hidden';\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.templateAnimate)(element, delay, 200, 'ZoomIn');\n        }\n    };\n    /**\n     * To find background color for the datalabel.\n     *\n     * @param {AccPoints} point - The data point for which to determine the background color.\n     * @returns {string} - The background color for the data label.\n     */\n    AccumulationDataLabel.prototype.getLabelBackground = function (point) {\n        return point.labelPosition === 'Outside' ?\n            this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf('dark') ? 'white' : 'black' : point.color;\n    };\n    /**\n     * To correct the padding between datalabel regions.\n     *\n     * @param {Rect} labelRegion - The region occupied by the data label.\n     * @param {Size} textSize - The size of the text within the data label.\n     * @param {number} padding - The padding value to adjust the spacing.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {\n        if (padding === void 0) { padding = 4; }\n        labelRegion.height -= padding;\n        labelRegion.width -= padding;\n        labelRegion.x += padding / 2;\n        labelRegion.y += padding / 2;\n        textSize.height -= padding;\n        textSize.width -= padding;\n    };\n    /**\n     * To get the dataLabel module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    AccumulationDataLabel.prototype.getModuleName = function () {\n        return 'AccumulationDataLabel';\n    };\n    /**\n     * To destroy the data label.\n     *\n     * @returns {void}\n     * @private\n     */\n    AccumulationDataLabel.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    //calculation for placing labels smartly\n    AccumulationDataLabel.prototype.extendedLabelsCalculation = function () {\n        var _this = this;\n        var series = this.accumulation.series[0];\n        series.rightSidePoints.forEach(function (point, index, halfSidePoints) {\n            point.initialLabelRegion = point.labelRegion;\n            point.isLabelUpdated = 0;\n            _this.skipPoints(point, halfSidePoints, index);\n        });\n        series.leftSidePoints.forEach(function (point, index, halfSidePoints) {\n            point.initialLabelRegion = point.labelRegion;\n            point.isLabelUpdated = 0;\n            _this.skipPoints(point, halfSidePoints, index);\n        });\n        this.arrangeLeftSidePoints(series);\n        this.isIncreaseAngle = false;\n        this.arrangeRightSidePoints(series);\n    };\n    /**\n     * Rightside points alignments calculation.\n     *\n     * @param {AccumulationSeries} series - To get a proper series.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.arrangeRightSidePoints = function (series) {\n        var startFresh;\n        var angleChanged;\n        var rightSideRenderPoints = series.rightSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });\n        this.rightSideRenderingPoints = rightSideRenderPoints;\n        var checkAngle;\n        var currentPoint;\n        var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];\n        var nextPoint;\n        if (lastPoint) {\n            if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {\n                this.isIncreaseAngle = true;\n                this.changeLabelAngle(lastPoint, 89);\n            }\n        }\n        /**\n         * Right side points arranged from last point.\n         * A point checked with successive points for overlapping.\n         * If that is overlapped, its label angle is decreased and placing in optimal position\n         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\n         * When decreasing angle falls beyond 270, label angle increased.\n         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\n         */\n        for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {\n            currentPoint = rightSideRenderPoints[i];\n            nextPoint = rightSideRenderPoints[i + 1];\n            // A point checked for overlapping, label visibility\n            if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible\n                || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {\n                checkAngle = lastPoint.labelAngle + 10;\n                angleChanged = true;\n                //If last's point change angle in beyond the limit, stop the increasing angle and do decrease the angle.\n                if (startFresh) {\n                    this.isIncreaseAngle = false;\n                }\n                else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {\n                    this.isIncreaseAngle = true;\n                }\n                if (!this.isIncreaseAngle) {\n                    for (var k = i + 1; k < rightSideRenderPoints.length; k++) {\n                        this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);\n                    }\n                }\n                else {\n                    for (var k = i + 1; k > 0; k--) {\n                        this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);\n                    }\n                }\n            }\n            else {\n                //If a point did not overlapped with previous points, increase the angle always for right side points.\n                if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {\n                    startFresh = true;\n                }\n            }\n        }\n    };\n    /**\n     * Leftside points alignments calculation.\n     *\n     * @param {AccumulationSeries} series - To get a proper series.\n     * @returns {void}\n     */\n    AccumulationDataLabel.prototype.arrangeLeftSidePoints = function (series) {\n        var _this = this;\n        var leftSideRenderPoints = series.leftSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });\n        this.leftSideRenderingPoints = leftSideRenderPoints;\n        var previousPoint;\n        var currentPoint;\n        var angleChanged;\n        var startFresh;\n        /**\n         * Left side points arranged from first point.\n         * A point checked with previous points for overlapping.\n         * If that is overlapped, its label angle is decreased and placing in optimal position\n         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\n         * When decreasing angle falls beyond 90, label angle increased.\n         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\n         */\n        for (var i = 0; i < leftSideRenderPoints.length; i++) {\n            currentPoint = leftSideRenderPoints[i];\n            previousPoint = leftSideRenderPoints[i - 1];\n            // A point checked\n            if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible\n                || !(currentPoint.labelAngle < 270)) {\n                angleChanged = true;\n                if (startFresh) {\n                    this.isIncreaseAngle = false;\n                }\n                if (!this.isIncreaseAngle) {\n                    for (var k = i; k > 0; k--) {\n                        this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);\n                        leftSideRenderPoints.filter(function (point, index) {\n                            if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {\n                                _this.isIncreaseAngle = true;\n                            }\n                        });\n                    }\n                }\n                else {\n                    for (var k = i; k < leftSideRenderPoints.length; k++) {\n                        this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);\n                    }\n                }\n            }\n            else {\n                if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {\n                    startFresh = true;\n                }\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.decreaseAngle = function (currentPoint, previousPoint, series, isRightSide) {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentPoint) || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(previousPoint)) {\n            return null;\n        }\n        var count = 1;\n        if (isRightSide) {\n            while ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&\n                !((previousPoint.labelRegion.height + previousPoint.labelRegion.y) < currentPoint.labelRegion.y))) {\n                var newAngle = previousPoint.midAngle - count;\n                if (newAngle < 0) {\n                    newAngle = 360 + newAngle;\n                }\n                if (newAngle <= 270 && newAngle >= 90) {\n                    newAngle = 270;\n                    this.isIncreaseAngle = true;\n                    break;\n                }\n                this.changeLabelAngle(previousPoint, newAngle);\n                count++;\n            }\n        }\n        else {\n            if (currentPoint.labelAngle > 270) {\n                this.changeLabelAngle(currentPoint, 270);\n                previousPoint.labelAngle = 270;\n            }\n            while ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&\n                ((currentPoint.labelRegion.y + currentPoint.labelRegion.height) > previousPoint.labelRegion.y))) {\n                var newAngle = previousPoint.midAngle - count;\n                if (!(newAngle <= 270 && newAngle >= 90)) {\n                    newAngle = 90;\n                    this.isIncreaseAngle = true;\n                    break;\n                }\n                this.changeLabelAngle(previousPoint, newAngle);\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, previousPoint.labelRegion) &&\n                    !series.leftSidePoints.indexOf(previousPoint) && (newAngle - 1 < 90 && newAngle - 1 > 270)) {\n                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);\n                    this.arrangeLeftSidePoints(series);\n                    break;\n                }\n                count++;\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.increaseAngle = function (currentPoint, nextPoint, series, isRightSide) {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentPoint) || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(nextPoint)) {\n            return null;\n        }\n        var count = 1;\n        if (isRightSide) {\n            while ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&\n                !((currentPoint.labelRegion.y + currentPoint.labelRegion.height) < nextPoint.labelRegion.y))) {\n                var newAngle = nextPoint.midAngle + count;\n                if (newAngle < 270 && newAngle > 90) {\n                    newAngle = 90;\n                    this.isIncreaseAngle = true;\n                    break;\n                }\n                this.changeLabelAngle(nextPoint, newAngle);\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, nextPoint.labelRegion) && (newAngle + 1 > 90 && newAngle + 1 < 270) &&\n                    this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {\n                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);\n                    nextPoint.labelRegion = nextPoint.initialLabelRegion;\n                    this.arrangeRightSidePoints(series);\n                    break;\n                }\n                if (count > 360) {\n                    break;\n                }\n                count++;\n            }\n        }\n        else {\n            while ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&\n                (currentPoint.labelRegion.y < (nextPoint.labelRegion.y + nextPoint.labelRegion.height)))) {\n                var newAngle = nextPoint.midAngle + count;\n                if (!(newAngle < 270 && newAngle > 90)) {\n                    newAngle = 270;\n                    this.isIncreaseAngle = false;\n                    break;\n                }\n                this.changeLabelAngle(nextPoint, newAngle);\n                if (count > 360) {\n                    break;\n                }\n                count++;\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.changeLabelAngle = function (currentPoint, newAngle) {\n        var dataLabel = this.accumulation.series[0].dataLabel;\n        var variableR;\n        if (this.isVariousRadius()) {\n            variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);\n        }\n        //padding 10px is added to label radius for increasing the angle and avoid congestion.\n        var labelRadius = (currentPoint.labelPosition === 'Outside' && this.accumulation.enableSmartLabels &&\n            dataLabel.position === 'Inside') ?\n            this.radius + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(dataLabel.connectorStyle.length || '4%', this.accumulation.pieSeriesModule.size / 2) :\n            (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR);\n        var radius = (!this.isVariousRadius() ? labelRadius : variableR);\n        this.getLabelRegion(currentPoint, 'Outside', currentPoint.textSize, radius, this.marginValue, newAngle);\n        currentPoint.isLabelUpdated = 1;\n        currentPoint.labelAngle = newAngle;\n    };\n    AccumulationDataLabel.prototype.isOverlapWithPrevious = function (currentPoint, points, currentPointIndex) {\n        for (var i = 0; i < currentPointIndex; i++) {\n            if (i !== points.indexOf(currentPoint) &&\n                points[i].visible && points[i].labelVisible &&\n                points[i].labelRegion && currentPoint.labelRegion &&\n                currentPoint.labelVisible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(currentPoint.labelRegion, points[i].labelRegion)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    AccumulationDataLabel.prototype.isOverlapWithNext = function (point, points, pointIndex) {\n        for (var i = pointIndex; i < points.length; i++) {\n            if (i !== points.indexOf(point) && points[i].visible &&\n                points[i].labelVisible && points[i].labelRegion &&\n                point.labelRegion && point.labelVisible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isOverlap)(point.labelRegion, points[i].labelRegion)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    AccumulationDataLabel.prototype.skipPoints = function (currentPoint, halfsidePoints, pointIndex) {\n        if (pointIndex > 0 && ((currentPoint.midAngle < 285 && currentPoint.midAngle > 255) ||\n            (currentPoint.midAngle < 105 && currentPoint.midAngle > 75))) {\n            var previousPoint = halfsidePoints[pointIndex - 1];\n            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n            var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;\n            if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {\n                this.setPointVisibleTrue(currentPoint);\n            }\n        }\n        else if (pointIndex > 1 && ((currentPoint.midAngle < 300 && currentPoint.midAngle > 240) ||\n            (currentPoint.midAngle < 120 && currentPoint.midAngle > 60))) {\n            var prevPoint = halfsidePoints[pointIndex - 1];\n            var secondPrevPoint = halfsidePoints[pointIndex - 2];\n            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n            var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;\n            var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;\n            if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {\n                this.setPointVisibleTrue(currentPoint);\n            }\n        }\n    };\n    AccumulationDataLabel.prototype.getPerpendicularDistance = function (startPoint, point) {\n        var increasedLocation;\n        var add = 10;\n        var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);\n        if (point.midAngle > 270 && point.midAngle < 360) {\n            increasedLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(startPoint.x + height * (Math.cos((360 - point.midAngle) * Math.PI / 180)), startPoint.y - height * (Math.sin((360 - point.midAngle) * Math.PI / 180)));\n        }\n        else if (point.midAngle > 0 && point.midAngle < 90) {\n            increasedLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(startPoint.x + height * (Math.cos((point.midAngle) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle) * Math.PI / 180)));\n            // eslint-disable-next-line no-dupe-else-if\n        }\n        else if (point.midAngle > 0 && point.midAngle < 90) {\n            increasedLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 90) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle - 90) * Math.PI / 180)));\n        }\n        else {\n            increasedLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 180) * Math.PI / 180)), startPoint.y - height * (Math.sin((point.midAngle - 180) * Math.PI / 180)));\n        }\n        return increasedLocation;\n    };\n    return AccumulationDataLabel;\n}(_accumulation_base__WEBPACK_IMPORTED_MODULE_5__.AccumulationBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/dataLabel.js?");

/***/ })

}]);