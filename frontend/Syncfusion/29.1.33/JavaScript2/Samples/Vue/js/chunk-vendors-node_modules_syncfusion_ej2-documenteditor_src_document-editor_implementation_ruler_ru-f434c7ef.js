"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-documenteditor_src_document-editor_implementation_ruler_ru-f434c7ef"],{

/***/ "./node_modules/@syncfusion/ej2-documenteditor/src/document-editor/implementation/ruler/ruler.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-documenteditor/src/document-editor/implementation/ruler/ruler.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ruler: () => (/* binding */ Ruler)\n/* harmony export */ });\n/* harmony import */ var _editor_editor_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editor/editor-helper */ \"./node_modules/@syncfusion/ej2-documenteditor/src/document-editor/implementation/editor/editor-helper.js\");\n/* harmony import */ var _utility_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility/size */ \"./node_modules/@syncfusion/ej2-documenteditor/src/document-editor/implementation/utility/size.js\");\n/* eslint-disable @typescript-eslint/ban-types */\n\n\n/**\n * @private\n */\nvar Ruler = /** @class */ (function () {\n    /**\n     *  Constructor for creating the Ruler Component\n     *\n     * @param {string | HTMLElement} element The ruler element.\n     * @param {RulerHelper} rulerHelper The ruler helper.\n     */\n    function Ruler(element, rulerHelper) {\n        /**\n         * Defines the unique interval of the ruler.\n         *\n         * @default 6\n         */\n        this.interval = 4;\n        /**\n         * Sets the segment width of the ruler.\n         *\n         * @default 36\n         */\n        this.segmentWidth = 47.9988;\n        /**\n         * Defines the orientation of the ruler.\n         *\n         * @default 'Horizontal'\n         */\n        this.orientation = 'Horizontal';\n        /**\n         * Defines the alignment of the tick in the ruler.\n         *\n         *\n         * @default 'RightOrBottom'\n         */\n        this.tickAlignment = 'RightOrBottom';\n        /**\n         * Defines the color of the marker.\n         *\n         * @default 'red'\n         */\n        this.markerColor = 'red';\n        /**\n         * Defines the thickness of the ruler.\n         *\n         * @default 15\n         */\n        this.thickness = 15;\n        /**\n         * Sets the segment width of the ruler.\n         *\n         * @default null\n         * @deprecated\n         */\n        this.arrangeTick = null;\n        /**\n         * Defines the length of the ruler.\n         *\n         * @default 400\n         */\n        this.length = 400;\n        /**   @private  */\n        this.offset = 0;\n        /**   @private  */\n        this.scale = 1;\n        /**   @private  */\n        this.rulerStartValue = 1584;\n        /**   @private  */\n        this.zeroPosition = _editor_editor_helper__WEBPACK_IMPORTED_MODULE_0__.HelperMethods.convertPointToPixel(1584);\n        /**   @private  */\n        this.addSegmentWidth = false;\n        this.element = element;\n        this.rulerHelper = rulerHelper;\n    }\n    /**\n     * @private\n     * @returns {void} To append the ruler\n     */\n    Ruler.prototype.appendTo = function () {\n        this.preRender();\n        this.render();\n    };\n    /**\n     * Initializes the values of private members.\n     *\n     * @returns {void}  Initializes the values of private members.\n     * @private\n     */\n    Ruler.prototype.preRender = function () {\n        this.unWireEvents();\n        this.wireEvents();\n    };\n    /**\n     * Renders the rulers.\n     *\n     * @returns {void}  Renders the rulers.\n     * @private\n     */\n    Ruler.prototype.render = function () {\n        this.updateRulerGeometry();\n        //this.renderComplete();\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    Ruler.prototype.getModuleName = function () {\n        return 'Ruler';\n    };\n    /**\n     *To destroy the ruler\n     *\n     * @returns {void} To destroy the ruler\n     */\n    Ruler.prototype.destroy = function () {\n        var _this = this;\n        this.unWireEvents();\n        // this.notify('destroy', {});\n        // super.destroy();\n        if (this.rulerSpacediv) {\n            this.rulerSpacediv.remove();\n            this.rulerSpacediv = null;\n        }\n        if (this.rulerSVGElement) {\n            this.rulerSVGElement.childNodes.forEach(function (element) {\n                _this.rulerSVGElement.removeChild(element);\n                element = null;\n            });\n            this.rulerSVGElement.innerHTML = '';\n            this.rulerSVGElement.remove();\n            this.rulerSVGElement = null;\n        }\n        this.element.classList.remove('e-ruler');\n    };\n    /**\n     * Refreshes the ruler when the Ruler properties are updated\\\n     *\n     * @returns {  void}    Refreshes the ruler when the Ruler properties are updated .\\\n     * @param {RulerModel} newProp - provide the newProp value.\n     * @param {RulerModel} oldProp - provide the oldProp value.\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    // public onPropertyChanged(newProp: RulerModel, oldProp: RulerModel): void {\n    //     for (const prop of Object.keys(newProp)) {\n    //         switch (prop) {\n    //             case 'interval':\n    //             case 'segmentWidth':\n    //             case 'tickAlignment':\n    //             case 'markerColor':\n    //             case 'thickness':\n    //                 this.updateRuler();\n    //                 break;\n    //         }\n    //     }\n    // }\n    /**\n     * @param {boolean} show - provide the show value.\n     * @private\n     * @returns {void} To show or hide the ruler\n     */\n    Ruler.prototype.showHideRuler = function (show) {\n        if (show) {\n            this.element.style.display = 'block';\n        }\n        else {\n            this.element.style.display = 'none';\n        }\n    };\n    Ruler.prototype.updateRulerGeometry = function () {\n        this.element.style.textAlign = 'left';\n        this.renderRulerSpace();\n        this.updateRuler();\n    };\n    Ruler.prototype.renderRulerSpace = function () {\n        var rulerGeometry = this.getRulerGeometry();\n        this.rulerSpacediv = document.getElementById(this.element.id + '_ruler_space');\n        if (!this.rulerSpacediv) {\n            this.rulerSpacediv = this.rulerHelper.createHtmlElement('div', {\n                'id': this.element.id + '_ruler_space',\n                'style': 'height:' + rulerGeometry.height + 'px;width:' + rulerGeometry.width + 'px;cssFloat:' + 'left;'\n            });\n            this.element.appendChild(this.rulerSpacediv);\n        }\n        return this.rulerSpacediv;\n    };\n    /**\n     * @private\n     *\n     * @returns {void} To update the ruler\n     */\n    Ruler.prototype.updateRuler = function () {\n        var rulerSize = this.getRulerSize();\n        var rulerGeometry = this.getRulerGeometry();\n        var length = 0;\n        var offset = 0;\n        var availableSize = new _utility_size__WEBPACK_IMPORTED_MODULE_1__.Size();\n        this.rulerSVGElement = this.getRulerSVG(rulerGeometry);\n        if (this.rulerSVGElement) {\n            length = this.length;\n            availableSize.height = rulerSize;\n            offset = this.offset;\n            if (length && length !== Infinity) {\n                var unitLength = length;\n                var unitOffset = offset;\n                this.updateSegments(unitOffset, (unitLength + Math.abs(unitOffset)), this.rulerSVGElement, rulerSize);\n            }\n        }\n    };\n    Ruler.prototype.updateSegments = function (start, end, svg, rulerSize) {\n        var run = start;\n        var trans = { trans: 0 };\n        this.rulerStartValue = _editor_editor_helper__WEBPACK_IMPORTED_MODULE_0__.HelperMethods.convertPixelToPoint(this.zeroPosition);\n        while (run < end) {\n            var rulerSegment = this.getNewSegment(run, svg);\n            if (rulerSegment) {\n                svg.appendChild(rulerSegment.segment);\n                run = this.updateSegment(start, end, rulerSegment, run, trans, rulerSize);\n            }\n        }\n        this.addSegmentWidth = false;\n    };\n    Ruler.prototype.updateSegment = function (start, end, rulerSegment, run, trans, rulerSize) {\n        var segWidth = this.updateSegmentWidth(this.scale);\n        if (run === start) {\n            this.startValue = Math.floor(start / segWidth) * segWidth / this.scale;\n            this.startValue = (this.startValue % 1) !== 0 ? Number((this.startValue).toFixed(1)) : this.startValue;\n            rulerSegment.label.textContent = this.rulerStartValue.toString();\n            this.defStartValue = run = this.startValue * this.scale;\n            if (this.orientation === 'Horizontal') {\n                this.hRulerOffset = start - run;\n            }\n            else {\n                this.vRulerOffset = start - run;\n            }\n        }\n        else {\n            //  this.startValue = (run / this.scale);\n            this.startValue = _editor_editor_helper__WEBPACK_IMPORTED_MODULE_0__.HelperMethods.convertPixelToPoint(run);\n            this.startValue = (this.startValue % 1) !== 0 ? Number((this.startValue).toFixed(1)) : this.startValue;\n            //  rulerSegment.label.textContent = (this.startValue).toString();\n            var labeltext = void 0;\n            if (this.rulerStartValue === 0) {\n                this.addSegmentWidth = true;\n            }\n            if (this.addSegmentWidth) {\n                labeltext = Math.abs(this.rulerStartValue + 36);\n            }\n            else {\n                labeltext = Math.abs(this.rulerStartValue - 36);\n            }\n            // const labeltext = this.subtractAndAdd(this.rulerStartValue, 36);\n            rulerSegment.label.textContent = (labeltext).toString();\n            this.rulerStartValue = labeltext;\n            //  if (this.addSegmentWidth) {\n            //   if ((1584 - this.startValue) <= this.leftMargin && !((1584 -this.startValue) >= (HelperMethods.convertPixelToPoint(this.pageWidth) - this.rightMargin))) {\n            //  rulerSegment.label.textContent = (this.startValue - this.leftMargin).toString();\n            // if (this.startValue >= 1584 && (Math.round(HelperMethods.convertPointToPixel(this.startValue)) < ((2112 - HelperMethods.convertPointToPixel(this.startMargin)) + ((pageLength) - HelperMethods.convertPointToPixel(this.endMargin))))) {\n            //     const rectElement = rulerSegment.segment.querySelector('.e-ruler-segment1') as SVGRectElement;\n            //     var rect = rulerSegment.segment.firstChild;\n            //     rectElement.setAttribute(\"fill\", \"white\");\n            // }\n            //}\n        }\n        this.updateTickLabel(rulerSegment, rulerSize);\n        var translate = (this.orientation === 'Horizontal') ? ((trans.trans + 0.5) + ',0.5') : ('0.5,' + (trans.trans + 0.5));\n        rulerSegment.segment.setAttribute('transform', 'translate(' + translate + ') scale(' + 1 + ',1)');\n        trans.trans += segWidth * this.scale;\n        run += segWidth;\n        return run;\n    };\n    Ruler.prototype.updateTickLabel = function (rulerSegment, rulerSize) {\n        var bBox = rulerSegment.segment.lastChild.getBBox();\n        var isHorizontal = (this.orientation === 'Horizontal') ? true : false;\n        var isRightOrBottom = (this.tickAlignment === 'RightOrBottom') ? true : false;\n        var x = isHorizontal ? -4 : 0;\n        var y = isHorizontal ? (isRightOrBottom ? (rulerSize / 2 + (11 / 2) - (11 / 2)) :\n            (rulerSize / 2 + (11 / 2))) : bBox.height;\n        if (isHorizontal) {\n            y = y + 2;\n        }\n        if (!isHorizontal) {\n            x = x + 10;\n            y = y + 2;\n        }\n        var translate = isRightOrBottom ? (-(bBox.width + 2) + ',' + ((rulerSize / 2) - bBox.height)) :\n            (-(bBox.width + 2) + ',' + ((rulerSize / 2) - bBox.height / 2));\n        var attr = isHorizontal ? { 'x': x, 'y': y } :\n            { 'x': x, 'y': y, 'transform': 'rotate(270)' + 'translate(' + translate + ')' };\n        this.rulerHelper.setAttributeSvg(rulerSegment.segment.lastChild, attr);\n    };\n    Ruler.prototype.getNewSegment = function (run, svg) {\n        var segment = this.createNewTicks(run, svg);\n        var label = this.createTickLabel(svg, segment);\n        return { segment: segment, label: label };\n    };\n    Ruler.prototype.createNewTicks = function (run, svg) {\n        var tick;\n        var tickInterval;\n        var segmentWidth = this.updateSegmentWidth(this.scale);\n        //let g: SVGElement;\n        var attr = { 'class': 'e-de-ruler-segment' };\n        var g = this.rulerHelper.createSvgElement('g', attr);\n        //let rect: SVGElement;\n        var rectattr = { 'class': 'e-de-ruler-segment1' };\n        var rect = this.rulerHelper.createSvgElement('rect', rectattr);\n        var width = this.orientation === 'Horizontal' ? (segmentWidth * this.scale) : 15;\n        var height = this.orientation === 'Horizontal' ? 15 : segmentWidth;\n        rect.setAttribute('x', '0');\n        rect.setAttribute('y', '0');\n        rect.setAttribute('width', width.toString());\n        rect.setAttribute('height', height.toString());\n        rect.setAttribute('fill', 'lightgrey');\n        // g.appendChild(rect);\n        for (var i = 0; i < this.interval; i++) {\n            tickInterval = segmentWidth / this.interval;\n            tick = this.createTick(svg, tickInterval, i + 1, run);\n            if (tick) {\n                g.appendChild(tick);\n            }\n        }\n        return g;\n    };\n    Ruler.prototype.getLinePoint = function (svg, tickInterval, length) {\n        var segmentWidth = this.updateSegmentWidth(this.scale);\n        var rulerSize = this.getRulerSize();\n        tickInterval = tickInterval * (length - 1);\n        length = ((tickInterval % segmentWidth) === 0) ? rulerSize : rulerSize * 0.3;\n        return length;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Ruler.prototype.createTick = function (svg, tickInterval, length, run) {\n        var ruler;\n        //let line: SVGElement;\n        var linePoint = this.getLinePoint(svg, tickInterval, length);\n        var rulerSize = this.getRulerSize();\n        //let args: IArrangeTickOptions;\n        //let attr: Object;\n        var isHorizontal = (this.orientation === 'Horizontal') ? true : false;\n        var isRightOrBottom = (this.tickAlignment === 'RightOrBottom') ? true : false;\n        // const arrangeTick: Function = getFunction(this.arrangeTick);\n        // // eslint-disable-next-line\n        // const args:IArrangeTickOptions = { ruler: ruler, tickLength: linePoint, tickInterval: ((this.segmentWidth / this.interval) * (length - 1)) };\n        // if (arrangeTick) {\n        //     arrangeTick(args);\n        // }\n        // linePoint = args.tickLength;\n        var point = tickInterval * (length - 1) * this.scale;\n        var x1 = isHorizontal ? point : (isRightOrBottom ? rulerSize : 0);\n        var x2 = isHorizontal ? point : (isRightOrBottom ? (rulerSize - linePoint) : (rulerSize - (rulerSize - linePoint)));\n        var y1 = isHorizontal ? (isRightOrBottom ? rulerSize : (rulerSize - (rulerSize - linePoint))) : point;\n        var y2 = isHorizontal ? (isRightOrBottom ? (rulerSize - linePoint) : 0) : point;\n        var line;\n        if (y2 !== 0) {\n            y1 = y1 - 6;\n            y2 = y2 - 6;\n            if (!isHorizontal) {\n                x1 = x1 - 6;\n                x2 = x2 - 6;\n            }\n            var attr = { 'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'stroke-width': '0.25', 'stroke': 'black' };\n            line = this.rulerHelper.createSvgElement('line', attr);\n            line.setAttribute('class', 'e-de-ruler-tick');\n        }\n        return line;\n    };\n    Ruler.prototype.createTickLabel = function (svg, segment) {\n        var text;\n        if (segment) {\n            var attr = { 'class': 'e-de-ruler-tick-label', 'style': 'font-weight: 400' };\n            text = this.rulerHelper.createSvgElement('text', attr);\n            segment.appendChild(text);\n        }\n        return text;\n    };\n    /**\n     * @private\n     * @param {number} scale\n     */\n    /**\n     * updateSegmentWidth method\\\n     *\n     * @returns {number}    updateSegmentWidth method .\\\n     * @param {string} scale - provide the scale value.\n     *\n     * @private\n     */\n    Ruler.prototype.updateSegmentWidth = function (scale) {\n        if (this.segmentWidth !== 100) {\n            return this.segmentWidth;\n        }\n        var five = 25;\n        var multiples = 1;\n        var div;\n        //let scaleRound: number;\n        var fifty = 100;\n        var scaleRound = Math.pow(2, Math.round(Math.log(scale) / Math.log(2)));\n        div = fifty;\n        div = (fifty / scaleRound);\n        while (div > 100) {\n            multiples /= 10;\n            div /= 10;\n        }\n        while (div < 25) {\n            multiples *= 10;\n            div *= 10;\n        }\n        if (div >= five && div % five !== 0) {\n            div = Math.round(div / five) * five;\n        }\n        return div * scale / multiples;\n    };\n    // private createMarkerLine(rulerSvg: SVGSVGElement, rulerObj: HTMLElement, attr: Object): SVGElement {\n    //     let line: SVGElement;\n    //     if (rulerObj) {\n    //         line = rulerSvg.getElementById(rulerObj.id + '_marker') as SVGElement;\n    //         if (line) {\n    //             line.parentNode.removeChild(line);\n    //         }\n    //         line = this.rulerHelper.createSvgElement('line', attr);\n    //     }\n    //     return line;\n    // }\n    // /**\n    //  * updateSegmentWidth method\\\n    //  *\n    //  * @returns {void}    updateSegmentWidth method .\\\n    //  * @param {HTMLElement} rulerObj - Defines the ruler Object\n    //  * @param {PointModel} currentPoint - Defines the current point for ruler Object\n    //  * @param {number} offset - Defines the offset ruler Object\n    //  *\n    //  * @private\n    //  */\n    // public drawRulerMarker(rulerObj: HTMLElement, currentPoint: PointModel, offset: number): void {\n    //     let rulerSvg: SVGSVGElement;\n    //     let rulerSize: number;\n    //     let scale: number;\n    //     let diff: number;\n    //     let i: number;\n    //     let attr: Object;\n    //     let line: SVGElement;\n    //     const isHorizontal: boolean = this.orientation === 'Horizontal' ? true : false;\n    //     // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    //     const rulerSvgElements: NodeListOf<SVGSVGElement> | any = rulerObj.getElementsByTagName('svg');\n    //     for (i = 0; i < rulerSvgElements.length; i++) {\n    //         if (rulerSvgElements[parseInt(i.toString(), 10)]) {\n    //             rulerSvg = rulerSvgElements[parseInt(i.toString(), 10)];\n    //         }\n    //         break;\n    //     }\n    //     if (rulerSvg) {\n    //         rulerSize = this.getRulerSize();\n    //         attr = {\n    //             'id': rulerObj.id + '_marker', 'x1': 0, 'y1': 0, 'x2': (isHorizontal ? 0 : rulerSize),\n    //             'y2': (isHorizontal ? rulerSize : 0), 'stroke': this.markerColor, 'stroke-width': 1.5,\n    //             'class': 'e-d-ruler-marker'\n    //         };\n    //         line = this.createMarkerLine(rulerSvg, rulerObj, attr);\n    //         scale = this.scale;\n    //         diff = this.offset - this.defStartValue;\n    //         const point: number = isHorizontal ? currentPoint.x : currentPoint.y;\n    //         const move: number = (point * scale) + offset + diff;\n    //         line.setAttribute('transform', 'translate(' + (isHorizontal ? ((move + 0.5) + ' 0.5') : ('0.5 ' + (move + 0.5))) + ')');\n    //         rulerSvg.appendChild(line);\n    //     }\n    // }\n    Ruler.prototype.getRulerGeometry = function () {\n        if (this.orientation === 'Horizontal') {\n            return new _utility_size__WEBPACK_IMPORTED_MODULE_1__.Size(this.length, this.element ? this.element.getBoundingClientRect().height : 0);\n        }\n        else {\n            return new _utility_size__WEBPACK_IMPORTED_MODULE_1__.Size(this.element ? this.element.getBoundingClientRect().width : 0, this.length);\n        }\n    };\n    Ruler.prototype.getRulerSize = function () {\n        return this.thickness;\n    };\n    Ruler.prototype.getRulerSVG = function (rulerGeometry) {\n        var rulerSpace;\n        var rulerSize = this.getRulerSize();\n        var svg;\n        if (this.element) {\n            rulerSpace = document.getElementById(this.element.id + '_ruler_space');\n            if (rulerSpace) {\n                var attr = {\n                    'id': this.element.id + '_Ruler_svg',\n                    width: this.orientation === 'Horizontal' ? this.length : rulerSize + 'px',\n                    height: this.orientation === 'Horizontal' ? rulerSize : (rulerGeometry.height) + 'px',\n                    style: 'position:inherit;'\n                };\n                svg = this.rulerHelper.createSvgElement('svg', attr);\n                if (rulerSpace.childNodes.length > 0) {\n                    for (var i = rulerSpace.childNodes.length - 1; i >= 0; i--) {\n                        rulerSpace.childNodes[parseInt(i.toString(), 10)].parentNode.removeChild(rulerSpace.childNodes[parseInt(i.toString(), 10)]);\n                    }\n                }\n                rulerSpace.appendChild(svg);\n            }\n        }\n        return svg;\n    };\n    /**\n     * Method to bind events for the ruler \\\n     *\n     * @returns {void}    Method to bind events for the ruler .\\\n     * @private\n     */\n    Ruler.prototype.wireEvents = function () {\n        //wire Events\n    };\n    /**\n     *  Method to unbind events for the ruler \\\n     *\n     * @returns {void}     Method to unbind events for the ruler .\\\n     * @private\n     */\n    Ruler.prototype.unWireEvents = function () {\n        //unWire Events\n    };\n    return Ruler;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-documenteditor/src/document-editor/implementation/ruler/ruler.js?");

/***/ })

}]);