"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_utils_chart3dRender_js-1991ab5b"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryTreeBuilder: () => (/* binding */ BinaryTreeBuilder),\n/* harmony export */   Chart3DRender: () => (/* binding */ Chart3DRender),\n/* harmony export */   ChartTransform3D: () => (/* binding */ ChartTransform3D),\n/* harmony export */   Graphics3D: () => (/* binding */ Graphics3D),\n/* harmony export */   Matrix3D: () => (/* binding */ Matrix3D),\n/* harmony export */   Polygon3D: () => (/* binding */ Polygon3D),\n/* harmony export */   Svg3DRenderer: () => (/* binding */ Svg3DRenderer),\n/* harmony export */   Vector3D: () => (/* binding */ Vector3D),\n/* harmony export */   getMinPointsDeltaValue: () => (/* binding */ getMinPointsDeltaValue),\n/* harmony export */   valueToCoefficients: () => (/* binding */ valueToCoefficients)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n/**\n * Represents a 3D rendering configuration for the EJ3D rendering engine.\n *\n */\nvar Chart3DRender = /** @class */ (function () {\n    function Chart3DRender() {\n        this.transform = null; // Chart3DBasicTransform\n    }\n    return Chart3DRender;\n}());\n\nvar chart3DRender = new Chart3DRender();\n/**\n * Represents a three-dimensional vector in space.\n */\nvar Vector3D = /** @class */ (function () {\n    /**\n     * Constructs a new Vector3D instance.\n     *\n     * @constructor\n     * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n     * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n     * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n     */\n    function Vector3D(pointX, vy, vz) {\n        /** The x-coordinate of the vector. */\n        this.x = 0;\n        /** The y-coordinate of the vector. */\n        this.y = 0;\n        /** The z-coordinate of the vector. */\n        this.z = 0;\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.00001;\n        this.x = pointX;\n        this.y = vy || 0;\n        this.z = vz || 0;\n    }\n    /**\n     * Checks if a vector is valid (not NaN for any component).\n     *\n     * @param {Chart3DVector} point - The vector to check.\n     * @returns {boolean} - True if the vector is valid, false otherwise.\n     */\n    Vector3D.prototype.isValid = function (point) {\n        return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n    };\n    /**\n     * Creates a new Vector3D instance from provided coordinates.\n     *\n     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n     * @param {number} vy - The y-coordinate.\n     * @param {number} vz - The z-coordinate.\n     * @returns {Chart3DVector} - The new Vector3D instance.\n     */\n    Vector3D.prototype.vector3D = function (vx, vy, vz) {\n        this.x = vx;\n        this.y = vy;\n        this.z = vz;\n        return { x: this.x, y: this.y, z: this.z };\n    };\n    /**\n     * Subtracts one vector from another and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector to subtract from the first.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DMinus = function (v1, v2) {\n        return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    };\n    /**\n     * Adds two vectors and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector to add to the first.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DPlus = function (v1, v2) {\n        return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    };\n    /**\n     * Multiplies two vectors using the cross product and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DMultiply = function (v1, v2) {\n        var x = v1.y * v2.z - v2.y * v1.z;\n        var y = v1.z * v2.x - v2.z * v1.x;\n        var z = v1.x * v2.y - v2.x * v1.y;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the dot product of two vectors.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector.\n     * @returns {number} - The dot product.\n     */\n    Vector3D.prototype.vector3DAdd = function (v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    };\n    /**\n     * Multiplies a vector by a scalar value.\n     *\n     * @param {Chart3DVector} v1 - The vector to multiply.\n     * @param {number} value - The scalar value.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DStarMultiply = function (v1, value) {\n        var x = v1.x * value;\n        var y = v1.y * value;\n        var z = v1.z * value;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the length of a vector.\n     *\n     * @param {Chart3DVector} vector - The vector to calculate the length of.\n     * @returns {number} - The length of the vector.\n     */\n    Vector3D.prototype.getLength = function (vector) {\n        var sqt = this.vector3DAdd(vector, vector);\n        return Math.sqrt(sqt);\n    };\n    /**\n     * Normalizes the vector to have a length of 1.\n     *\n     * @returns {void}\n     */\n    Vector3D.prototype.normalize = function () {\n        var length = this.getLength(this);\n        this.x /= length;\n        this.y /= length;\n        this.z /= length;\n    };\n    /**\n     * Calculates the normal vector of a triangle defined by three vectors.\n     *\n     * @param {Chart3DVector} v1 - The first vertex of the triangle.\n     * @param {Chart3DVector} v2 - The second vertex of the triangle.\n     * @param {Chart3DVector} v3 - The third vertex of the triangle.\n     * @returns {Chart3DVector} - The normal vector of the triangle.\n     */\n    Vector3D.prototype.getNormal = function (v1, v2, v3) {\n        var vector4 = this.vector3DMinus(v1, v2);\n        var vector5 = this.vector3DMinus(v3, v2);\n        var n = this.vector3DMultiply(vector4, vector5);\n        var length = this.getLength(n);\n        if (length < this.epsilon) {\n            return this.vector3D(0, 0, 0);\n        }\n        return this.vector3D(n.x / length, n.y / length, n.z / length);\n    };\n    return Vector3D;\n}());\n\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar Matrix3D = /** @class */ (function () {\n    function Matrix3D() {\n        /** The size of the matrix, which is set to 4 by default. */\n        this.matrixSize = 4;\n    }\n    /**\n     * Creates a 3D matrix with the specified size.\n     *\n     * @param {number} size - The size of the matrix.\n     * @returns {number[][]} - The created 3D matrix.\n     */\n    Matrix3D.prototype.matrix3D = function (size) {\n        var matrixData = [];\n        for (var i = 0; i < size; i++) {\n            matrixData[i] = this.createArray(size);\n        }\n        return matrixData;\n    };\n    /**\n     * Checks if a matrix is an affine matrix.\n     *\n     * @param {number[][]} matrixData - The matrix to check.\n     * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n     */\n    Matrix3D.prototype.isAffine = function (matrixData) {\n        return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n    };\n    /**\n     * Creates a new array with zeros.\n     *\n     * @param {number} initialSize - The size of the array.\n     * @returns {number[]} - The created array.\n     */\n    Matrix3D.prototype.createArray = function (initialSize) {\n        var matrixData = [];\n        for (var index = 0; index < initialSize; ++index) {\n            matrixData[index] = 0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the identity matrix.\n     *\n     * @returns {number[][]} -The identity matrix.\n     */\n    Matrix3D.prototype.getIdentity = function () {\n        var matrixData = this.matrix3D(this.matrixSize);\n        for (var i = 0; i < this.matrixSize; i++) {\n            matrixData[i][i] = 1.0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the interval of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix to get the interval for.\n     * @returns {number[][]} - The interval matrix.\n     */\n    Matrix3D.prototype.getInterval = function (matrix) {\n        var matrixData = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                matrixData[i][j] = this.getMinor(matrix, i, j);\n            }\n        }\n        matrixData = this.transposed(matrixData);\n        matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n        return matrixData;\n    };\n    /**\n     * Multiplies all elements of a matrix by a factor.\n     *\n     * @param {number} factor - The factor to multiply with.\n     * @param {number[][]} matrix - The matrix to multiply.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    Matrix3D.prototype.getMatrixMultiple = function (factor, matrix) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j < matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * factor;\n            }\n        }\n        return matrix;\n    };\n    /**\n     * Multiplies a matrix by a vector.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {Chart3DVector} point - The vector to multiply with.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Matrix3D.prototype.getMatrixVectorMultiple = function (matrix, point) {\n        var x = matrix[0][0] * point.x +\n            matrix[1][0] * point.y +\n            matrix[2][0] * point.z +\n            matrix[3][0];\n        var y = matrix[0][1] * point.x +\n            matrix[1][1] * point.y +\n            matrix[2][1] * point.z +\n            matrix[3][1];\n        var z = matrix[0][2] * point.x +\n            matrix[1][2] * point.y +\n            matrix[2][2] * point.z +\n            matrix[3][2];\n        if (!this.isAffine(matrix)) {\n            var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n            x *= c;\n            y *= c;\n            z *= c;\n        }\n        return { x: x, y: y, z: z };\n    };\n    /**\n     * Multiplies a matrix by a vector and applies translation.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {Chart3DVector} vector - The vector to multiply with.\n     * @returns {Vector3D} - The resulting vector.\n     */\n    Matrix3D.prototype.getMatrixVectorAnd = function (matrix, vector) {\n        var x = matrix[0][0] * vector.x +\n            matrix[1][0] * vector.y +\n            matrix[2][0] * vector.z;\n        var y = matrix[0][1] * vector.x +\n            matrix[1][1] * vector.y +\n            matrix[2][1] * vector.z;\n        var z = matrix[0][2] * vector.x +\n            matrix[1][2] * vector.y +\n            matrix[2][2] * vector.z;\n        return new Vector3D(x, y, z);\n    };\n    /**\n     * Multiplies two matrices.\n     *\n     * @param {number[][]} matrix1 - The first matrix.\n     * @param {number[][]} matrix2 - The second matrix.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    Matrix3D.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n        var result = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                var value = 0;\n                for (var k = 0; k < this.matrixSize; k++) {\n                    value += matrix1[k][j] * matrix2[i][k];\n                }\n                result[i][j] = value;\n            }\n        }\n        return result;\n    };\n    /**\n     * Gets the minor of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number} - The minor of the matrix.\n     * @private\n     */\n    Matrix3D.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n        return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n    };\n    /**\n     * Gets a submatrix of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number[][]} - The submatrix.\n     */\n    Matrix3D.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n        var count = matrix.length - 1;\n        var subMatrix = this.createArray(count);\n        for (var i = 0; i < count; i++) {\n            var matrixColumn = i >= columnIndex ? i + 1 : i;\n            subMatrix[i] = this.createArray(count);\n            for (var j = 0; j < count; j++) {\n                var matrixRow = j >= rowIndex ? j + 1 : j;\n                subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n            }\n        }\n        return subMatrix;\n    };\n    /**\n     * Gets the determinant of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @returns {number} - The determinant of the matrix.\n     */\n    Matrix3D.prototype.getDeterminant = function (matrix) {\n        var count = matrix.length;\n        var determinant = 0;\n        if (count < 2) {\n            determinant = matrix[0][0];\n        }\n        else {\n            var k = 1;\n            for (var i = 0; i < count; i++) {\n                var submatrix = this.getMatrix(matrix, i, 0);\n                determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n                k = k > 0 ? -1 : 1;\n            }\n        }\n        return determinant;\n    };\n    /**\n     * Transforms a matrix by translation.\n     *\n     * @param {number} x - The x-coordinate of the translation.\n     * @param {number} y - The y-coordinate of the translation.\n     * @param {number} z - The z-coordinate of the translation.\n     * @returns {number[][]} - The transformed matrix.\n     */\n    Matrix3D.prototype.transform = function (x, y, z) {\n        var transformedMatrix = this.getIdentity();\n        transformedMatrix[3][0] = x;\n        transformedMatrix[3][1] = y;\n        transformedMatrix[3][2] = z;\n        return transformedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the y-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    Matrix3D.prototype.turn = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[0][0] = Math.cos(angle);\n        rotatedMatrix[2][0] = -Math.sin(angle);\n        rotatedMatrix[0][2] = Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the x-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    Matrix3D.prototype.tilt = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[1][1] = Math.cos(angle);\n        rotatedMatrix[2][1] = Math.sin(angle);\n        rotatedMatrix[1][2] = -Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Transposes a matrix.\n     *\n     * @param {number[][]} matrix3D - The matrix to transpose.\n     * @returns {number[][]} - The transposed matrix.\n     */\n    Matrix3D.prototype.transposed = function (matrix3D) {\n        var transposedMatrix = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                transposedMatrix[i][j] = matrix3D[j][i];\n            }\n        }\n        return transposedMatrix;\n    };\n    return Matrix3D;\n}());\n\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar ChartTransform3D = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `ChartTransform3D` class.\n     */\n    function ChartTransform3D() {\n        /** Represents the angle conversion factor from degrees to radians. */\n        this.toRadial = Math.PI / 180;\n        this.vector = new Vector3D(0, 0, 0);\n        this.matrixObj = new Matrix3D();\n    }\n    /**\n     * Creates a 3D transformation based on the specified size.\n     *\n     * @param {Size} size - The size of the viewing area.\n     * @returns {Chart3DBasicTransform} - The 3D transformation.\n     */\n    ChartTransform3D.prototype.transform3D = function (size) {\n        return {\n            viewingArea: size,\n            rotation: 0,\n            tilt: 0,\n            depth: 0,\n            perspectiveAngle: 0,\n            needUpdate: true,\n            centeredMatrix: this.matrixObj.getIdentity(),\n            perspective: this.matrixObj.getIdentity(),\n            resultMatrix: this.matrixObj.getIdentity(),\n            viewMatrix: this.matrixObj.getIdentity()\n        };\n    };\n    /**\n     * Applies the specified 3D transformation to the current state.\n     *\n     * @param {Chart3DBasicTransform} transform - The 3D transformation to apply.\n     * @returns {void} - The 3D transformation.\n     */\n    ChartTransform3D.prototype.transform = function (transform) {\n        this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n        this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n        this.updatePerspective(transform.perspectiveAngle, transform);\n        transform.needUpdate = true;\n    };\n    /**\n     * Updates the perspective matrix based on the specified angle.\n     *\n     * @param {number} angle - The perspective angle.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.updatePerspective = function (angle, transform) {\n        var width = (((transform.viewingArea.width + transform.viewingArea.height) *\n            Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (transform.depth * 2) / 2);\n        transform.perspective[0][0] = width;\n        transform.perspective[1][1] = width;\n        transform.perspective[2][3] = 1;\n        transform.perspective[3][3] = width;\n    };\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {number} - The angle in radians.\n     * @private\n     */\n    ChartTransform3D.prototype.degreeToRadianConverter = function (angle) {\n        return angle * Math.PI / 180;\n    };\n    /**\n     * Transforms a 3D vector to screen coordinates based on the current state.\n     *\n     * @param {Chart3DVector} vector3D - The 3D vector to transform.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @param {Matrix3D} chartObj - Optional custom matrix object for transformation.\n     * @returns {Chart3DLocation} - The screen coordinates.\n     */\n    ChartTransform3D.prototype.toScreen = function (vector3D, transform, chartObj) {\n        if (!chartObj) {\n            transform.chartObj = this.matrixObj;\n            vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n        }\n        else {\n            this.matrixObj = chartObj;\n            vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n        }\n        return { x: vector3D.x, y: vector3D.y };\n    };\n    /**\n     * Sets the view matrix in the transformation state.\n     *\n     * @param {number[][]} matrix - The new view matrix.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.setViewMatrix = function (matrix, transform) {\n        if (transform.viewMatrix === matrix) {\n            return;\n        }\n        transform.viewMatrix = matrix;\n        transform.needUpdate = true;\n    };\n    /**\n     * Calculates the final result matrix based on the current state.\n     *\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @param {Matrix3D} matrixobj - Optional custom matrix object for transformation.\n     * @returns {number[][]} - The final result matrix.\n     */\n    ChartTransform3D.prototype.result = function (transform, matrixobj) {\n        var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n        if (!chartObj) {\n            chartObj = matrixobj;\n        }\n        if (!transform.needUpdate) {\n            return transform.resultMatrix;\n        }\n        var matrixObj = this.matrixObj ? this.matrixObj : matrixobj;\n        transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n        transform.needUpdate = false;\n        return transform.resultMatrix;\n    };\n    /**\n     * Sets the center in the transformation state.\n     *\n     * @param {Chart3DVector} center - The new center vector.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.setCenter = function (center, transform) {\n        transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n        transform.needUpdate = true;\n    };\n    return ChartTransform3D;\n}());\n\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n */\nvar Graphics3D = /** @class */ (function () {\n    function Graphics3D() {\n        /** The vector class. */\n        this.vector = new Vector3D(0, 0, 0);\n    }\n    /**\n     * Adds a visual polygon to the 3D chart and returns its identifier.\n     *\n     * @param {Chart3DPolygon} polygon - The polygon to add.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {number} - The identifier of the added polygon.\n     */\n    Graphics3D.prototype.addVisual = function (polygon, chart) {\n        if (polygon == null || polygonObj.test()) {\n            return -1;\n        }\n        return bspTreeObj.add(polygon, chart);\n    };\n    /**\n     * Prepares the view for rendering based on specified parameters.\n     *\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n        if (chart3DRender.transform == null) {\n            chart3DRender.transform = chart.transform3D.transform3D(size);\n        }\n        else {\n            chart3DRender.transform.viewingArea = size;\n        }\n        if (!chart3DRender.tree) {\n            chart3DRender.tree = [];\n        }\n        chart3DRender.transform.rotation = rotation;\n        chart3DRender.transform.tilt = tilt;\n        chart3DRender.transform.depth = depth;\n        chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n        chart.transform3D.transform(chart3DRender.transform);\n        chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();\n    };\n    /**\n     * Renders the 3D view on the specified panel element.\n     *\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {Chart3D} chart - The 3D chart.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @returns {void}\n     */\n    Graphics3D.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n        var MaxValue = 32767;\n        if (arguments.length === 2) {\n            if (panel == null) {\n                return;\n            }\n            var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);\n        }\n        else {\n            if (panel == null) {\n                return;\n            }\n            if (chart3DRender.transform == null) {\n                chart3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                chart3DRender.transform.viewingArea = size;\n            }\n            chart3DRender.transform.rotation = rotation;\n            chart3DRender.transform.tilt = tilt;\n            chart3DRender.transform.depth = depth;\n            chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(chart3DRender.transform);\n            var eye = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);\n        }\n    };\n    /**\n     * Draws a 3D element based on the specified Binary Space Partitioning Node.\n     *\n     * @param {Chart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.draw3DElement = function (bspElement, chart) {\n        if (bspElement.plane.element) {\n            if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n                polygonObj.drawText(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'template') {\n                polygonObj.drawTemplate(bspElement.plane, chart);\n            }\n            else {\n                polygonObj.drawLine(bspElement.plane, chart);\n            }\n        }\n        else {\n            polygonObj.draw(bspElement.plane, chart);\n        }\n    };\n    /**\n     * Draws the 3D nodes starting from the root based on the eye vector.\n     *\n     * @param {Chart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n     * @param {Chart3DVector} eyeVector - The eye vector.\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n        if (bspElement === null || chart3DRender.transform == null) {\n            return;\n        }\n        var isVector = true;\n        while (isVector) {\n            var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n            if (r > bspElement.plane.d) {\n                if (bspElement.front != null) {\n                    this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.back != null) {\n                    bspElement = bspElement.back;\n                    continue;\n                }\n            }\n            else {\n                if (bspElement.back != null) {\n                    this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.front != null) {\n                    bspElement = bspElement.front;\n                    continue;\n                }\n            }\n            break;\n        }\n    };\n    return Graphics3D;\n}());\n\n/**\n * Represents a binary tree builder for 3D polygons in a chart.\n *\n */\nvar BinaryTreeBuilder = /** @class */ (function () {\n    function BinaryTreeBuilder(chart) {\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.0005;\n        this.chart = chart;\n    }\n    /**\n     * Adds a polygon to the binary tree and returns its index.\n     *\n     * @param {Chart3DPolygon} polygon - The polygon to add.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {number} - The index of the added polygon.\n     */\n    BinaryTreeBuilder.prototype.add = function (polygon, chart) {\n        this.chart = chart;\n        chart.polygons.push(polygon);\n        return chart.polygons.length - 1;\n    };\n    /**\n     * Gets the next index considering the array length and the current index.\n     *\n     * @param {number} index - The current index.\n     * @param {number} count - The length of the array.\n     * @returns {number} - The next index.\n     */\n    BinaryTreeBuilder.prototype.getNext = function (index, count) {\n        if (index >= count) {\n            return index - count;\n        }\n        if (index < 0) {\n            return index + count;\n        }\n        return index;\n    };\n    /**\n     * Creates a PolyAttributes object based on the vector, index, and result.\n     *\n     * @param {Chart3DVector} point - The vector representing the point.\n     * @param {number} index - The index of the point.\n     * @param {string} result - The result classification.\n     * @returns {Chart3DPolyAttributes} - The created PolyAttributes object.\n     */\n    BinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n        return {\n            index: index,\n            result: result,\n            vector: point,\n            isCuttingBackPoint: false,\n            cuttingBackPairIndex: null,\n            alreadyCutBack: false,\n            isCuttingFrontPoint: false,\n            cuttingFrontPairIndex: null,\n            alreadyCutFront: false\n        };\n    };\n    /**\n     * Classifies a point relative to a polygon.\n     *\n     * @param {Chart3DVector} point - The point to classify.\n     * @param {Chart3DPolygon} polygon - The polygon for classification.\n     * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n     */\n    BinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n        var result = 'OnPlane';\n        var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n        if (signedDistance > this.epsilon) {\n            result = 'OnBack';\n        }\n        else if (signedDistance < -this.epsilon) {\n            result = 'OnFront';\n        }\n        return result;\n    };\n    /**\n     * Classifies a polygon relative to another polygon.\n     *\n     * @param {Chart3DPolygon} refPolygon - The reference polygon.\n     * @param {Chart3DPolygon} classPolygon - The polygon to classify.\n     * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n     */\n    BinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n        var result = 'Unknown';\n        var points = classPolygon.points;\n        if (points == null) {\n            return result;\n        }\n        var onBack = 0;\n        var onFront = 0;\n        var onPlane = 0;\n        var normal = refPolygon.normal;\n        var polygonValue = refPolygon.d;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n            if (value > this.epsilon) {\n                onBack++;\n            }\n            else if (value < -this.epsilon) {\n                onFront++;\n            }\n            else {\n                onPlane++;\n            }\n            if (onBack > 0 && onFront > 0) {\n                break;\n            }\n        }\n        if (onPlane === points.length) {\n            result = 'OnPlane';\n        }\n        else if (onFront + onPlane === points.length) {\n            result = 'ToRight';\n        }\n        else if (onBack + onPlane === points.length) {\n            result = 'ToLeft';\n        }\n        else {\n            result = 'Unknown';\n        }\n        return result;\n    };\n    /**\n     * Splits a polygon into two parts based on another polygon.\n     *\n     * @param {Chart3DPolygon} splitPolygon - The polygon to split.\n     * @param {Chart3DPolygon} refPolygon - The reference polygon for splitting.\n     * @returns {Chart3DPolyCollections} - The resulting back and front parts.\n     * @private\n     */\n    BinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n        var backPoint = [];\n        var frontPoint = [];\n        if (splitPolygon.points != null) {\n            var polyPoints = [];\n            var backPartPoints = [];\n            var frontPartPoints = [];\n            var outputs = void 0;\n            var inputs = void 0;\n            var count = splitPolygon.points.length;\n            for (var i = 0; i < count; i++) {\n                var pointB = splitPolygon.points[i];\n                var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n                var sideB = this.classifyPoint(pointB, refPolygon);\n                var sideC = this.classifyPoint(pointC, refPolygon);\n                var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n                polyPoints.push(attributeB);\n                if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n                    var vectorValue = vector.vector3DMinus(pointB, pointC);\n                    var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n                    var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n                    var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n                    var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n                    var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n                    polyPoints.push(attributeIntersection);\n                    backPartPoints.push(attributeIntersection);\n                    frontPartPoints.push(attributeIntersection);\n                }\n                else if (sideB === 'OnPlane') {\n                    var pointA = splitPolygon.points[this.getNext(i - 1, count)];\n                    var sideA = this.classifyPoint(pointA, refPolygon);\n                    if (sideA === sideC) {\n                        continue;\n                    }\n                    if (sideA !== 'OnPlane' && sideC !== 'OnPlane') {\n                        backPartPoints.push(attributeB);\n                        frontPartPoints.push(attributeB);\n                    }\n                    else if (sideA === 'OnPlane') {\n                        switch (sideC) {\n                            case 'OnBack':\n                                backPartPoints.push(attributeB);\n                                break;\n                            case 'OnFront':\n                                frontPartPoints.push(attributeB);\n                                break;\n                        }\n                    }\n                    else if (sideC === 'OnPlane') {\n                        switch (sideA) {\n                            case 'OnBack':\n                                backPartPoints.push(attributeB);\n                                break;\n                            case 'OnFront':\n                                frontPartPoints.push(attributeB);\n                                break;\n                        }\n                    }\n                }\n            }\n            if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n                for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n                    var backAttribute1 = backPartPoints[i];\n                    var backAttribute2 = backPartPoints[i + 1];\n                    backAttribute1.cuttingBackPoint = true;\n                    backAttribute2.cuttingBackPoint = true;\n                    backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n                    backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n                    var frontAttribute1 = frontPartPoints[i];\n                    var frontAttribute2 = frontPartPoints[i + 1];\n                    frontAttribute1.cuttingFrontPoint = true;\n                    frontAttribute2.cuttingFrontPoint = true;\n                    frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n                    frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n                }\n                for (var i = 0; i < backPartPoints.length - 1; i++) {\n                    var backAttribute1 = backPartPoints[i];\n                    if (backAttribute1.alreadyCutBack) {\n                        continue;\n                    }\n                    outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n                    if (outputs.length > 2) {\n                        var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n                        backPoint.push(__assign({}, polygon1));\n                    }\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i++) {\n                    var backAttribute2 = frontPartPoints[i];\n                    if (backAttribute2.alreadyCutFront) {\n                        continue;\n                    }\n                    inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n                    if (inputs.length > 2) {\n                        var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n                        frontPoint.push(__assign({}, polygon2));\n                    }\n                }\n            }\n        }\n        else {\n            backPoint.push(splitPolygon);\n            frontPoint.push(splitPolygon);\n        }\n        return { backPolygon: backPoint, frontPolygon: frontPoint };\n    };\n    /**\n     * Cuts out the front part of a polygon based on the PolyAttributes.\n     *\n     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {Chart3DVector[]} - The resulting points of the front part.\n     */\n    BinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        var isVector = true;\n        while (isVector) {\n            currentVertex.alreadyCutFront = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n            if (currentVertex.cuttingFrontPoint) {\n                if (!currentVertexPair.alreadyCutFront) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Cuts out the back part of a polygon based on the PolyAttributes.\n     *\n     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {Chart3DVector[]} - The resulting points of the back part.\n     */\n    BinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        var isVector = true;\n        while (isVector) {\n            currentVertex.alreadyCutBack = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n            if (currentVertex.cuttingBackPoint) {\n                if (!currentVertexPair.alreadyCutBack) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Builds a Binary Space Partitioning from a list of polygons.\n     *\n     * @param {Chart3DPolygon[]} [points] - The list of polygons to build the tree from.\n     * @returns {Chart3DBspNode} - The root node of the Binary Space Partitioning tree.\n     */\n    BinaryTreeBuilder.prototype.build = function (points) {\n        if (!points) {\n            return this.build(this.chart.polygons);\n        }\n        else {\n            var inputPolygons = points;\n            if (inputPolygons.length < 1) {\n                return null;\n            }\n            var bspNode = { back: null, front: null, plane: null };\n            var plane = inputPolygons[0];\n            bspNode.plane = plane;\n            var polygonsToLeft = [];\n            var polygonsToRight = [];\n            for (var i = 1, len = inputPolygons.length; i < len; i++) {\n                var currentPolygon = inputPolygons[i];\n                if (currentPolygon === plane) {\n                    continue;\n                }\n                var classificationResult = this.classifyPolygon(plane, currentPolygon);\n                switch (classificationResult) {\n                    case 'OnPlane':\n                    case 'ToRight':\n                        polygonsToRight.push(currentPolygon);\n                        break;\n                    case 'ToLeft':\n                        polygonsToLeft.push(currentPolygon);\n                        break;\n                    case 'Unknown':\n                        if (currentPolygon.element && (currentPolygon.element.tag === 'line' || currentPolygon.element.tag === 'text')) {\n                            polygonsToLeft.push(currentPolygon);\n                        }\n                        else {\n                            var result = this.splitPolygon(currentPolygon, plane);\n                            for (var k = 0; k < result.backPolygon.length; k++) {\n                                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                                polygonsToLeft.push(result.backPolygon[k]);\n                            }\n                            for (var j = 0; j < result.frontPolygon.length; j++) {\n                                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                                polygonsToRight.push(result.frontPolygon[j]);\n                            }\n                        }\n                        break;\n                }\n            }\n            if (polygonsToLeft.length > 0) {\n                bspNode.back = this.build(polygonsToLeft);\n            }\n            if (polygonsToRight.length > 0) {\n                bspNode.front = this.build(polygonsToRight);\n            }\n            return bspNode;\n        }\n    };\n    return BinaryTreeBuilder;\n}());\n\n/**\n * The Svg3DRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar Svg3DRenderer = /** @class */ (function () {\n    function Svg3DRenderer() {\n    }\n    /**\n     * Gets a Chart3DStringBuilder instance for constructing strings.\n     *\n     * @returns {Chart3DStringBuilder} - The StringBuilder instance.\n     */\n    Svg3DRenderer.prototype.getStringBuilder = function () {\n        var data = [];\n        var counter = 0;\n        return {\n            append: function (text) {\n                data[counter++] = text;\n                return this;\n            },\n            remove: function (i, j) {\n                data.splice(i, j || 1);\n                return this;\n            },\n            insert: function (i, text) {\n                data.splice(i, 0, text);\n                return this;\n            },\n            toString: function (text) {\n                return data.join(text || '');\n            }\n        };\n    };\n    /**\n     * Parses a hex color code and returns its Red green Blue values.\n     *\n     * @param {string} hexColorCode - The hex color code.\n     * @returns {Chart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n     */\n    Svg3DRenderer.prototype.hexToValue = function (hexColorCode) {\n        var result;\n        var values;\n        if (hexColorCode.indexOf('rgba(') === 0) {\n            values = hexColorCode.slice(5, -1).split(',');\n            return values ? {\n                red: parseInt(values[0], 10),\n                green: parseInt(values[1], 10),\n                blue: parseInt(values[2], 10),\n                alpha: parseFloat(values[3])\n            } : null;\n        }\n        else if (hexColorCode.indexOf('rgb(') === 0) {\n            values = hexColorCode.slice(4, -1).split(',');\n            return values ? {\n                red: parseInt(values[0], 10),\n                green: parseInt(values[1], 10),\n                blue: parseInt(values[2], 10)\n            } : null;\n        }\n        else {\n            result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 16),\n                    green: parseInt(result[2], 16),\n                    blue: parseInt(result[3], 16)\n                }\n                : null;\n        }\n    };\n    /**\n     * Converts a Chart3DColorFormat object to its corresponding color string.\n     *\n     * @param {Chart3DColorFormat} color - The color in Chart3DColorFormat.\n     * @returns {string} - The color string representation.\n     */\n    Svg3DRenderer.prototype.hexColor = function (color) {\n        var redValue = color.red;\n        var greenValue = color.green;\n        var blueValue = color.blue;\n        if (color.alpha) {\n            var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n            return returnColor;\n        }\n        else {\n            var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n            hex_1.forEach(function (val, nr) {\n                if (val.length === 1) {\n                    hex_1[nr] = '0' + val;\n                }\n            });\n            return '#' + hex_1.join('').toUpperCase();\n        }\n    };\n    /**\n     * Checks if a given color string is in a valid format (hex or rgba).\n     *\n     * @param {string} color - The color string to check.\n     * @returns {boolean} - True if the color string is valid, otherwise false.\n     */\n    Svg3DRenderer.prototype.checkColorFormat = function (color) {\n        if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\n            var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\n            if (rgbaValues.length === 3 || rgbaValues.length === 4) {\n                return rgbaValues.every(function (val) {\n                    var num = parseFloat(val);\n                    return !isNaN(num) && num >= 0 && num <= 255;\n                });\n            }\n        }\n        else if (color.indexOf('#') === 0) {\n            var hex = color.substring(1);\n            return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\n        }\n        return false;\n    };\n    /**\n     * Draws text on an SVG element.\n     *\n     * @param {any} options - The options for drawing the text.\n     * @param {string | string[]} label - The text label.\n     * @param {FontModel} font - The font settings for the text.\n     * @param {Chart3D} chart - The 3D chart instance.\n     * @returns {Element} - The created SVG text element.\n     */\n    Svg3DRenderer.prototype.drawText = function (options, label, font, chart) {\n        var text = document.getElementById(options.id);\n        if (text === null) {\n            text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        }\n        if (label.length > 1 && typeof label !== 'string') {\n            var dy = 0;\n            for (var i = 0; i < label.length; i++) {\n                var tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspanElement.textContent = label[i];\n                tspanElement.setAttribute('x', String(options.x));\n                tspanElement.setAttribute('dy', String(dy));\n                text.appendChild(tspanElement);\n                dy = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(label[i], font, chart.themeStyle.axisLabelFont).height;\n            }\n        }\n        else {\n            text.textContent = label;\n        }\n        text = chart.svgRenderer.setElementAttributes(options, text);\n        return text;\n    };\n    /**\n     * Transforms 3D coordinates to visible 2D coordinates on the chart.\n     *\n     * @param {Chart3DSeries} currentSeries - The current 3D series.\n     * @param {number} x - The x-coordinate in 3D space.\n     * @param {number} y - The y-coordinate in 3D space.\n     * @param {Chart3D} chart - The 3D chart instance.\n     * @returns {Chart3DLocation} - The transformed 2D coordinates.\n     */\n    Svg3DRenderer.prototype.transform3DToVisible = function (currentSeries, x, y, chart) {\n        if (currentSeries.xAxis != null && currentSeries.yAxis != null) {\n            var valueType = currentSeries.xAxis.valueType;\n            var xlogarithmicBase = 10; // Replace with the actual logarithmic base if needed\n            var xIsLogarithmic = valueType === 'Logarithmic';\n            // Apply logarithmic transformation if necessary\n            if (xIsLogarithmic && x > 0) {\n                x = Math.log(x) / Math.log(xlogarithmicBase);\n            }\n            var ylogarithmicBase = currentSeries.yAxis.logBase;\n            var yIsLogarithmic = currentSeries.yAxis.valueType === 'Logarithmic';\n            // Apply logarithmic transformation if necessary\n            if (yIsLogarithmic && y > 0) {\n                y = Math.log(y) / Math.log(ylogarithmicBase);\n            }\n            // Adjust the coordinates based on inverted axes\n            if (chart.requireInvertedAxis) {\n                var left = chart.chartAxisLayoutPanel.seriesClipRect.x;\n                var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;\n                var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);\n                var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));\n                return { x: pointX, y: pointY };\n            }\n            else {\n                var left = currentSeries.xAxis.rect.x;\n                var top_2 = currentSeries.yAxis.rect.y;\n                var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));\n                var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));\n                return { x: newX, y: newY };\n            }\n        }\n        // Return a default Point if xAxis and yAxis are null\n        return { x: 0, y: 0 };\n    };\n    return Svg3DRenderer;\n}());\n\n/**\n * Represents a 3D polygon in a chart.\n *\n */\nvar Polygon3D = /** @class */ (function () {\n    function Polygon3D() {\n        /** A small constant used for numerical comparisons. */\n        this.epsilon = 0.00001;\n        /** A small constant used for numerical comparisons. */\n        this.normal = { x: 0, y: 0, z: 0 };\n        /** A small constant used for numerical comparisons. */\n        this.vector = new Vector3D(0, 0, 0);\n        /** A small constant used for numerical comparisons. */\n        this.vectorPoints = [];\n        /** A small constant used for numerical comparisons. */\n        this.matrixObj = new Matrix3D();\n        /** A small constant used for numerical comparisons. */\n        this.tabIndex = true;\n    }\n    /**\n     * Creates a 3D polygon.\n     *\n     * @param {Chart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n     * @param {any} [tag] - Additional information or metadata for the polygon.\n     * @param {number} [index] - An index associated with the polygon.\n     * @param {string} [stroke] - The stroke color of the polygon.\n     * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n     * @param {number} [opacity] - The opacity of the polygon.\n     * @param {string} [fill] - The fill color of the polygon.\n     * @param {string} [name] - The name or identifier of the polygon.\n     * @param {Element} [parent] - The parent element to which the polygon belongs.\n     * @param {string} [text] - Additional text associated with the polygon.\n     * @returns {Chart3DPolygon} - Returns the created polygon.\n     */\n    Polygon3D.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n        if (arguments.length === 3) {\n            this.calculateNormal(points, tag, index);\n            return null;\n        }\n        else if (arguments.length === 2) {\n            //points = arguments[0];\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var polygon = tag;\n            polygon.normal = this.normal;\n            polygon.points = points;\n            polygon.vectorPoints = this.vectorPoints;\n            polygon.isSplit = true;\n            polygon.d = this.d;\n            return polygon;\n        }\n        else {\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var element = { tag: 'path', parent: parent };\n            var polygon = {\n                normal: this.normal,\n                points: points,\n                vectorPoints: this.vectorPoints,\n                index: index,\n                tag: tag,\n                name: name ? name : null,\n                strokeThickness: strokeThickness,\n                opacity: opacity,\n                fill: fill,\n                d: this.d,\n                text: text ? text : '',\n                polygonElement: element\n            };\n            if (arguments.length !== 1) {\n                polygon.polygonElement = element;\n            }\n            return polygon;\n        }\n    };\n    /**\n     * Creates a 3D line.\n     *\n     * @param {Chart3DTickElement} line - The tick elements associated with the line.\n     * @param {number} x1 - The x-coordinate of the starting point.\n     * @param {number} y1 - The y-coordinate of the starting point.\n     * @param {number} x2 - The x-coordinate of the ending point.\n     * @param {number} y2 - The y-coordinate of the ending point.\n     * @param {number} depth - The depth or z-coordinate of the line in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D line as a polygon.\n     */\n    Polygon3D.prototype.createLine = function (line, x1, y1, x2, y2, depth) {\n        var strokeThickness = line.width;\n        var vectorCollection = [];\n        vectorCollection[0] = this.vector.vector3D(x1, y1, depth);\n        vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);\n        vectorCollection[2] = this.vector.vector3D(x2, y2, depth);\n        return this.line3D(line, vectorCollection);\n    };\n    /**\n     *  Creates a 3D line polygon based on the given tick elements and points.\n     *\n     * @param {Chart3DTickElement} element - The tick elements associated with the line.\n     * @param {Chart3DVector[]} points - The array of 3D vector points defining the line in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D line polygon.\n     */\n    Polygon3D.prototype.line3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D text polygon based on the given label element and points.\n     *\n     * @param {Chart3DLabelElement} element - The label element associated with the text.\n     * @param {Chart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D text polygon.\n     */\n    Polygon3D.prototype.text3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D cylinder based on the given vectors, chart, and styling parameters.\n     *\n     * @param {Chart3DVector} v1 - The start vector of the cylinder.\n     * @param {Chart3DVector} v2 - The end vector of the cylinder.\n     * @param {Chart3D} chart - The 3D chart to which the cylinder belongs.\n     * @param {number} index - The index of the cylinder.\n     * @param {string} type - The type of the cylinder.\n     * @param {string} stroke - The stroke color of the cylinder.\n     * @param {string} fill - The fill color of the cylinder.\n     * @param {number} strokeThickness - The thickness of the stroke.\n     * @param {number} opacity - The opacity of the cylinder.\n     * @param {string} name - The name of the cylinder.\n     * @param {Element} parent - The parent element of the cylinder.\n     * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D cylinder.\n     */\n    Polygon3D.prototype.createCylinder = function (v1, //top left front vecotr.\n    v2, // bottom right back vector.\n    chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {\n        var i = 0; //cylinder path count.\n        var offsetX;\n        var offsetY;\n        var offsetZ;\n        var vectorCollection;\n        var pathCount = 24;\n        var theta = 360 / pathCount;\n        var degreeToRadian = Math.PI / 180;\n        var centerZ = (v1.z + v2.z) / 2;\n        var result = [];\n        var outPoints = [];\n        var topVector = [];\n        var bottomVector = [];\n        var radiusB = (v2.y - v1.y) < (v2.z - v1.z) ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;\n        var radiusC = (v2.x - v1.x) < (v2.z - v1.z) ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;\n        var centerX = (v1.x + v2.x) / 2;\n        var centerY = (v1.y + v2.y) / 2;\n        switch (type) {\n            case 'Bar':\n            case 'StackingBar':\n            case 'StackingBar100':\n                pathCount++;\n                while (pathCount--) {\n                    offsetY = centerY + radiusB * Math.cos((i * theta) * degreeToRadian);\n                    offsetZ = centerZ + radiusB * Math.sin((i * theta) * degreeToRadian);\n                    outPoints[i] = { Y: offsetY, Z: offsetZ };\n                    topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));\n                    bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));\n                    if (i > 0) {\n                        vectorCollection = [\n                            this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z),\n                            this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z),\n                            this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z),\n                            this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)\n                        ];\n                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, ('-' + (i + 1).toString() + '-' + name), parent);\n                        graphics.addVisual(result[i + 1], chart);\n                    }\n                    i++;\n                }\n                break;\n            case 'Column':\n            case 'StackingColumn':\n            case 'StackingColumn100':\n                pathCount++;\n                while (pathCount--) {\n                    offsetX = centerX + radiusC * Math.cos((i * theta) * degreeToRadian);\n                    offsetZ = centerZ + radiusC * Math.sin((i * theta) * degreeToRadian);\n                    outPoints[i] = { Y: offsetX, Z: offsetZ };\n                    topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));\n                    bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));\n                    if (i > 0) {\n                        vectorCollection = [\n                            this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z),\n                            this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z),\n                            this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z),\n                            this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)\n                        ];\n                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n                        graphics.addVisual(result[i + 1], chart);\n                    }\n                    i++;\n                }\n                break;\n        }\n        result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, '-0-' + name, parent);\n        result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent);\n        graphics.addVisual(result[0], chart);\n        graphics.addVisual(result[1], chart);\n        return result;\n    };\n    /**\n     * Creates a 3D box based on the given vectors, chart, and styling parameters.\n     *\n     * @param {Chart3DVector} v1 - The start vector of the box.\n     * @param {Chart3DVector} v2 - The end vector of the box.\n     * @param {Chart3D} chart - The 3D chart to which the box belongs.\n     * @param {number} index - The index of the box.\n     * @param {string} stroke - The stroke color of the box.\n     * @param {string} fill - The fill color of the box.\n     * @param {number} strokeThickness - The thickness of the stroke.\n     * @param {number} opacity - The opacity of the box.\n     * @param {boolean} inverse - A boolean indicating whether to inverse the box.\n     * @param {string} name - The name of the box.\n     * @param {Element} parent - The parent element of the box.\n     * @param {string} [text] - Optional text associated with the box.\n     * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D box.\n     *\n     */\n    Polygon3D.prototype.createBox = function (v1, //top left front vecotr.\n    v2, // bottom right back vector.\n    chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {\n        var result = [];\n        var point1 = [\n            this.vector.vector3D(v1.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point2 = [\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v2.z)\n        ];\n        var point3 = [\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v1.x, v1.y, v1.z)\n        ];\n        var point4 = [\n            this.vector.vector3D(v1.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point5 = [\n            this.vector.vector3D(v1.x, v1.y, v1.z),\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point6 = [\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z)\n        ];\n        if (name) {\n            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + name, parent, text);\n            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent, text);\n            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + name, parent, text);\n            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + name, parent, text);\n            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + name, parent, text);\n            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + name, parent, text);\n        }\n        else {\n            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + index, parent, text);\n            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + index, parent, text);\n            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + index, parent, text);\n            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + index, parent, text);\n            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + index, parent, text);\n            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + index, parent, text);\n        }\n        if (inverse) {\n            graphics.addVisual(result[0], chart);\n            graphics.addVisual(result[1], chart);\n            graphics.addVisual(result[2], chart);\n            graphics.addVisual(result[3], chart);\n            graphics.addVisual(result[4], chart);\n            graphics.addVisual(result[5], chart);\n        }\n        else {\n            graphics.addVisual(result[5], chart);\n            graphics.addVisual(result[4], chart);\n            graphics.addVisual(result[0], chart);\n            graphics.addVisual(result[1], chart);\n            graphics.addVisual(result[2], chart);\n            graphics.addVisual(result[3], chart);\n        }\n        return result;\n    };\n    /**\n     * Calculates the normal vector for a 3D polygon based on the provided points.\n     *\n     * @param {...Chart3DVector} args - Variable number of vector3d arguments representing points of the polygon.\n     * @returns {void}\n     */\n    Polygon3D.prototype.calculateNormal = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length >= 3) {\n            // Relative information of the points\n            var vector1 = args[0];\n            var vector2 = args[1];\n            var vector3 = args[2];\n            var vector4 = this.vector.vector3DMinus(vector1, vector2);\n            var vector5 = this.vector.vector3DMinus(vector3, vector2);\n            var normal = this.vector.vector3DMultiply(vector4, vector5);\n            var length_1 = this.vector.getLength(normal); // Get length of the vector\n            if (length_1 < this.epsilon) {\n                length_1 = 1;\n            }\n            this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n            this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n            if (args[3]) {\n                args[3].normal = this.normal;\n                args[3].d = this.d;\n            }\n        }\n        else {\n            var Points = args[0];\n            this.calculateNormal(Points[0], Points[1], Points[2], args[1]);\n            for (var i = 3; (i < Points.length) && (this.test()); i++) {\n                this.calculateNormal(Points[i], Points[0], Points[i / 2]);\n            }\n        }\n    };\n    /**\n     * Tests whether the calculated normal vector is valid.\n     *\n     * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n     */\n    Polygon3D.prototype.test = function () {\n        return !this.vector.isValid(this.normal);\n    };\n    /**\n     * Transforms the vector points of the specified polygon using the provided matrix.\n     *\n     * @param {number[][]} matrix - The transformation matrix.\n     * @param {Chart3DPolygon} polygon - The polygon to transform.\n     * @returns {void}\n     */\n    Polygon3D.prototype.transform = function (matrix, polygon) {\n        if (polygon.points != null) {\n            for (var i = 0; i < polygon.points.length; i++) {\n                polygon.vectorPoints[i] = polygon.points[i] =\n                    matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);\n            }\n            this.calculateNormal(polygon.vectorPoints, polygon);\n        }\n    };\n    /**\n     *  Gets the normal vector based on the transformed points using the specified transformation matrix.\n     *\n     * @param {number[][]} transform - The transformation matrix.\n     * @param {Chart3DVector[]} [vectorPoints] - The vector points.\n     * @returns {Chart3DVector} - Returns the normal vector.\n     * @private\n     */\n    Polygon3D.prototype.getNormal = function (transform, vectorPoints) {\n        var normal;\n        if (vectorPoints != null) {\n            normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n            for (var i = 3; (i < vectorPoints.length) && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n                var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n                var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n                var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n                normal = this.vector.getNormal(v1, v2, v3);\n            }\n        }\n        else {\n            normal = matrixObj.getMatrixVectorAnd(transform);\n            this.vector.normalize();\n        }\n        return normal;\n    };\n    /**\n     * A method for creating text element.\n     *\n     * @param {Chart3DVector} position - text position.\n     * @param {Chart3DLabelElement} element - text element.\n     * @param {number} xLength - text element x value.\n     * @param {number} yLength - text element y value.\n     * @returns {Chart3DPolygon} - Returns the polygon.\n     */\n    Polygon3D.prototype.createTextElement = function (position, element, xLength, yLength) {\n        var vectorCollection = [];\n        var x = position.x;\n        var y = position.y;\n        var desiredWidth = element.width;\n        var desiredHeight = element.height;\n        vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n        vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n        vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n        return this.text3D(element, vectorCollection);\n    };\n    /**\n     * Draws a template on the specified 3D chart panel.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the template will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawLine = function (panel, chart) {\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n        var optionsLine = {\n            'id': panel.element.id,\n            'x1': actual3DPosition1.x,\n            'y1': actual3DPosition1.y,\n            'x2': actual3DPosition2.x,\n            'y2': actual3DPosition2.y,\n            'stroke-dasharray': '',\n            'stroke-width': panel.element.width,\n            'stroke': panel.element.stroke,\n            'opacity': panel.element.opacity\n        };\n        chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(optionsLine.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = optionsLine.id;\n    };\n    /**\n     * Draws text on the specified 3D chart panel.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawTemplate = function (panel, chart) {\n        var element = panel.element;\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var label = element.label;\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a three-dimensional series.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawText = function (panel, chart) {\n        var element = panel.element;\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var x = actual3DPosition.x;\n        var y = actual3DPosition.y;\n        if (element.tag === 'text') {\n            var options = {\n                'id': element.id,\n                'x': x,\n                'y': y,\n                'fill': element.font.color || element.fill,\n                'font-size': element.font.size,\n                'font-family': element.font.fontFamily,\n                'font-style': element.font.fontStyle,\n                'font-weight': element.font.fontWeight,\n                'opacity': element.font.opacity,\n                'text-anchor': element.textAnchor,\n                'cursor': 'default',\n                'transform': element.angle ? 'rotate(' + element.angle + ',' + (x) + ',' + y + ')' : ''\n            };\n            var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n            if (element.id.indexOf('-axis-title') > -1) {\n                textElement.setAttribute('aria-hidden', 'true');\n            }\n            chart.chart3D.append(textElement);\n        }\n        else {\n            var series = element.series;\n            var labelFormat = (series.yAxis && series.yAxis.labelFormat) ? series.yAxis.labelFormat : '';\n            var pointText = (element.point.text) ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);\n            var textOffset = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);\n            var margin = series.dataLabel.margin;\n            var width = textOffset.width + margin.left + margin.right;\n            var height = textOffset.height + margin.top + margin.bottom;\n            var location_1 = { x: actual3DPosition.x, y: actual3DPosition.y };\n            var xXalue = location_1.x - (margin.left) / 2 + (margin.right) / 2;\n            var yValue = location_1.y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;\n            var seriesIndex = series.index;\n            this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);\n        }\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a three-dimensional series.\n     *\n     * @param {number} seriesIndex - The index of the series to which the data point belongs.\n     * @param {Chart3DSeries} series - The three-dimensional series containing the data point.\n     * @param {number} pointIndex - The index of the data point within the series.\n     * @param {number} x - The x-coordinate of the center of the symbol.\n     * @param {number} y - The y-coordinate of the center of the symbol.\n     * @param {number} width - The width of the symbol.\n     * @param {number} height - The height of the symbol.\n     * @param {Chart3D} chart - The three-dimensional chart containing the series.\n     * @returns {void}\n     */\n    Polygon3D.prototype.dataLabelSymbol = function (seriesIndex, series, pointIndex, x, y, width, height, chart) {\n        var path = 'M' + ' ' + (x + (-width / 2)) + ' ' +\n            (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (-height / 2)) + ' z';\n        var Rectoptions = {\n            id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-point-' + pointIndex,\n            fill: series.dataLabel.fill,\n            'stroke-width': series.dataLabel.border.width,\n            'stroke-dasharray': series.dataLabel.border.dashArray,\n            stroke: series.dataLabel.border.color,\n            opacity: series.dataLabel.opacity,\n            visibility: '',\n            d: path\n        };\n        var element = chart.svgRenderer.drawPath(Rectoptions);\n        chart.chart3D.append(element);\n    };\n    /**\n     * Draws a three-dimensional polygon on the specified chart.\n     *\n     * @param {Chart3DPolygon} panel - The polygon to be drawn.\n     * @param {Chart3D} chart - The three-dimensional chart on which the polygon is to be drawn.\n     * @returns {void}\n     */\n    Polygon3D.prototype.draw = function (panel, chart) {\n        if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n            return;\n        }\n        var transform = chart3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var color = panel.fill;\n        var format = chart.svg3DRenderer.checkColorFormat(color);\n        if (!format) {\n            if (color !== 'transparent') {\n                color = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.colorNameToHex)(color);\n            }\n        }\n        var figure = { StartPoint: null };\n        if (transform != null) {\n            figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n            pathDirection.append('M' + ' ' + (figure.StartPoint.x) + ' ' + (figure.StartPoint.y) + ' ');\n            for (var i = 0; i < panel.vectorPoints.length; i++) {\n                var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n                pathDirection.append('L' + ' ' + (lineSegment.x) + ' ' + (lineSegment.y) + ' ');\n            }\n        }\n        var direction = pathDirection.toString();\n        var name = 'Light';\n        var lightCoefficientZ = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1));\n        var lightCoefficientY = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1));\n        var lightCoefficientX = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1));\n        if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n            if (lightCoefficientZ === lightCoefficientX) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else if (((lightCoefficientY === lightCoefficientZ) || (lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ))) {\n                name = 'XLight';\n                color = this.applyXLight(color, chart);\n            }\n            else if (lightCoefficientZ < 0) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else {\n                name = 'Light';\n            }\n        }\n        var options = {\n            'id': chart.element.id + '-svg' + panel.name,\n            'name': name,\n            'fill': color,\n            'stroke': '',\n            'stroke-width': panel.strokeThickness,\n            'opacity': panel.opacity,\n            'd': direction\n        };\n        var element = chart.svgRenderer.drawPath(options);\n        if (panel.text) {\n            element.setAttribute('aria-label', panel.text);\n            element.setAttribute('role', 'img');\n        }\n        if (panel.name && panel.name.indexOf('-wall-brush') > -1) {\n            element.setAttribute('aria-hidden', 'true');\n        }\n        if (element.id.indexOf('0-region-series-0-point-0') > -1) {\n            if (this.tabIndex) {\n                element.setAttribute('tabindex', '0');\n            }\n            else {\n                var elements = panel.polygonElement.parent.querySelectorAll('[id*=\"0-region-series-0-point-0\"]');\n                if (elements.length > 0) {\n                    elements[elements.length - 1].removeAttribute('tabindex');\n                }\n                element.setAttribute('tabindex', '0');\n            }\n            this.tabIndex = false;\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(options.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = options.id;\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green and blue components.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    Polygon3D.prototype.applyXLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green and blue components with a focus on the Z-axis.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    Polygon3D.prototype.applyZLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    return Polygon3D;\n}());\n\nvar vector = new Vector3D(0, 0, 0);\nvar matrixObj = new Matrix3D();\nvar bspTreeObj = new BinaryTreeBuilder();\nvar polygonObj = new Polygon3D();\nvar graphics = new Graphics3D();\n/**\n * Gets the minimum delta value between adjacent data points on a given axis in a three-dimensional chart.\n *\n * @param {Chart3DAxis} axis - The three-dimensional axis for which the delta value is calculated.\n * @param {Chart3DSeries[]} seriesCollection - Collection of three-dimensional series in the chart.\n * @returns {number} - The minimum delta value between adjacent data points on the specified axis.\n */\nfunction getMinPointsDeltaValue(axis, seriesCollection) {\n    var minDelta = Number.MAX_VALUE;\n    var xValues;\n    var minVal;\n    var seriesMin;\n    for (var index = 0; index < seriesCollection.length; index++) {\n        var series = seriesCollection[index];\n        xValues = [];\n        if (series.visible &&\n            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null))) {\n            xValues = series.points.map(function (point) {\n                return point.xValue;\n            });\n            xValues.sort(function (first, second) { return first - second; });\n            if (xValues.length === 1) {\n                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;\n                minVal = xValues[0] - (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(seriesMin) ?\n                    seriesMin : axis.visibleRange.min);\n                if (minVal !== 0) {\n                    minDelta = Math.min(minDelta, minVal);\n                }\n            }\n            else {\n                for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n                    var value = xValues[index_1];\n                    if (index_1 > 0 && value) {\n                        minVal = value - xValues[index_1 - 1];\n                        if (minVal !== 0) {\n                            minDelta = Math.min(minDelta, minVal);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (minDelta === Number.MAX_VALUE) {\n        minDelta = 1;\n    }\n    return minDelta;\n}\n/**\n * Converts a numeric value to a coefficient based on the given 3D axis.\n *\n * @param {number} value - The numeric value to be converted.\n * @param {Chart3DAxis} axis - The 3D axis for reference.\n * @returns {number} - The coefficient value.\n * @private\n */\nfunction valueToCoefficients(value, axis) {\n    var range = axis.visibleRange;\n    var result = (value - range.min) / (range.delta);\n    var isInverse = axis.isAxisInverse;\n    return isInverse ? (1 - result) : result;\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js?");

/***/ })

}]);