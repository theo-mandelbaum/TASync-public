"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_annotation_sticky-notes-annotation-748f6c89"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/sticky-notes-annotation.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/sticky-notes-annotation.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StickyNotesAnnotation: () => (/* binding */ StickyNotesAnnotation)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_navigations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-navigations */ \"./node_modules/@syncfusion/ej2-navigations/index.js\");\n/* harmony import */ var _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-inplace-editor */ \"./node_modules/@syncfusion/ej2-inplace-editor/index.js\");\n/* harmony import */ var _drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/drawing-util */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/drawing-util.js\");\n\n\n\n\n\n/**\n * StickyNotes module\n */\nvar StickyNotesAnnotation = /** @class */ (function () {\n    /**\n     * @param {PdfViewer} pdfViewer - It describes about the pdfviewer\n     * @param {PdfViewerBase} pdfViewerBase - It describes about the pdfviewer base\n     * @private\n     */\n    function StickyNotesAnnotation(pdfViewer, pdfViewerBase) {\n        this.moreButtonId = '';\n        this.commentsCount = 0;\n        this.commentsreplyCount = 0;\n        this.commentContextMenu = [];\n        this.isAccordionContainer = true;\n        this.isCreateContextMenu = false;\n        this.isCommentsSelected = false;\n        /**\n         * @private\n         */\n        this.isAddAnnotationProgramatically = false;\n        /**\n         * @private\n         */\n        this.isEditableElement = false;\n        this.isPageCommentsRendered = false;\n        this.isCommentsRendered = false;\n        /**\n         * @private\n         */\n        this.isAnnotationRendered = false;\n        /**\n         * @private\n         */\n        this.textFromCommentPanel = false;\n        this.pdfViewer = pdfViewer;\n        this.pdfViewerBase = pdfViewerBase;\n        this.opacity = this.pdfViewer.stickyNotesSettings.opacity ? this.pdfViewer.stickyNotesSettings.opacity : 1;\n    }\n    /**\n     * @param {any} stickyAnnotations - It describes about the sticky annotations\n     * @param {number} pageNumber - It describes about the page number\n     * @param {any} canvas - It describes about the canvas\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.renderStickyNotesAnnotations = function (stickyAnnotations, pageNumber, canvas) {\n        if (stickyAnnotations) {\n            if (stickyAnnotations.length > 0) {\n                for (var i = 0; i < stickyAnnotations.length; i++) {\n                    var annotation = stickyAnnotations[parseInt(i.toString(), 10)];\n                    var isAdded = false;\n                    var pageAnnotations = this.getAnnotations(pageNumber, null, 'sticky');\n                    if (pageAnnotations !== null) {\n                        for (var k = 0; k < pageAnnotations.length; k++) {\n                            var annotationName = annotation.annotName ? annotation.annotName : annotation.AnnotName;\n                            var pageAnnotationName = pageAnnotations[parseInt(k.toString(), 10)].annotName ?\n                                pageAnnotations[parseInt(k.toString(), 10)].annotName :\n                                pageAnnotations[parseInt(k.toString(), 10)].AnnotName;\n                            if (pageAnnotationName && annotationName && pageAnnotationName === annotationName) {\n                                isAdded = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!isAdded) {\n                        annotation.annotationAddMode =\n                            this.pdfViewer.annotationModule.findAnnotationMode(annotation, pageNumber, annotation.AnnotType);\n                        var annotationObject = null;\n                        var position = annotation.Bounds;\n                        var author = annotation.Author;\n                        annotation.AnnotationSettings = annotation.AnnotationSettings ?\n                            annotation.AnnotationSettings : this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n                        annotation.allowedInteractions = annotation.AllowedInteraction ?\n                            annotation.AllowedInteraction : this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n                        var isPrint = true;\n                        if (annotation.annotationAddMode === 'Imported Annotation') {\n                            isPrint = annotation.IsPrint;\n                        }\n                        else {\n                            isPrint = annotation.AnnotationSettings.isPrint;\n                        }\n                        if (annotation.IsLock || annotation.IsLocked) {\n                            annotation.AnnotationSettings.isLock = annotation.IsLock ? annotation.IsLock : annotation.IsLocked;\n                        }\n                        annotationObject = {\n                            shapeAnnotationType: 'sticky', author: author, modifiedDate: annotation.ModifiedDate, subject: annotation.Subject, note: annotation.Note, opacity: annotation.Opacity, state: annotation.State, stateModel: annotation.StateModel,\n                            pathData: '', comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, author), review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate, author: author }, pageNumber: pageNumber,\n                            bounds: { left: annotation.Bounds.X, top: annotation.Bounds.Y, width: annotation.Bounds.Width,\n                                height: annotation.Bounds.Height, right: annotation.Bounds.Right, bottom: annotation.Bounds.Bottom },\n                            annotName: annotation.AnnotName, color: annotation.color,\n                            annotationSelectorSettings: this.getSettings(annotation),\n                            customData: this.pdfViewer.annotation.getCustomData(annotation),\n                            annotationSettings: annotation.AnnotationSettings, allowedInteractions: annotation.allowedInteractions,\n                            isPrint: isPrint, isCommentLock: annotation.IsCommentLock\n                        };\n                        annotation.AnnotationSelectorSettings = annotation.AnnotationSelectorSettings ?\n                            annotation.AnnotationSelectorSettings : this.pdfViewer.annotationSelectorSettings;\n                        var annot = {\n                            author: author, modifiedDate: annotationObject.modifiedDate, annotName: annotationObject.annotName, pageIndex: pageNumber, bounds: { x: position.Left, y: position.Top, width: position.Width, height: position.Height }, strokeColor: 'transparent', stampStrokeColor: '', data: this.setImageSource(), shapeAnnotationType: 'StickyNotes',\n                            subject: annotationObject.subject, notes: annotationObject.note, opacity: annotationObject.opacity,\n                            id: annotationObject.annotName, fillColor: annotationObject.color,\n                            annotationSelectorSettings: annotation.AnnotationSelectorSettings,\n                            annotationSettings: annotationObject.annotationSettings,\n                            annotationAddMode: annotation.annotationAddMode, isPrint: isPrint, isCommentLock: annotationObject.isCommentLock\n                        };\n                        if (canvas) {\n                            this.drawStickyNotes(position.Left, position.Top, position.Width, position.Height, pageNumber, annot, canvas);\n                        }\n                        else {\n                            this.pdfViewer.add(annot);\n                            this.drawStickyNotes(position.Left, position.Top, position.Width, position.Height, pageNumber, annot);\n                            this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_sticky');\n                        }\n                        if (this.isAddAnnotationProgramatically) {\n                            var settings = {\n                                opacity: annot.opacity, borderColor: annot.strokeColor, borderWidth: annot.thickness,\n                                author: annotation.author, subject: annotation.subject, modifiedDate: annotation.modifiedDate,\n                                fillColor: annot.fillColor, fontSize: annot.fontSize, width: annot.bounds.width,\n                                height: annot.bounds.height, fontColor: annot.fontColor, fontFamily: annot.fontFamily,\n                                defaultText: annot.dynamicText, fontStyle: annot.font, textAlignment: annot.textAlign\n                            };\n                            this.pdfViewer.fireAnnotationAdd(annot.pageIndex, annot.annotName, 'StickyNotes', annot.bounds, settings);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.getSettings = function (annotation) {\n        var selector = this.pdfViewer.annotationSelectorSettings;\n        if (annotation.AnnotationSelectorSettings) {\n            selector = typeof (annotation.AnnotationSelectorSettings) === 'string' ? JSON.parse(annotation.AnnotationSelectorSettings) : annotation.AnnotationSelectorSettings;\n        }\n        else if (this.pdfViewer.stickyNotesSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.stickyNotesSettings.annotationSelectorSettings;\n        }\n        return selector;\n    };\n    /**\n     * @param {number} X - It describes about the X\n     * @param {number} Y - It describes about the Y\n     * @param {number} width - It describes about the width\n     * @param {number} height - It describes about the height\n     * @param {number} pageIndex - It describes about the page index\n     * @param {any} annotation - It describes about the annotation\n     * @param {any} canvas - It describes about the canvas\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.drawStickyNotes = function (X, Y, width, height, pageIndex, annotation, canvas) {\n        var _this = this;\n        var annot;\n        var annotationObject = null;\n        var image = new Image();\n        // eslint-disable-next-line\n        var proxy = this;\n        image.onload = function () {\n            var commentsDivid;\n            var annotationName;\n            var author = (_this.pdfViewer.annotationSettings.author !== 'Guest') ? _this.pdfViewer.annotationSettings.author : _this.pdfViewer.stickyNotesSettings.author;\n            var subject = (_this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(_this.pdfViewer.annotationSettings.subject)) ? _this.pdfViewer.annotationSettings.subject : _this.pdfViewer.stickyNotesSettings.subject ? _this.pdfViewer.stickyNotesSettings.subject : 'Sticky Note';\n            var annotationSettings = _this.pdfViewer.annotationModule.updateSettings(_this.pdfViewer.stickyNotesSettings);\n            if (annotation) {\n                annot = {\n                    author: annotation.author, modifiedDate: annotation.modifiedDate, annotName: annotation.annotName, annotationSettings: annotation.annotationSettings && annotation.annotationSettings !== '' ? annotation.annotationSettings : annotationSettings,\n                    data: image.src, bounds: { x: X, y: Y, width: width, height: height }, subject: annotation.subject,\n                    notes: annotation.notes, opacity: annotation.opacity, id: annotation.annotName, shapeAnnotationType: 'StickyNotes', strokeColor: 'transparent', stampStrokeColor: '', pageIndex: annotation.pageIndex, isPrint: annotation.isPrint\n                };\n            }\n            else {\n                annotationName = _this.pdfViewer.annotation.createGUID();\n                commentsDivid = proxy.addComments('sticky', pageIndex + 1);\n                if (commentsDivid) {\n                    document.getElementById(commentsDivid).id = annotationName;\n                }\n                var annotationSelectorSettings = _this.pdfViewer.stickyNotesSettings.annotationSelectorSettings ?\n                    _this.pdfViewer.stickyNotesSettings.annotationSelectorSettings : _this.pdfViewer.annotationSelectorSettings;\n                var isPrint = _this.pdfViewer.stickyNotesSettings.isPrint;\n                annot = {\n                    bounds: { x: X, y: Y, width: width, height: height }, pageIndex: pageIndex, data: image.src,\n                    modifiedDate: _this.getDateAndTime(), annotationSettings: annotationSettings,\n                    shapeAnnotationType: 'StickyNotes', strokeColor: 'transparent', stampStrokeColor: '', annotName: annotationName, id: annotationName, opacity: _this.opacity, isPrint: isPrint\n                };\n                var isLock = _this.pdfViewer.stickyNotesSettings.isLock ?\n                    _this.pdfViewer.stickyNotesSettings.isLock : _this.pdfViewer.annotationSettings.isLock;\n                var allowedInteractions = _this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n                annotationObject = {\n                    author: author, allowedInteractions: allowedInteractions, modifiedDate: _this.getDateAndTime(), subject: subject, shapeAnnotationType: 'sticky', pageNumber: pageIndex,\n                    note: '', opacity: _this.opacity, pathData: '', state: '', stateModel: '', color: 'rgba(255,255,0)', comments: [], annotName: annotationName,\n                    bounds: { left: X, top: Y, width: width, height: height }, review: { state: '', stateModel: '', modifiedDate: '', author: author },\n                    annotationSelectorSettings: annotationSelectorSettings,\n                    customData: _this.pdfViewer.annotationModule.getData('sticky'), annotationSettings: { isLock: isLock }, isPrint: isPrint, isCommentLock: false\n                };\n            }\n            if (!annotation) {\n                proxy.pdfViewer.annotation.addAction(pageIndex, null, annot, 'Addition', '', annot, annot);\n                proxy.pdfViewer.add(annot);\n                proxy.pdfViewer.annotationModule.storeAnnotations(pageIndex, annotationObject, '_annotations_sticky');\n            }\n            if (proxy.pdfViewerBase.isAddComment) {\n                var bounds = { left: annot.bounds.x, top: annot.bounds.y, width: annot.bounds.width, height: annot.bounds.height };\n                _this.pdfViewerBase.updateDocumentEditedProperty(true);\n                var settings = { opacity: annot.opacity, author: author, modifiedDate: annot.modifiedDate, subject: subject };\n                _this.pdfViewer.fireAnnotationAdd(annot.pageIndex, annot.annotName, 'StickyNotes', bounds, settings);\n            }\n            if (canvas) {\n                proxy.pdfViewer.renderDrawing(canvas, pageIndex);\n            }\n            else {\n                var canvass = _this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', pageIndex);\n                proxy.pdfViewer.renderDrawing(canvass, pageIndex);\n            }\n            if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice) {\n                proxy.pdfViewer.select([annot.id], annot.annotationSelectorSettings);\n            }\n            proxy.pdfViewerBase.isAddComment = false;\n        };\n        image.src = this.setImageSource();\n    };\n    StickyNotesAnnotation.prototype.setImageSource = function () {\n        var imageSource = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgd2lkdGg9IjE2IgogICBoZWlnaHQ9IjE1IgogICB2aWV3Qm94PSIwIDAgNC4yMzMzMzMxIDMuOTY4NzQ5NyIKICAgdmVyc2lvbj0iMS4xIj4KICA8ZyBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBkPSJNIDMuODM4OSwwLjk0MTY3IEMgMy42NTM5LDAuNzAzNjcgMy40MTU5LDAuNTE3NjcgMy4xMjQ5LDAuMzg1NjcgMi44MDc5LDAuMjUzNjcgMi40ODk5LDAuMTczNjcgMi4xMTk5LDAuMTczNjcgMS43NDg5LDAuMTczNjcgMS40MzE5LDAuMjUzNjcgMS4xMTQyLDAuMzg1NjcgMC44MjMxNiwwLjUxNzY3IDAuNTg1MTYsMC43MDM2NyAwLjQwMDE2LDAuOTQxNjcgMC4yMTUxNiwxLjE3OTcgMC4xMzUxNiwxLjQxNzcgMC4xMzUxNiwxLjcwODcgMC4xMzUxNiwxLjk0NjcgMC4xODgxNiwyLjE1ODcgMC4zMjAxNiwyLjM0MzcgMC40NTMxNiwyLjU1NTcgMC42MTExNiwyLjcxMzcgMC44MjMxNiwyLjg0NjcgMC43OTIxNiwzLjE1NDcgMC42NTAxNiwzLjM4MjcgMC40NzkxNiwzLjU4NzcgMC40MjgxNiwzLjY2NzcgMC41MTcxNiwzLjc0MTcgMC42OTExNiwzLjcxOTcgMS4wODgyLDMuNjM5NyAxLjQwNDksMy40NTQ3IDEuNjQyOSwzLjE2MzcgMS44MDE5LDMuMTkwNyAxLjk2MDksMy4yMTY3IDIuMTE5OSwzLjIxNjcgMi40ODk5LDMuMjE2NyAyLjgwNzksMy4xMzc3IDMuMTI0OSwzLjAwNTcgMy40MTU5LDIuODcyNyAzLjY4MDksMi42ODc3IDMuODM4OSwyLjQ0OTcgNC4wMjQ5LDIuMjExNyA0LjEwMzksMS45NzM3IDQuMTAzOSwxLjY4MjcgNC4xMDM5LDEuNDE3NyA0LjAyNDksMS4xNTI3IDMuODM4OSwwLjk0MTY3IFoiCiAgICAgICBpZD0icGF0aDE1MjQiCiAgICAgICBzdHlsZT0iZmlsbDojZmZmNzAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjI2NDU4MztzdHJva2Utb3BhY2l0eToxIiAvPgogICAgPHBhdGgKICAgICAgIGQ9Ik0gMy4wNDI5LDEuNDE2NyBIIDEuMTkxMiBDIDEuMTExMiwxLjQxNjcgMS4wNTkyLDEuMzYzNyAxLjA1OTIsMS4yODM3IDEuMDU5MiwxLjIwNDcgMS4xMTEyLDEuMTUxNyAxLjE5MTIsMS4xNTE3IEggMy4wNDI5IEMgMy4xMjE5LDEuMTUxNyAzLjE3NDksMS4yMDQ3IDMuMTc0OSwxLjI4MzcgMy4xNzQ5LDEuMzYzNyAzLjEyMTksMS40MTY3IDMuMDQyOSwxLjQxNjcgWiIKICAgICAgIGlkPSJwYXRoMTUzNiIKICAgICAgIHN0eWxlPSJzdHJva2Utd2lkdGg6MC4yNjQ1ODMiIC8+CiAgICA8cGF0aAogICAgICAgZD0iTSAzLjA0MjksMS45NDU3IEggMS4xOTEyIEMgMS4xMTEyLDEuOTQ1NyAxLjA1OTIsMS44OTI3IDEuMDU5MiwxLjgxMjcgMS4wNTkyLDEuNzMzNyAxLjExMTIsMS42ODA3IDEuMTkxMiwxLjY4MDcgSCAzLjA0MjkgQyAzLjEyMTksMS42ODA3IDMuMTc0OSwxLjczMzcgMy4xNzQ5LDEuODEyNyAzLjE3NDksMS44OTI3IDMuMTIxOSwxLjk0NTcgMy4wNDI5LDEuOTQ1NyBaIgogICAgICAgaWQ9InBhdGgxNTQwIgogICAgICAgc3R5bGU9InN0cm9rZS13aWR0aDowLjI2NDU4MyIgLz4KICA8L2c+Cjwvc3ZnPgo=';\n        return imageSource;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.createRequestForComments = function () {\n        var jsonObject;\n        // eslint-disable-next-line\n        var proxy = this;\n        var startIndex = 0;\n        var pageLimit = 20;\n        var pageCount = proxy.pdfViewerBase.pageCount;\n        if (!proxy.isCommentsRendered) {\n            if (pageLimit < pageCount) {\n                pageCount = pageLimit;\n            }\n            else {\n                proxy.isPageCommentsRendered = true;\n            }\n        }\n        if (!this.isCommentsRendered) {\n            jsonObject = { pageStartIndex: startIndex.toString(), pageEndIndex: pageCount.toString(), hashId: this.pdfViewerBase.hashId, action: 'RenderAnnotationComments', elementId: this.pdfViewer.element.id, uniqueId: proxy.pdfViewerBase.documentId };\n            proxy.isCommentsRendered = true;\n        }\n        else {\n            jsonObject = { pageStartIndex: pageLimit.toString(), pageEndIndex: pageCount.toString(), hashId: this.pdfViewerBase.hashId, action: 'RenderAnnotationComments', elementId: this.pdfViewer.element.id, uniqueId: proxy.pdfViewerBase.documentId };\n        }\n        if (this.pdfViewerBase.jsonDocumentId) {\n            jsonObject.documentId = this.pdfViewerBase.jsonDocumentId;\n        }\n        var url = this.pdfViewer.serviceUrl + '/' + this.pdfViewer.serverActionSettings.renderComments;\n        proxy.commentsRequestHandler = new _index__WEBPACK_IMPORTED_MODULE_0__.AjaxHandler(proxy.pdfViewer);\n        proxy.commentsRequestHandler.url = url;\n        proxy.commentsRequestHandler.mode = true;\n        proxy.commentsRequestHandler.responseType = 'text';\n        if (this.pdfViewerBase.clientSideRendering) {\n            var data = this.pdfViewer.pdfRendererModule.getAnnotationComments(jsonObject);\n            this.renderCommentsOnSuccess(data, proxy);\n        }\n        else {\n            this.pdfViewerBase.requestCollection.push(this.commentsRequestHandler);\n            proxy.commentsRequestHandler.send(jsonObject);\n            proxy.commentsRequestHandler.onSuccess = function (result) {\n                var data = result.data;\n                var redirect = proxy.pdfViewerBase.checkRedirection(data);\n                if (!redirect) {\n                    if (data) {\n                        if (typeof data !== 'object') {\n                            try {\n                                data = JSON.parse(data);\n                                if (typeof data !== 'object') {\n                                    data = JSON.parse(data);\n                                }\n                                if (typeof data !== 'object') {\n                                    proxy.pdfViewerBase.onControlError(500, data, this.pdfViewer.serverActionSettings.renderComments);\n                                    data = null;\n                                }\n                            }\n                            catch (error) {\n                                proxy.pdfViewerBase.onControlError(500, data, this.pdfViewer.serverActionSettings.renderComments);\n                                data = null;\n                            }\n                        }\n                        proxy.renderCommentsOnSuccess(data, proxy);\n                    }\n                }\n            };\n            proxy.commentsRequestHandler.onFailure = function (result) {\n                this.pdfViewer.fireAjaxRequestFailed(result.status, result.statusText);\n            };\n            proxy.commentsRequestHandler.onError = function (result) {\n                proxy.pdfViewer.fireAjaxRequestFailed(result.status, result.statusText, proxy.pdfViewer.serverActionSettings.renderComments);\n            };\n        }\n    };\n    StickyNotesAnnotation.prototype.renderCommentsOnSuccess = function (data, proxy) {\n        if (data) {\n            var isInitialRender = false;\n            if (proxy.pdfViewerBase.annotationComments) {\n                proxy.pdfViewerBase.annotationComments = data.annotationDetails;\n            }\n            else {\n                proxy.pdfViewerBase.annotationComments = data.annotationDetails;\n                isInitialRender = true;\n            }\n            if (data.annotationDetails && data.uniqueId === proxy.pdfViewerBase.documentId) {\n                proxy.pdfViewer.fireAjaxRequestSuccess(this.pdfViewer.serverActionSettings.renderComments, data);\n                proxy.isAnnotationRendered = true;\n                var annotationCollections = void 0;\n                if (proxy.pdfViewerBase.documentAnnotationCollections) {\n                    annotationCollections = proxy.updateAnnotationsInDocumentCollections(proxy.pdfViewerBase.annotationComments, proxy.pdfViewerBase.documentAnnotationCollections);\n                }\n                else {\n                    var newCollection = proxy.pdfViewerBase.createAnnotationsCollection();\n                    annotationCollections = proxy.updateAnnotationsInDocumentCollections(proxy.pdfViewerBase.annotationComments, newCollection);\n                }\n                proxy.pdfViewerBase.annotationComments = annotationCollections;\n                proxy.pdfViewerBase.documentAnnotationCollections = annotationCollections;\n                for (var i = data.startPageIndex; i < data.endPageIndex; i++) {\n                    var newData = data.annotationDetails[parseInt(i.toString(), 10)];\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'annotationOrder');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'freeTextAnnotation');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'measureShapeAnnotation');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'shapeAnnotation');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'signatureAnnotation');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'signatureInkAnnotation');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'stampAnnotations');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'stickyNotesAnnotation');\n                    proxy.pdfViewerBase.updateModifiedDateToLocalDate(newData, 'textMarkupAnnotation');\n                }\n                for (var j = data.startPageIndex; j < data.endPageIndex; j++) {\n                    if (data.annotationDetails[parseInt(j.toString(), 10)]) {\n                        proxy.renderAnnotationCollections(data.annotationDetails[parseInt(j.toString(), 10)], j, isInitialRender);\n                    }\n                }\n                if (!proxy.isPageCommentsRendered) {\n                    proxy.isPageCommentsRendered = true;\n                    proxy.createRequestForComments();\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} excistingAnnotation - It describes about the existing annotation\n     * @param {any} newAnnotation - It describes about the new annotation\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.updateAnnotationsInDocumentCollections = function (excistingAnnotation, newAnnotation) {\n        for (var i = 0; i < this.pdfViewerBase.pageCount; i++) {\n            if (excistingAnnotation[parseInt(i.toString(), 10)] && newAnnotation[parseInt(i.toString(), 10)]) {\n                if (excistingAnnotation[parseInt(i.toString(), 10)].textMarkupAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].textMarkupAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].textMarkupAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].textMarkupAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            textMarkupAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].textMarkupAnnotation);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].shapeAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].shapeAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].shapeAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].shapeAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            shapeAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].shapeAnnotation);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].measureShapeAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].measureShapeAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].measureShapeAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].measureShapeAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            measureShapeAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].\n                            measureShapeAnnotation);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].stampAnnotations &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].stampAnnotations.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].stampAnnotations) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].stampAnnotations.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            stampAnnotations[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].stampAnnotations);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].stickyNotesAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].stickyNotesAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].stickyNotesAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].stickyNotesAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            stickyNotesAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].\n                            stickyNotesAnnotation);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].freeTextAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].freeTextAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].freeTextAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].freeTextAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            freeTextAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].\n                            freeTextAnnotation);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].signatureAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].signatureAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].signatureAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].signatureAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            signatureAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].\n                            signatureAnnotation);\n                    }\n                }\n                if (excistingAnnotation[parseInt(i.toString(), 10)].signatureInkAnnotation &&\n                    excistingAnnotation[parseInt(i.toString(), 10)].signatureInkAnnotation.length !== 0 &&\n                    newAnnotation[parseInt(i.toString(), 10)].signatureInkAnnotation) {\n                    for (var j = 0; j < excistingAnnotation[parseInt(i.toString(), 10)].signatureInkAnnotation.length; j++) {\n                        this.updateDocumentAnnotationCollections(excistingAnnotation[parseInt(i.toString(), 10)].\n                            signatureInkAnnotation[parseInt(j.toString(), 10)], newAnnotation[parseInt(i.toString(), 10)].signatureInkAnnotation);\n                    }\n                }\n            }\n        }\n        return newAnnotation;\n    };\n    StickyNotesAnnotation.prototype.updateDocumentAnnotationCollections = function (excistingAnnotation, newAnnotation) {\n        if (newAnnotation.length === 0) {\n            newAnnotation.push(excistingAnnotation);\n        }\n        else {\n            var isAdded = false;\n            for (var i = 0; i < newAnnotation.length; i++) {\n                if ((excistingAnnotation.AnnotName && newAnnotation[parseInt(i.toString(), 10)].AnnotName) &&\n                    (excistingAnnotation.AnnotName === newAnnotation[parseInt(i.toString(), 10)].AnnotName)) {\n                    isAdded = true;\n                    break;\n                }\n            }\n            if (!isAdded) {\n                newAnnotation.push(excistingAnnotation);\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.renderAnnotationCollections = function (pageAnnotations, pageNumber, isInitialRender) {\n        var pageCollections = [];\n        var collection = pageAnnotations.annotationOrder;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(collection)) {\n            for (var l = 0; l < collection.length; l++) {\n                var annotation = collection[parseInt(l.toString(), 10)];\n                var type = annotation.AnnotType ? annotation.AnnotType : annotation.AnnotationType;\n                if (this.pdfViewer.dateTimeFormat) {\n                    annotation.ModifiedDate =\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.getDateAndTime(annotation.ModifiedDate);\n                }\n                pageCollections.push(annotation);\n                switch (type) {\n                    case 'textMarkup':\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule) &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.textMarkupAnnotationModule))) {\n                            this.updateCollections(this.pdfViewer.annotationModule.textMarkupAnnotationModule.\n                                updateTextMarkupAnnotationCollections(annotation, pageNumber));\n                        }\n                        break;\n                    case 'shape_measure':\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule) &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.measureAnnotationModule))) {\n                            this.updateCollections(this.pdfViewer.annotationModule.measureAnnotationModule.\n                                updateMeasureAnnotationCollections(annotation, pageNumber));\n                        }\n                        break;\n                    case 'shape':\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule) &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.shapeAnnotationModule))) {\n                            this.updateCollections(this.pdfViewer.annotationModule.shapeAnnotationModule.\n                                updateShapeAnnotationCollections(annotation, pageNumber));\n                        }\n                        break;\n                    case 'sticky':\n                        this.updateCollections(this.updateStickyNotesAnnotationCollections(annotation, pageNumber));\n                        break;\n                    case 'stamp':\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule) &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.stampAnnotationModule))) {\n                            this.updateCollections(this.pdfViewer.annotationModule.stampAnnotationModule.\n                                updateStampAnnotationCollections(annotation, pageNumber));\n                        }\n                        break;\n                    case 'Ink':\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule) &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.inkAnnotationModule))) {\n                            this.updateCollections(this.pdfViewer.annotationModule.inkAnnotationModule.\n                                updateInkCollections(annotation, pageNumber));\n                        }\n                        break;\n                    case 'Text Box':\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule) &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.freeTextAnnotationModule))) {\n                            this.updateCollections(this.pdfViewer.annotationModule.freeTextAnnotationModule.\n                                updateFreeTextAnnotationCollections(annotation, pageNumber));\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        if (pageAnnotations.signatureAnnotation && pageAnnotations.signatureAnnotation.length !== 0) {\n            for (var i = 0; i < pageAnnotations.signatureAnnotation.length; i++) {\n                if (this.pdfViewer.dateTimeFormat) {\n                    pageAnnotations.signatureAnnotation[parseInt(i.toString(), 10)].ModifiedDate =\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                            getDateAndTime(pageAnnotations.signatureAnnotation[parseInt(i.toString(), 10)].ModifiedDate);\n                }\n                this.updateCollections(this.pdfViewerBase.signatureModule.\n                    updateSignatureCollections(pageAnnotations.signatureAnnotation[parseInt(i.toString(), 10)], pageNumber), true);\n            }\n        }\n        if (this.pdfViewer.toolbarModule) {\n            this.renderAnnotationComments(pageCollections, pageNumber);\n        }\n        if (isInitialRender) {\n            for (var i = 0; i < this.pdfViewerBase.renderedPagesList.length; i++) {\n                if (this.pdfViewerBase.renderedPagesList[parseInt(i.toString(), 10)] === pageNumber) {\n                    this.pdfViewerBase.renderAnnotations(pageNumber, pageAnnotations, false);\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {boolean} isSignature - It describes about the issignature\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateCollections = function (annotation, isSignature) {\n        var isAdded = false;\n        var collections;\n        if (isSignature) {\n            collections = this.pdfViewer.signatureCollection;\n        }\n        else {\n            collections = this.pdfViewer.annotationCollection;\n        }\n        if (collections && annotation) {\n            for (var i = 0; i < collections.length; i++) {\n                if (isSignature) {\n                    if (collections[parseInt(i.toString(), 10)].signatureName === annotation.signatureName) {\n                        isAdded = true;\n                        break;\n                    }\n                }\n                else {\n                    if (collections[parseInt(i.toString(), 10)].annotationId === annotation.annotationId) {\n                        isAdded = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (!isAdded && annotation) {\n            if (isSignature) {\n                this.pdfViewer.signatureCollection.push(annotation);\n            }\n            else {\n                this.pdfViewer.annotationCollection.push(annotation);\n            }\n        }\n    };\n    /**\n     * @param {any} data - It describes about the data\n     * @param {number} pageIndex - It describes about the page index\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.renderAnnotationComments = function (data, pageIndex) {\n        pageIndex = pageIndex + 1;\n        if (data) {\n            if (data.length !== 0) {\n                if (!(data.length === 1 && (data[0].AnnotationType === 'Signature' || data[0].AnnotationType === 'signature'))) {\n                    this.createPageAccordion(pageIndex);\n                }\n                for (var i = 0; i < data.length; i++) {\n                    if (data[parseInt(i.toString(), 10)].AnnotName && (data[parseInt(i.toString(), 10)].AnnotName.split('freeText').length === 1)) {\n                        this.createCommentControlPanel(data[parseInt(i.toString(), 10)], pageIndex);\n                    }\n                }\n                var newCommentsDiv = document.querySelectorAll('.e-pv-new-comments-div');\n                if (newCommentsDiv) {\n                    for (var j = 0; j < newCommentsDiv.length; j++) {\n                        newCommentsDiv[parseInt(j.toString(), 10)].style.display = 'none';\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.initializeAcccordionContainer = function () {\n        var commentPanelText = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commentsPanelText', className: 'e-pv-comments-panel-text' });\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n            var promise = this.pdfViewer._dotnetInstance.invokeMethodAsync('GetLocaleText', 'PdfViewer_NoCommentsYet');\n            promise.then(function (value) {\n                commentPanelText.textContent = value;\n            });\n        }\n        else {\n            commentPanelText.textContent = this.pdfViewer.localeObj.getConstant('No Comments Yet');\n        }\n        this.updateCommentPanelTextTop();\n        this.pdfViewerBase.navigationPane.commentsContentContainer.appendChild(commentPanelText);\n        this.accordionContentContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_accordionContentContainer', className: 'e-pv-accordion-content-container' });\n        this.pdfViewerBase.navigationPane.commentsContentContainer.appendChild(this.accordionContentContainer);\n        this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export Annotations')], false);\n        this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export XFDF')], false);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateCommentPanelTextTop = function () {\n        var commentPanelText = document.getElementById(this.pdfViewer.element.id + '_commentsPanelText');\n        if (this.pdfViewerBase.navigationPane.commentPanelContainer && this.pdfViewerBase.navigationPane.commentPanelContainer.clientHeight && commentPanelText.style.display !== 'none') {\n            commentPanelText.style.paddingTop = (this.pdfViewerBase.navigationPane.commentPanelContainer.clientHeight / 2) - 47 + 'px';\n            commentPanelText.style.paddingLeft = (this.pdfViewerBase.navigationPane.commentPanelContainer.clientWidth) / 3 + 'px';\n        }\n    };\n    /**\n     * @param {number} pageIndex - It describes about the page index\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.createPageAccordion = function (pageIndex) {\n        var pageAccordionContainer = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageIndex);\n        if (pageAccordionContainer === null) {\n            this.accordionContent = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_accordioncontent' + pageIndex });\n            this.accordionContent.style.zIndex = '1000';\n            this.accordionPageContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_accordionPageContainer' + pageIndex, className: 'e-pv-accordion-page-container' });\n            this.accordionPageContainer.appendChild(this.accordionContent);\n            this.pdfViewerBase.viewerMainContainer.appendChild(this.accordionPageContainer);\n            this.accordionContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_accordionContainer' + pageIndex, className: 'e-pv-accordion-container' });\n            var pageAccordion = new _syncfusion_ej2_navigations__WEBPACK_IMPORTED_MODULE_2__.Accordion({\n                items: [\n                    { header: this.pdfViewer.localeObj.getConstant('Page') + ' ' + (pageIndex), expanded: true, content: '#' + this.pdfViewer.element.id + '_accordioncontent' + pageIndex + '' }\n                ]\n            });\n            pageAccordion.appendTo(this.accordionContainer);\n            this.accordionContainer.style.order = 'pageIndex';\n            this.alignAccordionContainer(this.accordionContainer, pageIndex);\n            if (document.getElementById(this.pdfViewer.element.id + '_commentsPanelText')) {\n                this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export Annotations')], true);\n                this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export XFDF')], true);\n                document.getElementById(this.pdfViewer.element.id + '_commentsPanelText').style.display = 'none';\n            }\n            if (document.getElementById(this.pdfViewer.element.id + '_accordionContentContainer')) {\n                document.getElementById(this.pdfViewer.element.id + '_accordionContentContainer').style.display = 'block';\n            }\n            return this.accordionContainer;\n        }\n    };\n    StickyNotesAnnotation.prototype.alignAccordionContainer = function (accordionDiv, pageIndex) {\n        var isAdded = true;\n        if (this.accordionContentContainer) {\n            if (this.isAccordionContainer) {\n                this.accordionContentContainer.appendChild(accordionDiv);\n                isAdded = false;\n            }\n            else {\n                for (var i = 1; i <= this.pdfViewerBase.pageCount; i++) {\n                    var nextElement = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + i);\n                    if (nextElement) {\n                        if (pageIndex < i) {\n                            this.accordionContentContainer.insertBefore(accordionDiv, nextElement);\n                            isAdded = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (isAdded) {\n                this.accordionContentContainer.appendChild(accordionDiv);\n                isAdded = false;\n            }\n            this.isAccordionContainer = false;\n        }\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateCommentPanelScrollTop = function (pageNumber) {\n        var accordionDiv = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageNumber);\n        if (accordionDiv) {\n            var scrollValue = accordionDiv.offsetTop + accordionDiv.clientTop - 35;\n            this.pdfViewerBase.navigationPane.commentsContentContainer.scrollTop = scrollValue;\n        }\n    };\n    StickyNotesAnnotation.prototype.getButtonState = function (editObj, commentTextBox) {\n        commentTextBox.addEventListener('keyup', function (event) {\n            if (editObj.element.querySelector('.e-btn-save')) {\n                if ((event.srcElement.value !== '' || event.srcElement.defaultValue !== '') && event.srcElement.defaultValue !== event.srcElement.value) {\n                    editObj.element.querySelector('.e-btn-save').ej2_instances[0].disabled = false;\n                }\n            }\n        });\n    };\n    /**\n     * @param {any} data - It describes about the data\n     * @param {number} pageIndex - It describes about the page index\n     * @param {string} type - It describes about the type\n     * @param {string} annotationSubType - It describes about the annotation sub type\n     * @param {boolean} isReRender - It describes about the isRenderer\n     * @private\n     * @returns {string} - string\n     */\n    StickyNotesAnnotation.prototype.createCommentControlPanel = function (data, pageIndex, type, annotationSubType, isReRender) {\n        var accordionContent = document.getElementById(this.pdfViewer.element.id + '_accordioncontent' + pageIndex);\n        if (accordionContent) {\n            var accordionExpand = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageIndex);\n            if (accordionExpand) {\n                accordionExpand.ej2_instances[0].expandItem(true);\n            }\n            this.commentsContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'commentscontainer_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comments-container' });\n            this.commentsContainer.accessKey = pageIndex.toString() + '_' + this.commentsCount;\n            var isCommentsAdded = false;\n            if (data) {\n                this.commentsContainer.id = data.AnnotName;\n                if (data.AnnotName) {\n                    for (var j = 0; j < accordionContent.childElementCount; j++) {\n                        if (accordionContent.children[parseInt(j.toString(), 10)].id === data.AnnotName) {\n                            isCommentsAdded = true;\n                            if (isReRender) {\n                                // To remove the existing div element in the comment panel while importing the annotation with the same name. (EJ2-62092)\n                                var id = document.getElementById(accordionContent.children[parseInt(j.toString(), 10)].id);\n                                id.remove();\n                                isCommentsAdded = false;\n                            }\n                            break;\n                        }\n                    }\n                }\n                if (data.Name && data.Name === 'freeText') {\n                    this.commentsContainer.setAttribute('name', 'freeText');\n                }\n                else {\n                    this.commentsContainer.setAttribute('name', data.AnnotType);\n                }\n            }\n            if (type) {\n                this.commentsContainer.setAttribute('name', type);\n            }\n            this.commentsContainer.addEventListener('mousedown', this.commentsAnnotationSelect.bind(this));\n            var commentDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commentdiv_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comments-div' });\n            this.commentsCount = this.commentsCount + 1;\n            this.commentsContainer.appendChild(commentDiv);\n            this.updateCommentPanelScrollTop(pageIndex);\n            if (!isCommentsAdded) {\n                accordionContent.appendChild(this.commentsContainer);\n            }\n            var title = void 0;\n            if (data) {\n                title = this.commentsContainer.getAttribute('name');\n                if (title === 'null') {\n                    title = data.AnnotationType;\n                }\n                this.createTitleContainer(commentDiv, title, pageIndex, data.Subject, data.ModifiedDate, data.Author);\n            }\n            else {\n                title = this.commentsContainer.getAttribute('name');\n                this.createTitleContainer(commentDiv, title, pageIndex, annotationSubType);\n            }\n            var commentTextBox = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commenttextbox_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comment-textbox', attrs: { 'role': 'textbox', 'aria-label': 'comment textbox' } });\n            var enableAutoComplete = this.pdfViewer.enableAutoComplete ? 'on' : 'off';\n            var editObj_1 = new _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_3__.InPlaceEditor({\n                mode: 'Inline',\n                type: 'Text',\n                model: { placeholder: this.pdfViewer.localeObj.getConstant('Add a comment') + '..', htmlAttributes: { autocomplete: enableAutoComplete } },\n                emptyText: '',\n                editableOn: 'EditIconClick',\n                saveButton: {\n                    content: this.pdfViewer.localeObj.getConstant('Post'),\n                    cssClass: 'e-outline',\n                    disabled: true\n                },\n                cancelButton: {\n                    content: this.pdfViewer.localeObj.getConstant('Cancel'),\n                    cssClass: 'e-outline'\n                },\n                submitOnEnter: true\n            });\n            if (data && (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data.Note) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data.Text))) {\n                editObj_1.created = function () {\n                    setTimeout(function () {\n                        editObj_1.element.querySelector('.e-editable-value').innerText = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data.Note) ? data.Note : !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data.Text) ? data.Text : '';\n                    });\n                };\n                editObj_1.beginEdit = function () {\n                    editObj_1.value = editObj_1.valueEle.innerText;\n                };\n            }\n            editObj_1.appendTo(commentTextBox);\n            var textBox = document.querySelectorAll('.e-editable-inline');\n            for (var j = 0; j < textBox.length; j++) {\n                textBox[parseInt(j.toString(), 10)].style.display = 'none';\n            }\n            if (!data && type !== 'freeText') {\n                editObj_1.enableEditMode = true;\n            }\n            this.getButtonState(editObj_1, commentTextBox);\n            editObj_1.actionSuccess = this.createCommentDiv.bind(this, editObj_1);\n            commentDiv.appendChild(commentTextBox);\n            if (data) {\n                editObj_1.value = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data.Note) ? data.Note : !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data.Text) ? data.Text : '';\n                var isCommentLocked = this.checkIslockProperty(data);\n                if (isCommentLocked && data.Comments == null) {\n                    this.createCommentDiv(this.commentsContainer);\n                }\n                if (data.Name === 'freeText') {\n                    editObj_1.value = data.MarkupText;\n                }\n                if (data.State) {\n                    var statusContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                    var statusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                    var statusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon' });\n                    statusDiv.appendChild(statusSpan);\n                    statusContainer.appendChild(statusDiv);\n                    commentDiv.appendChild(statusContainer);\n                    this.updateStatusContainer(data.State, statusSpan, statusDiv, statusContainer);\n                }\n                if (data.Comments) {\n                    for (var j = 0; j < data.Comments.length; j++) {\n                        this.renderComments(data.Comments[parseInt(j.toString(), 10)], this.commentsContainer);\n                    }\n                    if (data.Note !== ' ' && data.Note !== '' && data.Note !== null) {\n                        this.createCommentDiv(this.commentsContainer);\n                    }\n                    if (data.AnnotType === 'Text Box' && data.Text !== ' ' && data.Text !== '' && data.Text !== null) {\n                        this.createCommentDiv(this.commentsContainer);\n                    }\n                }\n                //Task Id: 874405. If a comment is added programmatically, create a reply div container.\n                if (data.Note !== ' ' && data.Note !== '' && data.Note !== null) {\n                    this.createCommentDiv(this.commentsContainer);\n                }\n                if (data.AnnotType === 'Text Box' && data.Text !== ' ' && data.Text !== '' && data.Text !== null) {\n                    this.createCommentDiv(this.commentsContainer);\n                }\n            }\n            this.isNewcommentAdded = true;\n            commentDiv.addEventListener('click', this.commentsDivClickEvent.bind(this));\n            commentDiv.addEventListener('mouseover', this.commentDivMouseOver.bind(this));\n            commentDiv.addEventListener('mouseleave', this.commentDivMouseLeave.bind(this));\n            commentDiv.addEventListener('mouseout', this.commentDivMouseLeave.bind(this));\n            commentDiv.addEventListener('focusout', this.commentDivMouseLeave.bind(this));\n            commentTextBox.addEventListener('dblclick', this.openEditorElement.bind(this));\n            commentTextBox.addEventListener('focusin', this.commentDivFocus.bind(this));\n            return (this.commentsContainer.id);\n        }\n        return '';\n    };\n    StickyNotesAnnotation.prototype.commentDivFocus = function (args) {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.freeTextSettings.defaultText)) {\n            this.pdfViewer.freeTextSettings.defaultText = 'Type here';\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(args.target) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.freeTextSettings.defaultText) && this.pdfViewer.selectedItems && this.pdfViewer.selectedItems.annotations[0] && this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'FreeText' && args.target.value === this.pdfViewer.freeTextSettings.defaultText) {\n            args.target.select();\n        }\n        if (!this.isNewcommentAdded) {\n            if (args.relatedTarget !== null && args.relatedTarget.id === this.pdfViewer.element.id + '_viewerContainer') {\n                args.preventDefault();\n                args.target.blur();\n            }\n        }\n        else {\n            // eslint-disable-next-line\n            var proxy_1 = this;\n            var pageNumber_1 = this.pdfViewerBase.currentPageNumber;\n            setTimeout(function () {\n                proxy_1.updateScrollPosition(pageNumber_1);\n            }, 500);\n        }\n    };\n    StickyNotesAnnotation.prototype.updateScrollPosition = function (pageNumber) {\n        var accordionDiv = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageNumber);\n        if (accordionDiv && this.isNewcommentAdded) {\n            var commentHeight = 0;\n            var textBox = document.querySelectorAll('.e-editable-inline');\n            if (textBox[0]) {\n                commentHeight = textBox[0].getBoundingClientRect().height;\n            }\n            var scrollValue = accordionDiv.offsetTop + accordionDiv.clientTop + commentHeight;\n            if (this.pdfViewerBase.navigationPane.commentsContentContainer.scrollTop < scrollValue) {\n                this.pdfViewerBase.navigationPane.commentsContentContainer.scrollTop = scrollValue;\n            }\n            this.isNewcommentAdded = false;\n        }\n    };\n    StickyNotesAnnotation.prototype.updateCommentsScrollTop = function (isCommentsAdded) {\n        var accordionDiv = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + this.pdfViewerBase.currentPageNumber);\n        var commentsContainer = document.querySelector('.e-pv-comments-border');\n        var commentsHeight = 0;\n        if (accordionDiv && commentsContainer) {\n            commentsHeight = commentsContainer.getBoundingClientRect().height;\n            var scrollValue = void 0;\n            if (isCommentsAdded) {\n                scrollValue = accordionDiv.offsetTop + commentsContainer.offsetTop + (commentsHeight / 4);\n            }\n            else {\n                scrollValue = accordionDiv.offsetTop + commentsContainer.offsetTop - 70;\n            }\n            this.pdfViewerBase.navigationPane.commentsContentContainer.scrollTop = scrollValue;\n        }\n    };\n    /**\n     * @param {any} args - It describes about the args\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.createCommentDiv = function (args) {\n        var _this = this;\n        var commentsContainer;\n        var titleContainer;\n        var newCommentDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_newcommentdiv_' + this.commentsCount + '_' + this.commentsreplyCount, className: 'e-pv-new-comments-div' });\n        if (args.localName) {\n            commentsContainer = args;\n        }\n        else {\n            commentsContainer = args.valueEle.parentElement.parentElement.parentElement.parentElement;\n            titleContainer = args.valueEle.parentElement.parentElement.previousSibling.childNodes[1];\n        }\n        var enableAutoComplete = this.pdfViewer.enableAutoComplete ? 'on' : 'off';\n        var commentObj = new _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_3__.InPlaceEditor({\n            mode: 'Inline',\n            type: 'Text',\n            value: '',\n            editableOn: 'Click',\n            model: { placeholder: this.pdfViewer.localeObj.getConstant('Add a reply') + '..', htmlAttributes: { autocomplete: enableAutoComplete } },\n            emptyText: this.pdfViewer.localeObj.getConstant('Add a reply'),\n            saveButton: {\n                content: this.pdfViewer.localeObj.getConstant('Post'),\n                cssClass: 'e-outline',\n                disabled: true\n            },\n            cancelButton: {\n                content: this.pdfViewer.localeObj.getConstant('Cancel'),\n                cssClass: 'e-outline'\n            },\n            submitOnEnter: true\n        });\n        commentObj.appendTo(newCommentDiv);\n        newCommentDiv.lastChild.firstChild.click();\n        this.getButtonState(commentObj, newCommentDiv);\n        if (args.valueEle) {\n            if (this.pdfViewer.enableHtmlSanitizer && args.value) {\n                args.value = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(args.value);\n            }\n            if ((args.value !== null && args.value !== '' && args.value !== ' ') || (args.value === '' && args.prevValue !== '')) {\n                if (this.pdfViewer.selectedItems.annotations[0] && this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'FreeText') {\n                    this.modifyTextProperty(args.value, args.prevValue, args.valueEle.parentNode.parentNode.parentNode.parentNode.id);\n                }\n                else {\n                    try {\n                        this.modifyTextProperty(args.value, args.prevValue, args.valueEle.parentNode.parentNode.parentNode.parentNode.id);\n                    }\n                    catch (error) {\n                        this.modifyTextProperty(args.value, args.prevValue);\n                    }\n                }\n                // eslint-disable-next-line\n                if (args.prevValue != args.value) {\n                    this.updateModifiedDate(titleContainer);\n                }\n            }\n            if (args.valueEle.parentElement.parentElement.parentElement.parentElement.childElementCount === 1) {\n                if (args.value != null && args.value !== '') {\n                    commentsContainer.appendChild(newCommentDiv);\n                    setTimeout(function () {\n                        _this.updateCommentsScrollTop(true);\n                    }, 50);\n                }\n            }\n        }\n        else {\n            commentsContainer.appendChild(newCommentDiv);\n            setTimeout(function () {\n                _this.updateCommentsScrollTop(true);\n            }, 50);\n        }\n        commentObj.actionSuccess = this.saveCommentDiv.bind(this, commentObj);\n    };\n    /**\n     * @param {any} args - It describes about the args\n     * @param {any} comment - It describes about the comment\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.saveCommentDiv = function (args, comment) {\n        var commentsContainer;\n        var annotationAuthor;\n        var lastElement;\n        var commentValue;\n        if (this.pdfViewer.enableHtmlSanitizer && args.value) {\n            args.value = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(args.value);\n        }\n        if (comment.name && args.value !== '') {\n            commentsContainer = args.valueEle.parentElement.parentElement.parentElement;\n            lastElement = args.valueEle.parentElement.parentElement;\n            commentValue = args.value;\n        }\n        else {\n            commentsContainer = args;\n            lastElement = commentsContainer.lastChild;\n            commentValue = comment;\n        }\n        if (commentsContainer && lastElement) {\n            commentsContainer.removeChild(lastElement);\n            var replyTextBox = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_replytextbox_' + this.commentsCount + '_' + this.commentsreplyCount });\n            this.commentsreplyCount = this.commentsreplyCount + 1;\n            var replyCommentDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'replyDiv_' + this.commentsCount + '_' + this.commentsreplyCount, className: 'e-pv-reply-div' });\n            replyCommentDiv.id = this.pdfViewer.annotation.createGUID();\n            annotationAuthor = this.getAuthorName(this.pdfViewer.selectedItems.annotations[0], commentsContainer);\n            this.createReplyDivTitleContainer(replyCommentDiv, null, annotationAuthor);\n            replyCommentDiv.addEventListener('mouseover', this.commentDivMouseOver.bind(this));\n            replyCommentDiv.addEventListener('mouseleave', this.commentDivMouseLeave.bind(this));\n            replyCommentDiv.addEventListener('click', this.commentDivOnSelect.bind(this));\n            replyTextBox.addEventListener('dblclick', this.openEditorElement.bind(this));\n            replyCommentDiv.style.border = 1 + 'px';\n            replyCommentDiv.style.borderColor = 'black';\n            replyCommentDiv.style.zIndex = 1002;\n            var enableAutoComplete = this.pdfViewer.enableAutoComplete ? 'on' : 'off';\n            var saveObj_1 = new _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_3__.InPlaceEditor({\n                mode: 'Inline',\n                type: 'Text',\n                emptyText: '',\n                editableOn: 'EditIconClick',\n                model: { placeholder: this.pdfViewer.localeObj.getConstant('Add a reply') + '..', htmlAttributes: { autocomplete: enableAutoComplete } },\n                value: commentValue,\n                saveButton: {\n                    content: this.pdfViewer.localeObj.getConstant('Post'),\n                    cssClass: 'e-outline',\n                    disabled: true\n                },\n                cancelButton: {\n                    content: this.pdfViewer.localeObj.getConstant('Cancel'),\n                    cssClass: 'e-outline'\n                }\n            });\n            saveObj_1.created = function () {\n                setTimeout(function () {\n                    saveObj_1.element.querySelector('.e-editable-value').innerText = commentValue;\n                });\n            };\n            saveObj_1.beginEdit = function () {\n                saveObj_1.value = saveObj_1.valueEle.innerText;\n            };\n            saveObj_1.appendTo(replyTextBox);\n            saveObj_1.actionSuccess = this.modifyProperty.bind(this, saveObj_1);\n            replyCommentDiv.appendChild(replyTextBox);\n            replyCommentDiv.style.paddingLeft = 24 + 'px';\n            commentsContainer.appendChild(replyCommentDiv);\n            this.getButtonState(saveObj_1, replyTextBox);\n            replyCommentDiv.addEventListener('click', this.commentsDivClickEvent.bind(this));\n            replyCommentDiv.addEventListener('dblclick', this.commentsDivDoubleClickEvent.bind(this));\n            this.createCommentDiv(replyCommentDiv.parentElement);\n            this.modifyCommentsProperty(commentValue, replyCommentDiv.id, commentsContainer.id);\n        }\n    };\n    StickyNotesAnnotation.prototype.renderComments = function (data, commentDiv, undoRedoAction, id, isCommentAction) {\n        var annotationAuthor;\n        var replyTextBox = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_replytextbox_' + this.commentsCount + '_' + this.commentsreplyCount });\n        this.commentsreplyCount = this.commentsreplyCount + 1;\n        var replyDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: 'replyDiv_' + this.commentsCount + '_' + this.commentsreplyCount, className: 'e-pv-reply-div' });\n        if (undoRedoAction) {\n            replyDiv.id = data.annotName;\n            annotationAuthor = data.author;\n        }\n        else {\n            replyDiv.id = data.AnnotName;\n            annotationAuthor = data.Author;\n        }\n        replyDiv.style.border = 1 + 'px';\n        replyDiv.style.borderColor = 'black';\n        if (!annotationAuthor) {\n            annotationAuthor = commentDiv.getAttribute('author');\n        }\n        if (undoRedoAction) {\n            if (data.modifiedDate !== undefined) {\n                this.createReplyDivTitleContainer(replyDiv, data.modifiedDate, annotationAuthor);\n            }\n            else {\n                this.createReplyDivTitleContainer(replyDiv, null, annotationAuthor);\n            }\n        }\n        else {\n            this.createReplyDivTitleContainer(replyDiv, data.ModifiedDate, annotationAuthor);\n        }\n        replyDiv.addEventListener('mouseover', this.commentDivMouseOver.bind(this));\n        replyDiv.addEventListener('mouseleave', this.commentDivMouseLeave.bind(this));\n        replyDiv.addEventListener('click', this.commentDivOnSelect.bind(this));\n        replyTextBox.addEventListener('dblclick', this.openEditorElement.bind(this));\n        var enableAutoComplete = this.pdfViewer.enableAutoComplete ? 'on' : 'off';\n        var saveObj = new _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_3__.InPlaceEditor({\n            mode: 'Inline',\n            type: 'Text',\n            emptyText: '',\n            editableOn: 'EditIconClick',\n            model: { placeholder: this.pdfViewer.localeObj.getConstant('Add a reply') + '..', htmlAttributes: { autocomplete: enableAutoComplete } },\n            value: '',\n            saveButton: {\n                content: this.pdfViewer.localeObj.getConstant('Post'),\n                cssClass: 'e-outline',\n                disabled: true\n            },\n            cancelButton: {\n                content: this.pdfViewer.localeObj.getConstant('Cancel'),\n                cssClass: 'e-outline'\n            }\n        });\n        if (undoRedoAction) {\n            saveObj.value = data.note;\n        }\n        else {\n            saveObj.value = data.Note;\n        }\n        saveObj.created = function () {\n            setTimeout(function () {\n                saveObj.element.querySelector('.e-editable-value').innerText = undoRedoAction ? data ? data.note : '' : data ? data.Note : '';\n            });\n        };\n        saveObj.beginEdit = function () {\n            saveObj.value = saveObj.valueEle.innerText;\n        };\n        saveObj.appendTo(replyTextBox);\n        replyDiv.appendChild(replyTextBox);\n        if (undoRedoAction) {\n            data.State = data.state;\n        }\n        if (data.State) {\n            var statusContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n            var statusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n            var statusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon' });\n            statusDiv.appendChild(statusSpan);\n            statusContainer.appendChild(statusDiv);\n            replyDiv.appendChild(statusContainer);\n            this.updateStatusContainer(data.State, statusSpan, statusDiv, statusContainer);\n        }\n        replyDiv.style.paddingLeft = 24 + 'px';\n        this.getButtonState(saveObj, replyTextBox);\n        if (undoRedoAction) {\n            if (isCommentAction) {\n                commentDiv.appendChild(replyDiv);\n            }\n            else {\n                var commentsDiv = document.getElementById(id);\n                if (data.position) {\n                    commentsDiv.insertBefore(replyDiv, commentsDiv.childNodes[data.position]);\n                }\n                else {\n                    if (commentsDiv) {\n                        if (commentsDiv.childElementCount > 1) {\n                            commentsDiv.insertBefore(replyDiv, commentsDiv.childNodes[commentsDiv.childElementCount - 1]);\n                        }\n                        else {\n                            commentDiv.appendChild(replyDiv);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            commentDiv.appendChild(replyDiv);\n        }\n        replyDiv.addEventListener('click', this.commentsDivClickEvent.bind(this));\n        replyDiv.addEventListener('dblclick', this.commentsDivDoubleClickEvent.bind(this));\n        saveObj.actionSuccess = this.modifyProperty.bind(this, saveObj);\n    };\n    /**\n     * @param {any} data - It describes about the data\n     * @param {number} pageIndex - It describes about the page index\n     * @param {boolean} isCopy - It describes about the isCopy\n     * @private\n     * @returns {string} - string\n     */\n    StickyNotesAnnotation.prototype.createCommentsContainer = function (data, pageIndex, isCopy) {\n        var accordionContentContainer = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageIndex);\n        if (!accordionContentContainer) {\n            var accordionPageContainer = document.getElementById(this.pdfViewer.element.id + '_accordionPageContainer' + pageIndex);\n            if (accordionPageContainer) {\n                accordionPageContainer.parentElement.removeChild(accordionPageContainer);\n            }\n            accordionContentContainer = this.createPageAccordion(pageIndex);\n            if (accordionContentContainer) {\n                accordionContentContainer.ej2_instances[0].expandItem(true);\n            }\n        }\n        var accordionContent = document.getElementById(this.pdfViewer.element.id + '_accordioncontent' + pageIndex);\n        this.commentsContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'commentscontainer_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comments-container' });\n        this.commentsContainer.accessKey = pageIndex.toString() + '_' + this.commentsCount;\n        if (data) {\n            this.commentsContainer.id = data.annotName ? data.annotName : data.annotationId;\n        }\n        this.commentsContainer.addEventListener('mousedown', this.commentsAnnotationSelect.bind(this));\n        var commentDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commentdiv_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comments-div' });\n        this.commentsCount = this.commentsCount + 1;\n        this.commentsContainer.appendChild(commentDiv);\n        this.updateCommentPanelScrollTop(pageIndex);\n        if (data && accordionContent) {\n            if (data.position || data.position === 0) {\n                accordionContent.insertBefore(this.commentsContainer, accordionContent.children[data.position]);\n            }\n            else {\n                accordionContent.appendChild(this.commentsContainer);\n            }\n        }\n        if (data && accordionContent) {\n            if (data.indent) {\n                this.commentsContainer.setAttribute('name', 'shape_measure');\n                this.createTitleContainer(commentDiv, 'shape_measure', pageIndex, data.subject, data.modifiedDate, data.author);\n            }\n            else if (data.shapeAnnotationType === 'sticky' || data.shapeAnnotationType === 'stamp') {\n                var annotType = this.createTitleContainer(commentDiv, data.shapeAnnotationType, pageIndex, null, data.modifiedDate, data.author);\n                this.commentsContainer.setAttribute('name', annotType);\n                if (annotType === 'sticky') {\n                    if (!isCopy) {\n                        this.addStickyNotesAnnotations((pageIndex - 1), data);\n                    }\n                }\n            }\n            else if (data.shapeAnnotationType === 'textMarkup') {\n                this.commentsContainer.setAttribute('name', 'textMarkup');\n                this.createTitleContainer(commentDiv, 'textMarkup', pageIndex, data.subject, data.modifiedDate, data.author);\n            }\n            else if (data.shapeAnnotationType === 'FreeText') {\n                data.note = data.dynamicText;\n                this.commentsContainer.setAttribute('name', 'freetext');\n                this.createTitleContainer(commentDiv, 'freeText', pageIndex, data.subject, data.modifiedDate);\n            }\n            else if (data.shapeAnnotationType === 'Ink') {\n                data.note = data.dynamicText;\n                this.commentsContainer.setAttribute('name', 'ink');\n                this.createTitleContainer(commentDiv, 'ink', pageIndex, data.subject, data.modifiedDate);\n            }\n            else {\n                this.commentsContainer.setAttribute('name', 'shape');\n                if (data.shapeAnnotationType === 'Line') {\n                    this.createTitleContainer(commentDiv, 'shape', pageIndex, data.subject, data.modifiedDate, data.author);\n                }\n                else {\n                    this.createTitleContainer(commentDiv, 'shape', pageIndex, data.shapeAnnotationType, data.modifiedDate, data.author);\n                }\n            }\n        }\n        var commentTextBox = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commenttextbox_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comment-textbox', attrs: { 'role': 'textbox', 'aria-label': 'comment textbox' } });\n        var enableAutoComplete = this.pdfViewer.enableAutoComplete ? 'on' : 'off';\n        var editObj = new _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_3__.InPlaceEditor({\n            mode: 'Inline',\n            type: 'Text',\n            model: { placeholder: this.pdfViewer.localeObj.getConstant('Add a comment') + '..', htmlAttributes: { autocomplete: enableAutoComplete } },\n            emptyText: '',\n            editableOn: 'EditIconClick',\n            saveButton: {\n                content: this.pdfViewer.localeObj.getConstant('Post'),\n                cssClass: 'e-outline',\n                disabled: true\n            },\n            cancelButton: {\n                content: this.pdfViewer.localeObj.getConstant('Cancel'),\n                cssClass: 'e-outline'\n            },\n            submitOnEnter: true\n        });\n        editObj.appendTo(commentTextBox);\n        var textBox = document.querySelectorAll('.e-editable-inline');\n        for (var j = 0; j < textBox.length; j++) {\n            textBox[parseInt(j.toString(), 10)].style.display = 'none';\n        }\n        commentTextBox.addEventListener('keydown', function (event) {\n            if (editObj.element.querySelector('.e-btn-save')) {\n                if (event.srcElement.value !== '') {\n                    editObj.element.querySelector('.e-btn-save').ej2_instances[0].disabled = false;\n                }\n                else {\n                    editObj.element.querySelector('.e-btn-save').ej2_instances[0].disabled = true;\n                }\n            }\n        });\n        editObj.actionSuccess = this.createCommentDiv.bind(this, editObj);\n        commentDiv.appendChild(commentTextBox);\n        if (data) {\n            editObj.value = data.note;\n            if (data.state) {\n                var statusContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                var statusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                var statusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon' });\n                statusDiv.appendChild(statusSpan);\n                statusContainer.appendChild(statusDiv);\n                commentDiv.appendChild(statusContainer);\n                this.updateStatusContainer(data.state, statusSpan, statusDiv, statusContainer);\n            }\n            if (data.comments) {\n                for (var j = 0; j < data.comments.length; j++) {\n                    this.renderComments(data.comments[parseInt(j.toString(), 10)], this.commentsContainer, true, null, true);\n                }\n                if (data.comments.length > 0) {\n                    this.createCommentDiv(this.commentsContainer);\n                }\n            }\n        }\n        commentDiv.addEventListener('click', this.commentsDivClickEvent.bind(this));\n        commentDiv.addEventListener('mouseover', this.commentDivMouseOver.bind(this));\n        commentDiv.addEventListener('mouseleave', this.commentDivMouseLeave.bind(this));\n        commentDiv.addEventListener('mouseout', this.commentDivMouseLeave.bind(this));\n        commentDiv.addEventListener('focusout', this.commentDivMouseLeave.bind(this));\n        commentTextBox.addEventListener('dblclick', this.openEditorElement.bind(this));\n        return (this.commentsContainer.id);\n    };\n    StickyNotesAnnotation.prototype.modifyProperty = function (args) {\n        var commentElement = args.element.parentElement.id;\n        var parentElement = args.element.parentElement.parentElement.id;\n        var titleElement = args.element.previousSibling.firstChild;\n        this.updateModifiedDate(titleElement);\n        this.modifyCommentsProperty(args.value, commentElement, parentElement, args.prevValue);\n    };\n    StickyNotesAnnotation.prototype.createTitleContainer = function (commentsDivElement, type, pageIndex, subType, modifiedDate, author, note) {\n        var annotationType = this.getAnnotationType(type);\n        var commentTitleContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commentTitleConatiner_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comment-title-container' });\n        var commentTypeSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + '_commenttype' + '_icon' + pageIndex + '_' + this.commentsCount });\n        commentTypeSpan.style.opacity = '0.6';\n        this.updateCommentIcon(commentTypeSpan, annotationType, subType);\n        var annotationAuthor;\n        if (!author) {\n            annotationAuthor = this.pdfViewer.annotationModule.updateAnnotationAuthor(annotationType, subType);\n        }\n        else {\n            annotationAuthor = author;\n        }\n        annotationAuthor = annotationAuthor.replace(/(\\r\\n|\\n|\\r)/gm, '');\n        commentTypeSpan.style.padding = 8 + 'px';\n        commentTypeSpan.style.cssFloat = 'left';\n        commentTitleContainer.appendChild(commentTypeSpan);\n        var commentsTitle = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_commentTitle_' + pageIndex + '_' + this.commentsCount, className: 'e-pv-comment-title' });\n        if (!modifiedDate) {\n            commentsTitle.textContent = annotationAuthor + ' - ' + this.setModifiedDate();\n        }\n        else {\n            commentsTitle.textContent = annotationAuthor + ' - ' + this.convertUTCDateToLocalDate(modifiedDate);\n        }\n        commentTitleContainer.appendChild(commentsTitle);\n        this.moreButtonId = this.pdfViewer.element.id + '_more-options_' + this.commentsCount + '_' + this.commentsreplyCount;\n        var moreOptionsButton = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('button', { id: this.moreButtonId, className: 'e-pv-more-options-button e-btn', attrs: { 'tabindex': '-1' } });\n        moreOptionsButton.style.visibility = 'hidden';\n        moreOptionsButton.style.zIndex = '1001';\n        moreOptionsButton.setAttribute('type', 'button');\n        moreOptionsButton.setAttribute('aria-label', 'more button');\n        var moreOptionsButtonSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + '_more-options_icon', className: 'e-pv-more-icon e-pv-icon' });\n        moreOptionsButton.appendChild(moreOptionsButtonSpan);\n        moreOptionsButtonSpan.style.opacity = '0.87';\n        commentTitleContainer.appendChild(moreOptionsButton);\n        commentsDivElement.appendChild(commentTitleContainer);\n        var commentsContainer = commentsDivElement.parentElement;\n        if (commentsContainer) {\n            var author_1 = this.pdfViewer.annotationModule.updateAnnotationAuthor(annotationType, subType);\n            commentsContainer.setAttribute('author', author_1);\n        }\n        if (!this.isCreateContextMenu) {\n            this.createCommentContextMenu();\n        }\n        this.isCreateContextMenu = true;\n        if (commentsTitle.parentElement && commentsTitle.parentElement.clientWidth !== 0) {\n            commentsTitle.style.maxWidth = (commentsTitle.parentElement.clientWidth - moreOptionsButton.clientWidth) + 'px';\n        }\n        else {\n            commentsTitle.style.maxWidth = '237px';\n        }\n        commentTitleContainer.addEventListener('dblclick', this.openTextEditor.bind(this));\n        moreOptionsButton.addEventListener('mouseup', this.moreOptionsClick.bind(this));\n        return annotationType;\n    };\n    StickyNotesAnnotation.prototype.createReplyDivTitleContainer = function (commentsDivElement, modifiedDate, annotationAuthor) {\n        var replyTitleContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_replyTitleConatiner_' + this.commentsCount + '_' + this.commentsreplyCount, className: 'e-pv-reply-title-container' });\n        var replyTitle = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_replyTitle_' + this.commentsCount + '_' + this.commentsreplyCount, className: 'e-pv-reply-title' });\n        annotationAuthor = annotationAuthor.replace(/(\\r\\n|\\n|\\r)/gm, '');\n        if (!modifiedDate) {\n            replyTitle.textContent = annotationAuthor + ' - ' + this.setModifiedDate();\n        }\n        else {\n            replyTitle.textContent = annotationAuthor + ' - ' + this.setExistingAnnotationModifiedDate(modifiedDate);\n        }\n        replyTitleContainer.appendChild(replyTitle);\n        this.moreButtonId = this.pdfViewer.element.id + '_more-options_' + this.commentsCount + '_' + this.commentsreplyCount;\n        var moreButton = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('button', { id: this.moreButtonId, className: 'e-pv-more-options-button e-btn', attrs: { 'tabindex': '-1' } });\n        moreButton.style.visibility = 'hidden';\n        moreButton.style.zIndex = '1001';\n        moreButton.setAttribute('type', 'button');\n        moreButton.setAttribute('aria-label', 'more button');\n        var moreButtonSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + '_more-options_icon', className: 'e-pv-more-icon e-pv-icon' });\n        moreButton.appendChild(moreButtonSpan);\n        moreButtonSpan.style.opacity = '0.87';\n        replyTitleContainer.appendChild(moreButton);\n        commentsDivElement.appendChild(replyTitleContainer);\n        var parentCommentDiv = document.querySelectorAll('[class=\"e-pv-comment-title\"]');\n        var moreactionIcon = document.querySelectorAll('[class=\"e-pv-more-options-button e-btn\"]');\n        if (parentCommentDiv[0] && moreactionIcon[0] && parentCommentDiv[0].parentElement &&\n            parentCommentDiv[0].parentElement.clientWidth !== 0) {\n            replyTitle.style.maxWidth = (parentCommentDiv[0].parentElement.clientWidth - moreactionIcon[0].clientWidth) + 'px';\n        }\n        else {\n            replyTitle.style.maxWidth = '237px';\n        }\n        replyTitleContainer.addEventListener('dblclick', this.openTextEditor.bind(this));\n        moreButton.addEventListener('mouseup', this.moreOptionsClick.bind(this));\n    };\n    StickyNotesAnnotation.prototype.updateCommentIcon = function (commentSpan, annotationType, annotationSubType) {\n        if (annotationType === 'sticky') {\n            commentSpan.className = 'e-pv-comment-icon e-pv-icon';\n        }\n        else if (annotationType === 'stamp') {\n            commentSpan.className = 'e-pv-stamp-icon e-pv-icon';\n        }\n        else if (annotationType === 'shape') {\n            if (annotationSubType === 'Line') {\n                commentSpan.className = 'e-pv-shape-line-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'LineWidthArrowHead' || annotationSubType === 'Arrow') {\n                commentSpan.className = 'e-pv-shape-arrow-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Circle' || annotationSubType === 'Ellipse' || annotationSubType === 'Oval') {\n                commentSpan.className = 'e-pv-shape-circle-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Rectangle' || annotationSubType === 'Square') {\n                commentSpan.className = 'e-pv-shape-rectangle-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Polygon') {\n                commentSpan.className = 'e-pv-shape-pentagon-icon e-pv-icon';\n            }\n            else {\n                commentSpan.className = 'e-pv-annotation-shape-icon e-pv-icon';\n            }\n        }\n        else if (annotationType === 'measure') {\n            if (annotationSubType === 'Distance' || annotationSubType === 'Distance calculation') {\n                commentSpan.className = 'e-pv-calibrate-distance-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Perimeter' || annotationSubType === 'Perimeter calculation') {\n                commentSpan.className = 'e-pv-calibrate-perimeter-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Radius' || annotationSubType === 'Radius calculation') {\n                commentSpan.className = 'e-pv-calibrate-radius-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Area' || annotationSubType === 'Area calculation') {\n                commentSpan.className = 'e-pv-calibrate-area-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Volume' || annotationSubType === 'Volume calculation') {\n                commentSpan.className = 'e-pv-calibrate-volume-icon e-pv-icon';\n            }\n            else {\n                commentSpan.className = 'e-pv-annotation-calibrate-icon e-pv-icon';\n            }\n        }\n        else if (annotationType === 'textMarkup') {\n            if (annotationSubType === 'Highlight') {\n                commentSpan.className = 'e-pv-highlight-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Underline') {\n                commentSpan.className = 'e-pv-underline-icon e-pv-icon';\n            }\n            else if (annotationSubType === 'Strikethrough') {\n                commentSpan.className = 'e-pv-strikethrough-icon e-pv-icon';\n            }\n            else {\n                commentSpan.className = 'e-pv-annotation-icon e-pv-icon';\n            }\n        }\n        else if (annotationType === 'freeText') {\n            commentSpan.className = 'e-pv-freetext-icon e-pv-icon';\n        }\n        else if (annotationType === 'ink' || annotationSubType === 'Ink') {\n            commentSpan.className = 'e-pv-inkannotation-icon e-pv-icon';\n        }\n    };\n    StickyNotesAnnotation.prototype.updateStatusContainer = function (state, statusSpan, statusDiv, statusContainer) {\n        if (state === 'Accepted') {\n            statusDiv.style.backgroundColor = 'rgb(24,169,85)';\n            statusSpan.className = 'e-pv-accepted-icon';\n        }\n        else if (state === 'Completed') {\n            statusDiv.style.backgroundColor = 'rgb(0,122,255)';\n            statusSpan.className = 'e-pv-completed-icon';\n        }\n        else if (state === 'Cancelled') {\n            statusDiv.style.backgroundColor = 'rgb(245,103,0)';\n            statusSpan.className = 'e-pv-cancelled-icon';\n        }\n        else if (state === 'Rejected') {\n            statusDiv.style.backgroundColor = 'rgb(255,59,48)';\n            statusSpan.className = 'e-pv-rejected-icon';\n        }\n        else {\n            statusSpan.className = '';\n            statusContainer.parentElement.removeChild(statusContainer);\n        }\n    };\n    /**\n     * @param {HTMLElement} removeDiv -  It describes about the removeDiv\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateAccordionContainer = function (removeDiv) {\n        var pageNumber = parseInt(removeDiv.accessKey.split('_')[0], 10);\n        var accordionContent = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageNumber);\n        if (accordionContent) {\n            accordionContent.parentElement.removeChild(accordionContent);\n        }\n        var accordionContentContainer = document.getElementById(this.pdfViewer.element.id + '_accordionContentContainer');\n        if (accordionContentContainer) {\n            if (accordionContentContainer.childElementCount === 0) {\n                accordionContentContainer.style.display = 'none';\n                if (document.getElementById(this.pdfViewer.element.id + '_commentsPanelText')) {\n                    this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export Annotations')], false);\n                    this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export XFDF')], false);\n                    document.getElementById(this.pdfViewer.element.id + '_commentsPanelText').style.display = 'block';\n                    this.updateCommentPanelTextTop();\n                }\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.createCommentContextMenu = function () {\n        this.commentContextMenu = [\n            { text: this.pdfViewer.localeObj.getConstant('Edit') },\n            { text: this.pdfViewer.localeObj.getConstant('Delete Context') },\n            {\n                text: this.pdfViewer.localeObj.getConstant('Set Status'), items: [{ text: this.pdfViewer.localeObj.getConstant('None') }, { text: this.pdfViewer.localeObj.getConstant('Accepted') }, { text: this.pdfViewer.localeObj.getConstant('Cancelled') }, { text: this.pdfViewer.localeObj.getConstant('Completed') }, { text: this.pdfViewer.localeObj.getConstant('Rejected') }]\n            }\n        ];\n        var commentMenuElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('ul', { id: this.pdfViewer.element.id + '_comment_context_menu' });\n        this.pdfViewer.element.appendChild(commentMenuElement);\n        this.commentMenuObj = new _syncfusion_ej2_navigations__WEBPACK_IMPORTED_MODULE_2__.ContextMenu({\n            target: '#' + this.moreButtonId, items: this.commentContextMenu,\n            beforeOpen: this.contextMenuBeforeOpen.bind(this),\n            select: this.commentMenuItemSelect.bind(this)\n        });\n        if (this.pdfViewer.enableRtl) {\n            this.commentMenuObj.enableRtl = true;\n        }\n        this.commentMenuObj.appendTo(commentMenuElement);\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode) {\n            this.commentMenuObj.animationSettings.effect = 'ZoomIn';\n        }\n        else {\n            this.commentMenuObj.animationSettings.effect = 'SlideDown';\n        }\n    };\n    StickyNotesAnnotation.prototype.contextMenuBeforeOpen = function (args) {\n        var contextActiveDiv;\n        var contextDiv = document.querySelectorAll('.e-pv-more-options-button');\n        if (contextDiv) {\n            for (var i = 0; i < contextDiv.length; i++) {\n                if (contextDiv[parseInt(i.toString(), 10)].style.visibility === 'visible') {\n                    contextActiveDiv = contextDiv[parseInt(i.toString(), 10)].parentElement.nextSibling;\n                }\n            }\n        }\n        var isCommentLocked = this.checkIslockProperty(contextActiveDiv);\n        if (isCommentLocked) {\n            this.commentMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Edit')], false);\n            this.commentMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Delete Context')], false);\n        }\n        else {\n            this.commentMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Edit')], true);\n            this.commentMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Delete Context')], true);\n        }\n    };\n    StickyNotesAnnotation.prototype.commentMenuItemSelect = function (args) {\n        var contextActiveDiv;\n        var contextDiv = document.querySelectorAll('.e-pv-more-options-button');\n        if (contextDiv) {\n            for (var i = 0; i < contextDiv.length; i++) {\n                if (contextDiv[parseInt(i.toString(), 10)].style.visibility === 'visible') {\n                    contextActiveDiv = contextDiv[parseInt(i.toString(), 10)].parentElement.nextSibling;\n                }\n            }\n            if (args.item) {\n                switch (args.item.text) {\n                    case this.pdfViewer.localeObj.getConstant('Edit'): {\n                        var commentShow = document.querySelectorAll('.e-pv-new-comments-div');\n                        for (var i = 0; i < commentShow.length; i++) {\n                            commentShow[parseInt(i.toString(), 10)].style.display = 'none';\n                        }\n                        contextActiveDiv.ej2_instances[0].enableEditMode = true;\n                        break;\n                    }\n                    case this.pdfViewer.localeObj.getConstant('Delete Context'):\n                        if (contextActiveDiv.parentElement.parentElement.firstChild === contextActiveDiv.parentElement) {\n                            var annotationData = this.getAnnotationById(contextActiveDiv.parentElement.parentElement);\n                            if (annotationData) {\n                                var annotation = annotationData.annotation, pageIndex = annotationData.pageIndex;\n                                if (annotation) {\n                                    this.handleCommentDeletion(annotation);\n                                }\n                            }\n                        }\n                        else {\n                            this.modifyCommentDeleteProperty(contextActiveDiv.parentElement.parentElement, contextActiveDiv.parentElement);\n                        }\n                        break;\n                    case this.pdfViewer.localeObj.getConstant('Set Status'):\n                        break;\n                    case this.pdfViewer.localeObj.getConstant('Accepted'): {\n                        if (contextActiveDiv.parentElement.lastChild.id === this.pdfViewer.element.id + 'status_container') {\n                            contextActiveDiv.parentElement.lastChild.remove();\n                        }\n                        var acceptedStatusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                        var statusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                        var statusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon', className: 'e-pv-accepted-icon' });\n                        statusDiv.style.backgroundColor = 'rgb(24,169,85)';\n                        statusDiv.appendChild(statusSpan);\n                        acceptedStatusDiv.appendChild(statusDiv);\n                        contextActiveDiv.parentElement.appendChild(acceptedStatusDiv);\n                        this.modifyStatusProperty('Accepted', contextActiveDiv.parentElement);\n                        break;\n                    }\n                    case this.pdfViewer.localeObj.getConstant('Completed'): {\n                        if (contextActiveDiv.parentElement.lastChild.id === this.pdfViewer.element.id + 'status_container') {\n                            contextActiveDiv.parentElement.lastChild.remove();\n                        }\n                        var completedStatusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                        var statusElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                        var statusOptionSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon', className: 'e-pv-completed-icon' });\n                        statusElement.style.backgroundColor = 'rgb(0,122,255)';\n                        statusElement.appendChild(statusOptionSpan);\n                        completedStatusDiv.appendChild(statusElement);\n                        contextActiveDiv.parentElement.appendChild(completedStatusDiv);\n                        this.modifyStatusProperty('Completed', contextActiveDiv.parentElement);\n                        break;\n                    }\n                    case this.pdfViewer.localeObj.getConstant('Cancelled'): {\n                        if (contextActiveDiv.parentElement.lastChild.id === this.pdfViewer.element.id + 'status_container') {\n                            contextActiveDiv.parentElement.lastChild.remove();\n                        }\n                        var cancelStatusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                        var cancelStatusElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                        var cancelStatusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon', className: 'e-pv-cancelled-icon' });\n                        cancelStatusElement.style.backgroundColor = 'rgb(245,103,0)';\n                        cancelStatusElement.appendChild(cancelStatusSpan);\n                        cancelStatusDiv.appendChild(cancelStatusElement);\n                        contextActiveDiv.parentElement.appendChild(cancelStatusDiv);\n                        this.modifyStatusProperty('Cancelled', contextActiveDiv.parentElement);\n                        break;\n                    }\n                    case this.pdfViewer.localeObj.getConstant('Rejected'): {\n                        if (contextActiveDiv.parentElement.lastChild.id === this.pdfViewer.element.id + 'status_container') {\n                            contextActiveDiv.parentElement.lastChild.remove();\n                        }\n                        var rejectedStatusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                        var rejectedStatusElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                        var rejectedStatusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon', className: 'e-pv-rejected-icon' });\n                        rejectedStatusElement.style.backgroundColor = 'rgb(255,59,48)';\n                        rejectedStatusElement.appendChild(rejectedStatusSpan);\n                        rejectedStatusDiv.appendChild(rejectedStatusElement);\n                        contextActiveDiv.parentElement.appendChild(rejectedStatusDiv);\n                        this.modifyStatusProperty('Rejected', contextActiveDiv.parentElement);\n                        break;\n                    }\n                    case this.pdfViewer.localeObj.getConstant('None'):\n                        if (contextActiveDiv.parentElement.lastChild.id === this.pdfViewer.element.id + 'status_container') {\n                            contextActiveDiv.parentElement.lastChild.remove();\n                        }\n                        this.modifyStatusProperty('None', contextActiveDiv.parentElement);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.handleCommentDeletion = function (annotation) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.note) && annotation.note !== '') {\n            this.pdfViewer.fireCommentDelete(annotation.annotName, annotation.note, annotation);\n        }\n        this.pdfViewer.annotationModule.deleteAnnotation();\n    };\n    StickyNotesAnnotation.prototype.getAnnotationById = function (element) {\n        var pageNumber = parseInt(element.accessKey.split('_')[0], 10);\n        var pageIndex = pageNumber - 1;\n        var annotType = element.getAttribute('name');\n        var pageAnnotations = this.getAnnotations(pageIndex, null, annotType);\n        if (pageAnnotations) {\n            var annotation = pageAnnotations.find(function (annotation) { return annotation.annotName === element.id; }) || null;\n            return { annotation: annotation, pageIndex: pageIndex };\n        }\n        return null;\n    };\n    StickyNotesAnnotation.prototype.moreOptionsClick = function (event, isMoreOptionClick) {\n        if (document.getElementById(this.pdfViewer.element.id + '_comment_context_menu').style.display !== 'block') {\n            this.pdfViewer.annotationModule.checkContextMenuDeleteItem(this.commentMenuObj);\n            this.commentMenuObj.open(event.clientY, event.clientX, event.currentTarget);\n        }\n        if (this.pdfViewer.annotationModule && this.pdfViewer.annotationModule.inkAnnotationModule) {\n            var currentPageNumber = parseInt(this.pdfViewer.annotationModule.inkAnnotationModule.currentPageNumber, 10);\n            this.pdfViewer.annotationModule.inkAnnotationModule.drawInkAnnotation(currentPageNumber);\n        }\n    };\n    StickyNotesAnnotation.prototype.openTextEditor = function (event) {\n        var commentShow = document.querySelectorAll('.e-pv-new-comments-div');\n        for (var i = 0; i < commentShow.length; i++) {\n            commentShow[parseInt(i.toString(), 10)].style.display = 'none';\n        }\n        var isCommentLocked = this.checkIslockProperty(event.currentTarget.nextSibling);\n        if (isCommentLocked) {\n            event.currentTarget.nextSibling.ej2_instances[0].enableEditMode = false;\n        }\n        else if (event.currentTarget && event.target) {\n            var isLocked = this.checkAnnotationSettings(event.currentTarget.id);\n            if (!isLocked) {\n                event.currentTarget.nextSibling.ej2_instances[0].enableEditMode = true;\n            }\n        }\n        else {\n            event.currentTarget.nextSibling.ej2_instances[0].enableEditMode = true;\n        }\n    };\n    /**\n     * @param {any} commentEvent - It describes about the selected reply\n     * @private\n     * @returns {boolean} - boolean\n     */\n    StickyNotesAnnotation.prototype.checkIslockProperty = function (commentEvent) {\n        var annotCollection = this.pdfViewer.annotationCollection;\n        var annotation;\n        if (commentEvent.IsCommentLock) {\n            return true;\n        }\n        if (this.pdfViewer.annotationModule.textMarkupAnnotationModule &&\n            this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n            annotation = this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        else if (this.pdfViewer.selectedItems.annotations[0]) {\n            annotation = this.pdfViewer.selectedItems.annotations[0];\n        }\n        for (var i = 0; i < annotCollection.length; i++) {\n            annotCollection[parseInt(i.toString(), 10)].annotationSettings =\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotCollection[parseInt(i.toString(), 10)].annotationSettings) ?\n                    annotCollection[parseInt(i.toString(), 10)].annotationSettings : {};\n            var note = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotCollection[parseInt(i.toString(), 10)].note) ?\n                annotCollection[parseInt(i.toString(), 10)].note : annotCollection[parseInt(i.toString(), 10)].notes;\n            if (annotCollection[parseInt(i.toString(), 10)].annotationSettings.isLock &&\n                (commentEvent.textContent === note || annotCollection[parseInt(i.toString(), 10)].dynamicText === commentEvent.textContent)) {\n                return true;\n            }\n            else if (annotCollection[parseInt(i.toString(), 10)].isCommentLock &&\n                ((this.pdfViewer.selectedItems.annotations[parseInt(i.toString(), 10)] &&\n                    this.pdfViewer.selectedItems.annotations[parseInt(i.toString(), 10)].isCommentLock) ||\n                    (this.pdfViewer.annotationModule.textMarkupAnnotationModule &&\n                        this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation &&\n                        this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation.isCommentLock))) {\n                return true;\n            }\n            for (var j = 0; j < annotCollection[parseInt(i.toString(), 10)].comments.length; j++) {\n                if (annotation && annotCollection[parseInt(i.toString(), 10)].annotationId === annotation.annotName) {\n                    if (annotCollection[parseInt(i.toString(), 10)].comments[parseInt(j.toString(), 10)].isLock ===\n                        true && commentEvent.textContent === annotCollection[parseInt(i.toString(), 10)].\n                        comments[parseInt(j.toString(), 10)].note) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    StickyNotesAnnotation.prototype.openEditorElement = function (event) {\n        var commentShow = document.querySelectorAll('.e-pv-new-comments-div');\n        for (var i = 0; i < commentShow.length; i++) {\n            commentShow[parseInt(i.toString(), 10)].style.display = 'none';\n        }\n        var isCommentLocked = this.checkIslockProperty(event.currentTarget);\n        if (isCommentLocked) {\n            event.currentTarget.ej2_instances[0].enableEditMode = false;\n        }\n        else if (event.currentTarget && event.target) {\n            var isLocked = this.checkAnnotationSettings(event.currentTarget.id);\n            if (!isLocked) {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.selectedItems) &&\n                    this.pdfViewer.selectedItems.annotations[0] && this.pdfViewer.selectedItems.annotations[0].isReadonly) {\n                    event.currentTarget.ej2_instances[0].enableEditMode = false;\n                }\n                else {\n                    event.currentTarget.ej2_instances[0].enableEditMode = true;\n                }\n            }\n        }\n        else {\n            event.currentTarget.ej2_instances[0].enableEditMode = true;\n        }\n    };\n    StickyNotesAnnotation.prototype.commentsDivClickEvent = function (event) {\n        var annotation = this.findAnnotationObject(event.currentTarget.parentElement.id);\n        var isLocked = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation) ? (annotation.annotationSettings.isLock || annotation.isLock) : false;\n        if (!isLocked) {\n            var isCommentsSelect = false;\n            if (event.clientX === 0 && event.clientY === 0) {\n                this.isSetAnnotationType = true;\n            }\n            else {\n                this.isSetAnnotationType = false;\n            }\n            if (event.target.className === 'e-pv-more-icon e-pv-icon') {\n                return null;\n            }\n            var x = document.querySelectorAll('.e-pv-more-options-button');\n            for (var i = 0; i < x.length; i++) {\n                x[parseInt(i.toString(), 10)].style.visibility = 'hidden';\n            }\n            if (document.getElementById(this.pdfViewer.element.id + '_commantPanel').style.display === 'none') {\n                this.pdfViewer.annotationModule.showCommentsPanel();\n            }\n            if (event.currentTarget.parentElement.classList.contains('e-pv-comments-border')) {\n                isCommentsSelect = true;\n            }\n            event.currentTarget.firstChild.lastChild.style.visibility = 'visible';\n            var commentsContainer = document.querySelectorAll('.e-pv-comments-border');\n            if (commentsContainer) {\n                for (var j = 0; j < commentsContainer.length; j++) {\n                    commentsContainer[parseInt(j.toString(), 10)].classList.remove('e-pv-comments-border');\n                }\n            }\n            event.currentTarget.parentElement.classList.add('e-pv-comments-border');\n            var commentShow = document.querySelectorAll('.e-pv-new-comments-div');\n            for (var i = 0; i < commentShow.length; i++) {\n                commentShow[parseInt(i.toString(), 10)].style.display = 'none';\n            }\n            var editElement = event.currentTarget.parentElement.lastChild;\n            var commentsElement = event.currentTarget.parentElement;\n            if (editElement) {\n                editElement.style.display = 'block';\n                if (editElement.querySelector('.e-editable-inline')) {\n                    if (!this.isEditableElement) {\n                        editElement.querySelector('.e-editable-inline').style.display = 'block';\n                    }\n                    for (var i = 0; i < commentsElement.childElementCount; i++) {\n                        var activeElement = commentsElement.childNodes[parseInt(i.toString(), 10)];\n                        var textElement = activeElement.querySelector('.e-editable-inline');\n                        if (textElement) {\n                            if (textElement.style.display === '') {\n                                editElement.style.display = 'none';\n                                editElement.querySelector('.e-editable-inline').style.display = 'none';\n                            }\n                        }\n                    }\n                }\n                if (this.isSetAnnotationType) {\n                    if (!isCommentsSelect) {\n                        this.updateCommentsScrollTop();\n                    }\n                }\n            }\n            if (event.currentTarget.parentElement.childElementCount === 1) {\n                if (!this.pdfViewer.enableShapeLabel) {\n                    event.currentTarget.childNodes[1].ej2_instances[0].enableEditMode = true;\n                }\n                else {\n                    var type = event.currentTarget.parentElement.getAttribute('name');\n                    if (this.isSetAnnotationType && type === 'shape') {\n                        event.currentTarget.childNodes[1].ej2_instances[0].enableEditMode = false;\n                    }\n                    else {\n                        event.currentTarget.childNodes[1].ej2_instances[0].enableEditMode = true;\n                    }\n                }\n            }\n            var editModule = void 0;\n            if (event && event.currentTarget && event.currentTarget.childNodes[1]) {\n                editModule = event.currentTarget.childNodes[1].ej2_instances[0];\n            }\n            if (event.currentTarget && event.currentTarget.id && editModule) {\n                if (annotation && annotation.isCommentLock) {\n                    editModule.enableEditMode = false;\n                    this.createCommentDiv(event.currentTarget);\n                }\n                this.pdfViewer.fireCommentSelect(event.currentTarget.id, event.currentTarget.childNodes[1].ej2_instances[0].value, annotation);\n            }\n            this.commentDivOnSelect(event);\n            event.preventDefault();\n        }\n    };\n    StickyNotesAnnotation.prototype.commentsDivDoubleClickEvent = function (event) {\n        var commentShow = document.querySelectorAll('.e-pv-new-comments-div');\n        for (var i = 0; i < commentShow.length; i++) {\n            commentShow[parseInt(i.toString(), 10)].style.display = 'none';\n        }\n        var isCommentLocked = this.checkIslockProperty(event.currentTarget.children[1]);\n        if (isCommentLocked) {\n            if (event.currentTarget.childElementCount === 2) {\n                event.currentTarget.lastChild.ej2_instances[0].enableEditMode = false;\n            }\n            else {\n                event.currentTarget.childNodes[1].ej2_instances[0].enableEditMode = false;\n            }\n        }\n        else if (event.currentTarget && event.target) {\n            var isLocked = this.checkAnnotationSettings(event.currentTarget.id);\n            if (!isLocked) {\n                if (event.currentTarget.childElementCount === 2) {\n                    event.currentTarget.lastChild.ej2_instances[0].enableEditMode = true;\n                }\n                else {\n                    event.currentTarget.childNodes[1].ej2_instances[0].enableEditMode = true;\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.commentDivOnSelect = function (event) {\n        var commentSelect = document.querySelectorAll('.e-pv-comments-select');\n        for (var z = 0; z < commentSelect.length; z++) {\n            commentSelect[parseInt(z.toString(), 10)].classList.remove('e-pv-comments-select');\n        }\n        var activeElement = document.getElementById(event.currentTarget.id);\n        if (activeElement) {\n            activeElement.classList.remove('e-pv-comments-hover');\n            activeElement.classList.remove('e-pv-comments-leave');\n            activeElement.classList.add('e-pv-comments-select');\n            if (event.currentTarget.nextSibling) {\n                if (event.currentTarget.nextSibling.classList.contains('e-pv-new-comments-div')) {\n                    var activeSiblingElement = document.getElementById(event.currentTarget.nextSibling.id);\n                    activeSiblingElement.classList.remove('e-pv-comments-hover');\n                    activeSiblingElement.classList.remove('e-pv-comments-leave');\n                    activeSiblingElement.classList.add('e-pv-comments-select');\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.commentDivMouseOver = function (event) {\n        var activeElement = document.getElementById(event.currentTarget.id);\n        if (activeElement) {\n            activeElement.classList.remove('e-pv-comments-select');\n            activeElement.classList.remove('e-pv-comments-leave');\n            activeElement.classList.add('e-pv-comments-hover');\n            if (event.currentTarget.nextSibling) {\n                if (event.currentTarget.nextSibling.classList.contains('e-pv-new-comments-div')) {\n                    var activeSiblingElement = document.getElementById(event.currentTarget.nextSibling.id);\n                    activeSiblingElement.classList.remove('e-pv-comments-select');\n                    activeSiblingElement.classList.remove('e-pv-comments-leave');\n                    activeSiblingElement.classList.add('e-pv-comments-hover');\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.commentDivMouseLeave = function (event) {\n        var activeElement = document.getElementById(event.currentTarget.id);\n        if (activeElement) {\n            activeElement.classList.remove('e-pv-comments-hover');\n            activeElement.classList.remove('e-pv-comments-select');\n            activeElement.classList.add('e-pv-comments-leave');\n            if (event.currentTarget.nextSibling) {\n                if (event.currentTarget.nextSibling.classList.contains('e-pv-new-comments-div')) {\n                    var activeSiblingElement = document.getElementById(event.currentTarget.nextSibling.id);\n                    activeSiblingElement.classList.remove('e-pv-comments-hover');\n                    activeSiblingElement.classList.remove('e-pv-comments-select');\n                    activeSiblingElement.classList.add('e-pv-comments-leave');\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} event -  It describes about the event\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.drawIcons = function (event) {\n        if (this.pdfViewerBase.isCommentIconAdded) {\n            var pageIndex = this.pdfViewer.annotation.getEventPageNumber(event);\n            var pageCurrentRect = this.pdfViewerBase.getElement('_pageDiv_' + pageIndex).getBoundingClientRect();\n            var zoomValue = this.pdfViewerBase.getZoomFactor();\n            this.pdfViewer.annotationModule.isFormFieldShape = false;\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.\n                drawStickyNotes((event.clientX - pageCurrentRect.left) / zoomValue, (event.clientY - pageCurrentRect.top) / zoomValue, 30, 30, pageIndex, null);\n            this.pdfViewerBase.isCommentIconAdded = false;\n            var commentsButton = document.getElementById(this.pdfViewer.element.id + '_comment');\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                commentsButton = commentsButton.children[0];\n            }\n            if (commentsButton && commentsButton.classList.contains('e-pv-select')) {\n                commentsButton.classList.remove('e-pv-select');\n            }\n            else {\n                var commentsIcon = document.getElementById(this.pdfViewer.element.id + '_commentIcon');\n                if (commentsIcon) {\n                    if (this.pdfViewer.enableRtl) {\n                        commentsIcon.className = 'e-pv-comment-icon e-pv-icon e-icon-left e-right';\n                    }\n                    else {\n                        commentsIcon.className = 'e-pv-comment-icon e-pv-icon e-icon-left';\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {string} annotationType - It describes about the annotation type\n     * @param {number} pageNumber - It describes about the page number\n     * @param {string} annotationSubType - It describes about the annotation sub type\n     * @private\n     * @returns {string} - string\n     */\n    StickyNotesAnnotation.prototype.addComments = function (annotationType, pageNumber, annotationSubType) {\n        var commentsDivid;\n        var accordion = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + pageNumber);\n        if (accordion) {\n            commentsDivid = this.pdfViewer.annotation.stickyNotesAnnotationModule.\n                createCommentControlPanel(null, pageNumber, annotationType, annotationSubType);\n        }\n        else {\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.createPageAccordion(pageNumber);\n            commentsDivid = this.pdfViewer.annotation.stickyNotesAnnotationModule.\n                createCommentControlPanel(null, pageNumber, annotationType, annotationSubType);\n        }\n        return commentsDivid;\n    };\n    StickyNotesAnnotation.prototype.commentsAnnotationSelect = function (event) {\n        var element = event.currentTarget;\n        var isLocked = this.checkAnnotationSettings(element.id);\n        // When the isLock is set to true, it comes and checks whether the allowedInteractions is select and set the isLock to false, In that case if enters the condition and makes the comment panel to editable mode. So, have removed the condition in openEditorElement, commentsDivClickEvent, openTextEditor,commentAnnotationSelect methods. (Task id: 835410)\n        if (!isLocked) {\n            if (element.classList.contains('e-pv-comments-border')) {\n                var commentsDiv = document.querySelectorAll('.e-pv-comments-div');\n                for (var j = 0; j < commentsDiv.length; j++) {\n                    commentsDiv[parseInt(j.toString(), 10)].style.minHeight = 60 + 'px';\n                }\n                if (event.currentTarget.childElementCount === 1) {\n                    if (event.currentTarget.childNodes[0].querySelector('.e-editable-inline')) {\n                        event.currentTarget.childNodes[0].style.minHeight = event.currentTarget.childNodes[0].clientHeight;\n                    }\n                }\n            }\n            if (event.target.className === 'e-pv-more-icon e-pv-icon' || event.target.className === 'e-pv-more-options-button e-btn') {\n                event.preventDefault();\n                return null;\n            }\n            var pageNumber = parseInt(element.accessKey.split('_')[0], 10);\n            if (!element.classList.contains('e-pv-comments-border')) {\n                var commentsContainer = document.querySelectorAll('.e-pv-comments-border');\n                if (commentsContainer) {\n                    for (var j = 0; j < commentsContainer.length; j++) {\n                        commentsContainer[parseInt(j.toString(), 10)].classList.remove('e-pv-comments-border');\n                    }\n                }\n                var commentsDiv = document.getElementById(element.id);\n                if (commentsDiv) {\n                    document.querySelectorAll('.e-pv-more-options-button[style*=\"visibility: visible\"]').forEach(function (moreButton) { return moreButton.style.visibility = 'hidden'; });\n                    if (event.target.className === 'e-editable-value-wrapper') {\n                        event.target.parentElement.parentElement.firstChild.lastChild.style.visibility = 'visible';\n                    }\n                    else if (event.target.className === 'e-pv-reply-title' || event.target.className === 'e-pv-comment-title') {\n                        event.target.parentElement.lastChild.style.visibility = 'visible';\n                    }\n                    else if (event.target.className === 'e-editable-value') {\n                        event.target.parentElement.parentElement.parentElement.firstChild.lastChild.style.visibility = 'visible';\n                    }\n                    commentsDiv.classList.add('e-pv-comments-border');\n                }\n                var commentTextBox = document.querySelectorAll('.e-pv-new-comments-div');\n                for (var j = 0; j < commentTextBox.length; j++) {\n                    commentTextBox[parseInt(j.toString(), 10)].style.display = 'none';\n                }\n                if (commentsDiv) {\n                    var currentTextBox = commentsDiv.querySelector('.e-pv-new-comments-div');\n                    if (currentTextBox) {\n                        currentTextBox.style.display = 'block';\n                    }\n                }\n                var textDiv = element.lastChild;\n                this.isEditableElement = false;\n                if (textDiv.querySelector('.e-editable-inline')) {\n                    textDiv.style.display = 'block';\n                    textDiv.querySelector('.e-editable-inline').style.display = 'block';\n                    for (var i = 0; i < element.childElementCount; i++) {\n                        var activeElement = element.childNodes[parseInt(i.toString(), 10)];\n                        var textElement = activeElement.querySelector('.e-editable-inline');\n                        if (textElement) {\n                            if (textElement.style.display === '') {\n                                if (textDiv.classList.contains('e-pv-new-comments-div')) {\n                                    this.isEditableElement = true;\n                                    textDiv.style.display = 'none';\n                                    textDiv.querySelector('.e-editable-inline').style.display = 'none';\n                                }\n                            }\n                        }\n                    }\n                }\n                this.isSetAnnotationType = false;\n                if (event.currentTarget.childElementCount === 1) {\n                    event.currentTarget.childNodes[0].childNodes[1].ej2_instances[0].enableEditMode = true;\n                }\n            }\n            else {\n                this.isSetAnnotationType = true;\n            }\n            if (!this.isSetAnnotationType) {\n                var annotType = element.getAttribute('name');\n                if (annotType === 'null' || annotType === 'Ink') {\n                    annotType = 'ink';\n                }\n                this.isCommentsSelected = false;\n                this.setAnnotationType(element.id, annotType, pageNumber);\n                if (!this.isCommentsSelected) {\n                    this.selectAnnotationObj = { id: element.id, annotType: annotType, pageNumber: pageNumber };\n                }\n                if (this.pdfViewer.navigation) {\n                    this.pdfViewer.navigationModule.goToPage(pageNumber);\n                }\n            }\n        }\n        else {\n            var pageNumber = parseInt(element.accessKey.split('_')[0], 10);\n            if (this.pdfViewer.navigation) {\n                this.pdfViewer.navigationModule.goToPage(pageNumber);\n            }\n            var annotType = element.getAttribute('name');\n            if (annotType === 'null' || annotType === 'Ink') {\n                annotType = 'ink';\n            }\n            this.isCommentsSelected = false;\n            this.setAnnotationType(element.id, annotType, pageNumber);\n            if (!this.isCommentsSelected) {\n                this.selectAnnotationObj = { id: element.id, annotType: annotType, pageNumber: pageNumber };\n            }\n        }\n        this.isSetAnnotationType = false;\n    };\n    StickyNotesAnnotation.prototype.findAnnotationObject = function (id) {\n        if (this.pdfViewer.annotationModule.textMarkupAnnotationModule &&\n            this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n            return this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        else if (this.pdfViewer.selectedItems.annotations[0]) {\n            return this.pdfViewer.selectedItems.annotations[0];\n        }\n        var annotationCollection = this.pdfViewer.annotationCollection;\n        if (annotationCollection) {\n            for (var i = 0; i < annotationCollection.length; i++) {\n                if (annotationCollection[parseInt(i.toString(), 10)].annotationId &&\n                    (annotationCollection[parseInt(i.toString(), 10)].annotationId === id)) {\n                    if (annotationCollection[parseInt(i.toString(), 10)].shapeAnnotationType === 'textMarkup') {\n                        return annotationCollection[parseInt(i.toString(), 10)];\n                    }\n                    else {\n                        annotationCollection = this.pdfViewer.annotations;\n                        for (var j = 0; j < annotationCollection.length; j++) {\n                            if (annotationCollection[parseInt(j.toString(), 10)].annotName &&\n                                (annotationCollection[parseInt(j.toString(), 10)].annotName === id)) {\n                                return annotationCollection[parseInt(j.toString(), 10)];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.checkAnnotationSettings = function (annotId) {\n        var annotationCollection = this.pdfViewer.annotationCollection;\n        if (annotationCollection) {\n            var annot = annotationCollection.find(function (annotation) { return annotation.annotationId === annotId; });\n            if (annot && annot.annotationSettings && annot.annotationSettings.isLock) {\n                if (!annot.isCommentLock && annot.comments.length === 0 && ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annot.note) || annot.note === '') && annot.shapeAnnotationType !== 'FreeText') {\n                    return true;\n                }\n                else if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annot.comments) && annot.comments.length > 0 &&\n                    annot.comments[0].isLock) || annot.isCommentLock) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    StickyNotesAnnotation.prototype.updateCommentsContainerWidth = function () {\n        var accordionContainer = document.getElementById(this.pdfViewer.element.id + '_accordionContentContainer');\n        var commentsContentContainer = document.getElementById(this.pdfViewer.element.id + '_commentscontentcontainer');\n        accordionContainer.style.width = commentsContentContainer.clientWidth + 'px';\n    };\n    /**\n     * @param {number} pageIndex - It describes about the page index\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.selectCommentsAnnotation = function (pageIndex) {\n        if (this.selectAnnotationObj && !this.isCommentsSelected) {\n            if ((this.selectAnnotationObj.pageNumber - 1) === pageIndex) {\n                this.setAnnotationType(this.selectAnnotationObj.id, this.selectAnnotationObj.annotType, this.selectAnnotationObj.pageNumber);\n                this.selectAnnotationObj = null;\n                this.isCommentsSelected = true;\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.setAnnotationType = function (id, type, pageNumber) {\n        var typeString = (type === 'measure') ? 'shape_measure' : type;\n        if (typeString === 'freeText') {\n            typeString = 'freetext';\n        }\n        var storeCommentObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_' + typeString);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeCommentObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_' + typeString];\n        }\n        if (storeCommentObject) {\n            var annotationCommentObject = JSON.parse(storeCommentObject);\n            var annotation = this.pdfViewer.selectedItems.annotations[0];\n            var index = this.pdfViewer.annotationModule.\n                getPageCollection(annotationCommentObject, (pageNumber - 1));\n            if (index != null && annotationCommentObject[parseInt(index.toString(), 10)]) {\n                var pageCollections = annotationCommentObject[parseInt(index.toString(), 10)].annotations;\n                for (var i = 0; i < pageCollections.length; i++) {\n                    var currentSelector = pageCollections[parseInt(i.toString(), 10)].annotationSelectorSettings;\n                    if (pageCollections[parseInt(i.toString(), 10)].annotName === id) {\n                        if (annotation) {\n                            this.pdfViewer.annotation.triggerAnnotationUnselectEvent();\n                            this.pdfViewer.annotation.triggerSignatureUnselectEvent();\n                        }\n                        this.pdfViewer.clearSelection(pageNumber - 1);\n                        if (type === 'textMarkup') {\n                            this.pdfViewer.annotationModule.textMarkupAnnotationModule.\n                                clearCurrentAnnotationSelection(pageNumber - 1, true);\n                            var canvasId = annotation && annotation.textMarkupAnnotationType === 'Highlight' ?\n                                '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n                            var canvas = this.pdfViewerBase.getElement(canvasId + (pageNumber - 1));\n                            this.pdfViewer.annotationModule.textMarkupAnnotationModule.\n                                selectAnnotation(pageCollections[parseInt(i.toString(), 10)], canvas, (pageNumber - 1));\n                            this.pdfViewer.annotation.textMarkupAnnotationModule.currentTextMarkupAnnotation =\n                                pageCollections[parseInt(i.toString(), 10)];\n                            this.pdfViewer.annotation.textMarkupAnnotationModule.selectTextMarkupCurrentPage = pageNumber - 1;\n                            this.pdfViewer.annotation.textMarkupAnnotationModule.enableAnnotationPropertiesTool(true);\n                            if (this.pdfViewer.toolbarModule && this.pdfViewer.enableAnnotationToolbar) {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.isToolbarHidden = true;\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.\n                                    showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                            }\n                        }\n                        else if (type === 'stamp') {\n                            this.pdfViewer.select([pageCollections[parseInt(i.toString(), 10)].randomId], currentSelector);\n                            this.pdfViewer.annotation.onAnnotationMouseDown();\n                        }\n                        else if (type === 'sticky') {\n                            this.pdfViewer.select([pageCollections[parseInt(i.toString(), 10)].annotName], currentSelector);\n                            this.pdfViewer.annotation.onAnnotationMouseDown();\n                        }\n                        else if (type === 'ink') {\n                            this.pdfViewer.select([pageCollections[parseInt(i.toString(), 10)].id], currentSelector);\n                            this.pdfViewer.annotation.onAnnotationMouseDown();\n                        }\n                        else {\n                            this.pdfViewer.select([pageCollections[parseInt(i.toString(), 10)].id], currentSelector);\n                            this.pdfViewer.annotation.onAnnotationMouseDown();\n                        }\n                        if (type === 'textMarkup') {\n                            if (pageCollections[parseInt(i.toString(), 10)].rect || pageCollections[parseInt(i.toString(), 10)].bounds) {\n                                var scrollValue = this.pdfViewerBase.pageSize[pageNumber - 1].top *\n                                    this.pdfViewerBase.getZoomFactor() + (this.pdfViewer.annotationModule.\n                                    getAnnotationTop(pageCollections[parseInt(i.toString(), 10)]) * this.pdfViewerBase.getZoomFactor());\n                                if (scrollValue) {\n                                    var scroll_1 = (scrollValue - 20).toString();\n                                    this.pdfViewerBase.viewerContainer.scrollTop = parseInt(scroll_1, 10);\n                                }\n                            }\n                        }\n                        else {\n                            var top_1 = pageCollections[parseInt(i.toString(), 10)].bounds.top;\n                            if (type === 'ink') {\n                                top_1 = pageCollections[parseInt(i.toString(), 10)].bounds.y;\n                            }\n                            var scrollValue = this.pdfViewerBase.pageSize[pageNumber - 1].top *\n                                this.pdfViewerBase.getZoomFactor() + ((top_1) * this.pdfViewerBase.getZoomFactor());\n                            var scroll_2 = (scrollValue - 20).toString();\n                            this.pdfViewerBase.viewerContainer.scrollTop = parseInt(scroll_2, 10);\n                        }\n                        this.isCommentsSelected = true;\n                    }\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.modifyTextProperty = function (text, previousValue, annotationName) {\n        var currentAnnotation;\n        var module = this.pdfViewer.annotationModule.textMarkupAnnotationModule;\n        if (module && module.currentTextMarkupAnnotation) {\n            currentAnnotation = this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        if (currentAnnotation) {\n            if (currentAnnotation.annotName !== annotationName) {\n                currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n            }\n        }\n        else {\n            currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentAnnotation) && annotationName || (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentAnnotation) &&\n            currentAnnotation.annotName !== annotationName)) {\n            currentAnnotation = this.pdfViewer.annotationCollection.filter(function (annot) { return annot.annotationId === annotationName; })[0];\n        }\n        if (annotationName && (currentAnnotation.annotName !== annotationName)) {\n            for (var i = 0; i < this.pdfViewer.annotations.length; i++) {\n                if (annotationName === this.pdfViewer.annotations[parseInt(i.toString(), 10)].annotName) {\n                    currentAnnotation = this.pdfViewer.annotations[parseInt(i.toString(), 10)];\n                    break;\n                }\n            }\n        }\n        if (currentAnnotation) {\n            currentAnnotation.annotName = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentAnnotation.annotName) ?\n                currentAnnotation.annotName : currentAnnotation.annotationId;\n            var commentsDiv = document.getElementById(currentAnnotation.annotName);\n            if (commentsDiv) {\n                var pageNumber = void 0;\n                if (commentsDiv.accessKey.split('_')[0]) {\n                    pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n                }\n                else {\n                    pageNumber = this.pdfViewerBase.currentPageNumber;\n                }\n                var type = commentsDiv.getAttribute('name');\n                var pageIndex = pageNumber - 1;\n                var pageAnnotations = void 0;\n                var isMeasure = false;\n                if (currentAnnotation.shapeAnnotationType === 'FreeText' || (this.pdfViewer.enableShapeLabel && (type === 'shape' || type === 'shape_measure'))) {\n                    var isTextAdded = false;\n                    if (annotationName) {\n                        if (currentAnnotation.annotName !== annotationName) {\n                            this.pdfViewer.annotation.modifyDynamicTextValue(text, annotationName);\n                            isTextAdded = true;\n                        }\n                    }\n                    if (!isTextAdded) {\n                        if (currentAnnotation.shapeAnnotationType === 'FreeText') {\n                            if (currentAnnotation.dynamicText !== text) {\n                                this.textFromCommentPanel = true;\n                                this.pdfViewer.annotation.modifyDynamicTextValue(text, currentAnnotation.annotName);\n                            }\n                            currentAnnotation.dynamicText = text;\n                        }\n                        else {\n                            this.pdfViewer.annotation.modifyDynamicTextValue(text, currentAnnotation.annotName);\n                            currentAnnotation.labelContent = text;\n                            currentAnnotation.notes = text;\n                        }\n                        this.pdfViewer.nodePropertyChange(currentAnnotation, {});\n                    }\n                }\n                if (currentAnnotation.measureType && currentAnnotation.measureType !== '') {\n                    pageAnnotations = this.getAnnotations(pageIndex, null, 'shape_measure');\n                    isMeasure = true;\n                }\n                else {\n                    pageAnnotations = this.getAnnotations(pageIndex, null, currentAnnotation.shapeAnnotationType);\n                }\n                if (pageAnnotations !== null && currentAnnotation.shapeAnnotationType !== 'FreeText') {\n                    for (var i = 0; i < pageAnnotations.length; i++) {\n                        if (pageAnnotations[parseInt(i.toString(), 10)].annotName === currentAnnotation.annotName) {\n                            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(pageAnnotations[parseInt(i.toString(), 10)]);\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(text) && text !== '' || (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(text) && text === '' &&\n                                previousValue !== '')) {\n                                if (pageAnnotations[parseInt(i.toString(), 10)].note !== text) {\n                                    this.pdfViewer.annotation.addAction(pageIndex, i, pageAnnotations[parseInt(i.toString(), 10)], 'Text Property Added', '', clonedObject, pageAnnotations[parseInt(i.toString(), 10)]);\n                                    currentAnnotation = pageAnnotations[parseInt(i.toString(), 10)];\n                                    currentAnnotation.note = text;\n                                    if (currentAnnotation.enableShapeLabel) {\n                                        currentAnnotation.labelContent = text;\n                                    }\n                                    currentAnnotation.modifiedDate = this.getDateAndTime();\n                                    if (!isMeasure) {\n                                        this.updateUndoRedoCollections(currentAnnotation, pageIndex);\n                                    }\n                                    else {\n                                        this.updateUndoRedoCollections(currentAnnotation, pageIndex, 'shape_measure');\n                                    }\n                                    if (!previousValue || previousValue === '') {\n                                        this.pdfViewer.fireCommentAdd(currentAnnotation.annotName, currentAnnotation.note, currentAnnotation);\n                                    }\n                                    else {\n                                        this.pdfViewer.fireCommentEdit(currentAnnotation.annotName, currentAnnotation.note, currentAnnotation);\n                                    }\n                                    return currentAnnotation;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} date - It describes about the date\n     * @private\n     * @returns {string} - string\n     */\n    StickyNotesAnnotation.prototype.getDateAndTime = function (date) {\n        if (!date) {\n            date = new Date();\n        }\n        this.globalize = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Internationalization();\n        var dateOptions = { format: 'M/d/yyyy h:mm:ss a', type: 'dateTime' };\n        var dateTime = this.globalize.formatDate(new Date(date), dateOptions);\n        return dateTime;\n    };\n    StickyNotesAnnotation.prototype.getDateAndTimeFormat = function (date) {\n        if (!date) {\n            date = new Date();\n        }\n        this.globalize = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Internationalization();\n        var dateOptions = { format: this.pdfViewer.dateTimeFormat, type: 'dateTime' };\n        var dateTime = this.globalize.formatDate(new Date(date), dateOptions);\n        return dateTime;\n    };\n    StickyNotesAnnotation.prototype.modifyCommentsProperty = function (text, annotName, parentElement, previousValue) {\n        var currentAnnotation;\n        if (this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n            currentAnnotation = this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        else {\n            currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        }\n        if (!currentAnnotation) {\n            var annotationKeys = Object.keys(this.pdfViewer.nameTable);\n            for (var i = 0; i < annotationKeys.length; i++) {\n                var annotObject = this.pdfViewer.nameTable[annotationKeys[parseInt(i.toString(), 10)]];\n                if (parentElement === annotObject.annotName) {\n                    currentAnnotation = annotObject;\n                    break;\n                }\n            }\n        }\n        if (currentAnnotation) {\n            var commentsDiv = document.getElementById(currentAnnotation.annotName);\n            var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n            var pageIndex = pageNumber - 1;\n            var pageAnnotations = void 0;\n            var isMeasure = false;\n            var author = this.getAuthorName(currentAnnotation, commentsDiv);\n            if (currentAnnotation.measureType && currentAnnotation.measureType !== '') {\n                pageAnnotations = this.getAnnotations(pageIndex, null, 'shape_measure');\n                isMeasure = true;\n            }\n            else {\n                pageAnnotations = this.getAnnotations(pageIndex, null, currentAnnotation.shapeAnnotationType);\n            }\n            if (pageAnnotations !== null) {\n                for (var i = 0; i < pageAnnotations.length; i++) {\n                    if (pageAnnotations[parseInt(i.toString(), 10)].annotName === currentAnnotation.annotName) {\n                        currentAnnotation = pageAnnotations[parseInt(i.toString(), 10)];\n                    }\n                }\n            }\n            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(currentAnnotation);\n            if (currentAnnotation.comments.length > 0) {\n                var isComment = false;\n                for (var j = 0; j < currentAnnotation.comments.length; j++) {\n                    if (currentAnnotation.comments[parseInt(j.toString(), 10)].annotName === annotName) {\n                        isComment = true;\n                        currentAnnotation.comments[parseInt(j.toString(), 10)].note = text;\n                        currentAnnotation.comments[parseInt(j.toString(), 10)].modifiedDate = this.getDateAndTime();\n                    }\n                }\n                if (currentAnnotation.annotName === parentElement) {\n                    var newArray = { annotName: annotName, parentId: parentElement, subject: currentAnnotation.subject, comments: [], author: author, note: text, shapeAnnotationType: '', state: '', stateModel: '', modifiedDate: this.getDateAndTime(), review: { state: '', stateModel: '', modifiedDate: this.getDateAndTime(), author: author }, isLock: false };\n                    if (!isComment) {\n                        currentAnnotation.comments[currentAnnotation.comments.length] = newArray;\n                    }\n                }\n            }\n            else if (currentAnnotation.annotName === parentElement) {\n                var newArray = { annotName: annotName, parentId: parentElement, subject: currentAnnotation.subject, comments: [], author: author, note: text, shapeAnnotationType: '', state: '', stateModel: '', modifiedDate: this.getDateAndTime(), review: { state: '', stateModel: '', modifiedDate: this.getDateAndTime(), author: author }, isLock: false };\n                currentAnnotation.comments[currentAnnotation.comments.length] = newArray;\n            }\n            this.pdfViewer.annotation.addAction(pageIndex, null, currentAnnotation, 'Comments Property Added', '', clonedObject, currentAnnotation);\n            if (!isMeasure) {\n                this.updateUndoRedoCollections(currentAnnotation, pageIndex);\n            }\n            else {\n                this.updateUndoRedoCollections(currentAnnotation, pageIndex, 'shape_measure');\n            }\n        }\n        if (previousValue !== undefined) {\n            this.pdfViewer.fireCommentEdit(annotName, text, currentAnnotation);\n        }\n        else {\n            this.pdfViewer.fireCommentAdd(annotName, text, currentAnnotation);\n        }\n    };\n    StickyNotesAnnotation.prototype.modifyStatusProperty = function (text, statusElement) {\n        var currentAnnotation;\n        if (this.pdfViewer.annotation.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n            currentAnnotation = this.pdfViewer.annotation.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        else {\n            currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        }\n        if (currentAnnotation) {\n            var commentsDiv = document.getElementById(currentAnnotation.annotName);\n            var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n            var pageIndex = pageNumber - 1;\n            var pageAnnotations = void 0;\n            var isMeasure = false;\n            var author = commentsDiv.getAttribute('author');\n            if (currentAnnotation.measureType && currentAnnotation.measureType !== '') {\n                pageAnnotations = this.getAnnotations(pageIndex, null, 'shape_measure');\n                isMeasure = true;\n            }\n            else {\n                pageAnnotations = this.getAnnotations(pageIndex, null, currentAnnotation.shapeAnnotationType);\n            }\n            if (pageAnnotations !== null) {\n                for (var i = 0; i < pageAnnotations.length; i++) {\n                    if (pageAnnotations[parseInt(i.toString(), 10)].annotName === currentAnnotation.annotName) {\n                        currentAnnotation = pageAnnotations[parseInt(i.toString(), 10)];\n                    }\n                }\n            }\n            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(currentAnnotation);\n            if (statusElement.parentElement.firstChild.id === statusElement.id) {\n                currentAnnotation.review = { state: text, stateModel: 'Review', author: author, modifiedDate: this.getDateAndTime(), annotId: statusElement.id };\n                currentAnnotation.state = text;\n                currentAnnotation.stateModel = 'Review';\n                this.pdfViewer.annotation.addAction(pageIndex, null, currentAnnotation, 'Status Property Added', '', clonedObject, currentAnnotation);\n                this.pdfViewer.fireCommentStatusChanged(statusElement.id, currentAnnotation.note, currentAnnotation, currentAnnotation.state);\n            }\n            else {\n                for (var j = 0; j < currentAnnotation.comments.length; j++) {\n                    if (currentAnnotation.comments[parseInt(j.toString(), 10)].annotName === statusElement.id) {\n                        var clonedObj = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(currentAnnotation.comments[parseInt(j.toString(), 10)]);\n                        currentAnnotation.comments[parseInt(j.toString(), 10)].state = text;\n                        currentAnnotation.comments[parseInt(j.toString(), 10)].stateModel = 'Review';\n                        currentAnnotation.comments[parseInt(j.toString(), 10)].review = { state: text, stateModel: 'Review', author: author, modifiedDate: this.getDateAndTime(), annotId: statusElement.id };\n                        this.pdfViewer.annotation.addAction(pageIndex, null, currentAnnotation, 'Status Property Added', '', clonedObj, currentAnnotation.comments[parseInt(j.toString(), 10)]);\n                        this.pdfViewer.fireCommentStatusChanged(currentAnnotation.comments[parseInt(j.toString(), 10)].annotName, currentAnnotation.comments[parseInt(j.toString(), 10)].note, currentAnnotation, currentAnnotation.comments[parseInt(j.toString(), 10)].state);\n                    }\n                }\n            }\n            if (!isMeasure) {\n                this.updateUndoRedoCollections(currentAnnotation, pageIndex);\n            }\n            else {\n                this.updateUndoRedoCollections(currentAnnotation, pageIndex, 'shape_measure');\n            }\n        }\n    };\n    /**\n     * @param {any} commentsElement - It describes about the comments element\n     * @param {any} replyElement - It describes about the reply element\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.modifyCommentDeleteProperty = function (commentsElement, replyElement) {\n        var commentsParentElement = document.getElementById(commentsElement.id);\n        var annotationData = this.getAnnotationById(commentsElement);\n        if (commentsParentElement && annotationData) {\n            var currentAnnotation = annotationData.annotation, pageIndex = annotationData.pageIndex;\n            var clonedAnnotation = void 0;\n            var clonedObject = void 0;\n            for (var i = 1; i < commentsParentElement.childElementCount; i++) {\n                if (commentsParentElement.childNodes[parseInt(i.toString(), 10)].id === replyElement.id) {\n                    var positionValue = i - 1;\n                    var comment = currentAnnotation.comments[positionValue];\n                    clonedAnnotation = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(currentAnnotation);\n                    clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(comment);\n                    comment.position = i;\n                    this.pdfViewer.fireCommentDelete(comment.annotName, comment.note, currentAnnotation);\n                    currentAnnotation.comments.splice(parseInt(positionValue.toString(), 10), 1);\n                    replyElement.remove();\n                }\n            }\n            this.pdfViewer.annotation.addAction(pageIndex, null, clonedAnnotation, 'Comments Reply Deleted', '', clonedObject, currentAnnotation);\n            this.updateUndoRedoCollections(currentAnnotation, pageIndex);\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateOpacityValue = function (annotation) {\n        var pageAnnotations = this.getAnnotations(annotation.pageIndex, null, annotation.shapeAnnotationType);\n        this.pdfViewer.annotationModule.isFormFieldShape = false;\n        if (pageAnnotations !== null) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (pageAnnotations[parseInt(i.toString(), 10)].annotName === annotation.annotName) {\n                    pageAnnotations[parseInt(i.toString(), 10)].opacity = annotation.opacity;\n                    this.updateUndoRedoCollections(pageAnnotations[parseInt(i.toString(), 10)], annotation.pageIndex);\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {string} isAction - It describes about the isAction\n     * @param {any} undoAnnotation - It describes about the undo annotation\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.undoAction = function (annotation, isAction, undoAnnotation) {\n        if (isAction === 'Text Property Added') {\n            if (annotation) {\n                var commentsMainDiv = document.getElementById(annotation.annotName);\n                if (commentsMainDiv) {\n                    var pageNumber = parseInt(commentsMainDiv.accessKey.split('_')[0], 10);\n                    var pageIndex = pageNumber - 1;\n                    var clonedAnnotationObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(annotation);\n                    commentsMainDiv.firstChild.firstChild.nextSibling.ej2_instances[0].value = undoAnnotation.note;\n                    var value = undoAnnotation.note;\n                    annotation.note = value;\n                    if (commentsMainDiv.childElementCount === 2) {\n                        commentsMainDiv.lastChild.style.display = 'block';\n                    }\n                    this.updateUndoRedoCollections(annotation, pageIndex);\n                    return clonedAnnotationObject;\n                }\n            }\n        }\n        else if (isAction === 'Comments Property Added') {\n            if (annotation.comments.length > 0) {\n                var commentsDiv = document.getElementById(annotation.annotName);\n                var pageIndex = this.pdfViewerBase.currentPageNumber - 1;\n                if (commentsDiv) {\n                    var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n                    pageIndex = pageNumber - 1;\n                }\n                var clonedAnnotationObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(annotation);\n                var comment = annotation.comments[annotation.comments.length - 1];\n                var removeDiv = document.getElementById(comment.annotName);\n                if (removeDiv) {\n                    removeDiv.remove();\n                }\n                annotation = undoAnnotation;\n                this.updateUndoRedoCollections(annotation, pageIndex);\n                return clonedAnnotationObject;\n            }\n        }\n        else if (isAction === 'Status Property Added') {\n            if (annotation) {\n                var commentsDiv = document.getElementById(annotation.annotName);\n                var pageIndex = this.pdfViewerBase.currentPageNumber - 1;\n                if (commentsDiv) {\n                    var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n                    pageIndex = pageNumber - 1;\n                }\n                var clonedAnnotationObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(annotation);\n                if (annotation.annotName === undoAnnotation.annotName) {\n                    annotation.review = undoAnnotation.review;\n                    annotation.state = undoAnnotation.state;\n                    annotation.stateModel = undoAnnotation.stateModel;\n                    this.pdfViewer.annotation.redoCommentsElement.push(annotation);\n                }\n                else {\n                    for (var j = 0; j < annotation.comments.length; j++) {\n                        if (annotation.comments[parseInt(j.toString(), 10)].annotName === undoAnnotation.annotName) {\n                            annotation.comments[parseInt(j.toString(), 10)].state = undoAnnotation.state;\n                            annotation.comments[parseInt(j.toString(), 10)].stateModel = undoAnnotation.stateModel;\n                            annotation.comments[parseInt(j.toString(), 10)].review = undoAnnotation.review;\n                            this.pdfViewer.annotation.redoCommentsElement.push(annotation.comments[parseInt(j.toString(), 10)]);\n                            break;\n                        }\n                    }\n                }\n                var activeDiv = document.getElementById(undoAnnotation.annotName);\n                if (activeDiv.lastChild.id === this.pdfViewer.element.id + 'status' + '_container') {\n                    activeDiv.lastChild.remove();\n                }\n                else {\n                    if (activeDiv.firstChild.lastChild.id === this.pdfViewer.element.id + 'status' + '_container') {\n                        activeDiv.firstChild.lastChild.remove();\n                    }\n                }\n                this.updateUndoRedoCollections(annotation, pageIndex);\n                return clonedAnnotationObject;\n            }\n        }\n        else if (isAction === 'Comments Reply Deleted') {\n            var commentsDiv = document.getElementById(annotation.annotName);\n            if (commentsDiv) {\n                var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n                var pageIndex = pageNumber - 1;\n                this.renderComments(undoAnnotation, commentsDiv, true, annotation.annotName);\n                this.pdfViewer.annotation.redoCommentsElement.push(undoAnnotation);\n                this.updateUndoRedoCollections(annotation, pageIndex);\n                return annotation;\n            }\n        }\n        else if (isAction === 'dynamicText Change') {\n            if (annotation) {\n                var commentsMainDiv = document.getElementById(annotation.annotName);\n                if (commentsMainDiv) {\n                    commentsMainDiv.firstChild.firstChild.nextSibling.ej2_instances[0].value = undoAnnotation.dynamicText;\n                    return annotation;\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {string} isAction - It describes about the isAction\n     * @param {any} undoAnnotation - It describes about the undo annotation\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.redoAction = function (annotation, isAction, undoAnnotation) {\n        if (isAction === 'Text Property Added') {\n            var commentsMainDiv = document.getElementById(annotation.annotName);\n            if (commentsMainDiv) {\n                var pageNumber = parseInt(commentsMainDiv.accessKey.split('_')[0], 10);\n                var pageIndex = pageNumber - 1;\n                commentsMainDiv.firstChild.firstChild.nextSibling.ej2_instances[0].value = annotation.note;\n                commentsMainDiv.lastChild.style.display = 'block';\n                this.updateUndoRedoCollections(annotation, pageIndex);\n                return annotation;\n            }\n        }\n        else if (isAction === 'Comments Property Added') {\n            var comment = annotation.comments[annotation.comments.length - 1];\n            var commentsDiv = document.getElementById(annotation.annotName);\n            if (commentsDiv) {\n                var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n                var pageIndex = pageNumber - 1;\n                this.renderComments(comment, commentsDiv, true, annotation.annotName);\n                this.updateUndoRedoCollections(annotation, pageIndex);\n                return annotation;\n            }\n        }\n        else if (isAction === 'Status Property Added') {\n            var poppedItem = this.pdfViewer.annotation.redoCommentsElement.pop();\n            var pageIndex = this.pdfViewerBase.currentPageNumber - 1;\n            if (poppedItem) {\n                var statusContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_container', className: 'e-pv-status-container' });\n                var statusDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + 'status' + '_div', className: 'e-pv-status-div' });\n                var statusSpan = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: this.pdfViewer.element.id + 'status' + '_icon' });\n                statusDiv.appendChild(statusSpan);\n                statusContainer.appendChild(statusDiv);\n                var activeDiv = document.getElementById(annotation.annotName);\n                if (activeDiv) {\n                    var pageNumber = parseInt(activeDiv.accessKey.split('_')[0], 10);\n                    pageIndex = pageNumber - 1;\n                }\n                if (annotation.annotName === poppedItem.annotName) {\n                    this.updateStatusContainer(annotation.state, statusSpan, statusDiv, statusContainer);\n                    for (var i = 0; i < activeDiv.firstChild.children.length; i++) {\n                        if (activeDiv.firstChild.children[parseInt(i.toString(), 10)].id === this.pdfViewer.element.id + 'status_container') {\n                            activeDiv.firstChild.children[parseInt(i.toString(), 10)].parentElement.\n                                removeChild(activeDiv.firstChild.children[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                    activeDiv.firstChild.appendChild(statusContainer);\n                }\n                else {\n                    for (var i = 0; i < annotation.comments.length; i++) {\n                        if (annotation.comments[parseInt(i.toString(), 10)].annotName === poppedItem.annotName) {\n                            this.updateStatusContainer(annotation.comments[parseInt(i.toString(), 10)].state, statusSpan, statusDiv, statusContainer);\n                            var statusElement = document.getElementById(poppedItem.annotName);\n                            for (var i_1 = 0; i_1 < statusElement.children.length; i_1++) {\n                                if (statusElement.children[parseInt(i_1.toString(), 10)].id === this.pdfViewer.element.id + 'status_container') {\n                                    statusElement.children[parseInt(i_1.toString(), 10)].\n                                        parentElement.removeChild(statusElement.children[parseInt(i_1.toString(), 10)]);\n                                }\n                            }\n                            if (statusElement) {\n                                statusElement.appendChild(statusContainer);\n                            }\n                        }\n                    }\n                }\n            }\n            this.updateUndoRedoCollections(annotation, pageIndex);\n            return annotation;\n        }\n        else if (isAction === 'Comments Reply Deleted') {\n            var pageIndex = this.pdfViewerBase.currentPageNumber - 1;\n            var activeDiv = document.getElementById(annotation.annotName);\n            if (activeDiv) {\n                var pageNumber = parseInt(activeDiv.accessKey.split('_')[0], 10);\n                pageIndex = pageNumber - 1;\n            }\n            var poppedItem = this.pdfViewer.annotation.redoCommentsElement.pop();\n            var clonedAnnotationObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(annotation);\n            for (var i = 0; i < annotation.comments.length; i++) {\n                if (annotation.comments[parseInt(i.toString(), 10)].annotName === poppedItem.annotName) {\n                    var replyElement = document.getElementById(poppedItem.annotName);\n                    annotation.comments.splice(i, 1);\n                    replyElement.remove();\n                }\n            }\n            this.updateUndoRedoCollections(annotation, pageIndex);\n            return clonedAnnotationObject;\n        }\n        else if (isAction === 'dynamicText Change') {\n            if (annotation) {\n                var commentsMainDiv = document.getElementById(annotation.annotName);\n                if (commentsMainDiv) {\n                    commentsMainDiv.firstChild.firstChild.nextSibling.ej2_instances[0].value = annotation.dynamicText;\n                    return annotation;\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.updateUndoRedoCollections = function (annotationBase, pageNumber, shapeType, action) {\n        var annotationType = (!shapeType) ? annotationBase.shapeAnnotationType : shapeType;\n        if (annotationBase.indent && annotationBase.indent !== '') {\n            annotationType = 'shape_measure';\n        }\n        var pageAnnotations = this.getAnnotations(pageNumber, null, annotationType);\n        if (pageAnnotations !== null) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (annotationBase.annotName === pageAnnotations[parseInt(i.toString(), 10)].annotName) {\n                    pageAnnotations[parseInt(i.toString(), 10)] = annotationBase;\n                    this.pdfViewer.annotationModule.storeAnnotationCollections(pageAnnotations[parseInt(i.toString(), 10)], pageNumber);\n                    if (action) {\n                        pageAnnotations.splice(i, 1);\n                        this.deleteStickyNotesAnnotations(pageAnnotations, pageNumber);\n                    }\n                }\n            }\n            if (annotationType === 'shape_measure') {\n                this.manageAnnotations(pageAnnotations, pageNumber, 'shape_measure');\n            }\n            else {\n                this.manageAnnotations(pageAnnotations, pageNumber, annotationBase.shapeAnnotationType);\n            }\n        }\n    };\n    /**\n     * @param {any} pageIndex - It describes about the page index\n     * @param {string} type - It describes about the type\n     * @param {boolean} action - It describes about the action\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.addAnnotationComments = function (pageIndex, type, action) {\n        var pageNumber = pageIndex + 1;\n        var poppedItem;\n        if (!action) {\n            poppedItem = this.pdfViewer.annotation.redoCommentsElement.pop();\n        }\n        else if (action) {\n            poppedItem = this.pdfViewer.annotation.undoCommentsElement.pop();\n        }\n        if (poppedItem) {\n            this.createCommentsContainer(poppedItem, pageNumber);\n            this.updateUndoRedoCollections(poppedItem, pageIndex, type);\n            this.pdfViewer.annotationModule.storeAnnotationCollections(poppedItem, pageNumber - 1);\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {string} type - It describes about the type\n     * @param {string} action - It describes about the action\n     * @param {boolean} isUndoAction - Ensures whether undo action is true or not\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.findPosition = function (annotation, type, action, isUndoAction) {\n        var index;\n        var commentsDiv = document.getElementById(annotation.annotName);\n        if (commentsDiv) {\n            var pageNumber = parseInt(commentsDiv.accessKey.split('_')[0], 10);\n            var pageIndex = pageNumber - 1;\n            var parentDiv = commentsDiv.parentElement;\n            for (var i = 0; i < parentDiv.childElementCount; i++) {\n                if (parentDiv.childNodes[parseInt(i.toString(), 10)].id === annotation.annotName) {\n                    index = i;\n                }\n            }\n            if (type === 'Stamp' || type === 'Image') {\n                type = 'stamp';\n            }\n            else if (type === 'FreeText') {\n                type = 'freetext';\n            }\n            else if (type === 'StickyNotes' || type === 'sticky') {\n                type = 'sticky';\n            }\n            else if (type === 'Ink') {\n                type = 'ink';\n            }\n            var pageAnnotations = this.getAnnotations(pageIndex, null, type);\n            if (pageAnnotations !== null) {\n                for (var i = 0; i < pageAnnotations.length; i++) {\n                    if (pageAnnotations[parseInt(i.toString(), 10)].annotName === annotation.annotName) {\n                        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(pageAnnotations[parseInt(i.toString(), 10)]);\n                        pageAnnotations[parseInt(i.toString(), 10)].position = index;\n                        if (!isUndoAction) {\n                            this.pdfViewer.annotation.undoCommentsElement.push(pageAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                        else {\n                            this.pdfViewer.annotation.redoCommentsElement.push(pageAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                        if (type === 'sticky') {\n                            this.updateUndoRedoCollections(clonedObject, pageIndex, null, action);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.getAnnotations = function (pageIndex, shapeAnnotations, type) {\n        var annotationCollection;\n        if (type === 'Stamp' || type === 'stamp' || type === 'Image') {\n            type = 'stamp';\n        }\n        else if (type === 'StickyNotes' || type === 'sticky') {\n            type = 'sticky';\n        }\n        else if (type === 'textMarkup') {\n            type = 'textMarkup';\n        }\n        else if (type === 'shape' || type === 'Line' || type === 'Radius' || type === 'Rectangle' || type === 'Ellipse'\n            || type === 'Polygon' || type === 'LineWidthArrowHead' || type === 'Square' || type === 'Circle') {\n            type = 'shape';\n        }\n        else if (type === 'FreeText' || type === 'freetext' || type === 'freeText') {\n            type = 'freetext';\n        }\n        else if (type === 'ink' || type === 'Ink') {\n            type = 'ink';\n        }\n        else {\n            type = 'shape_measure';\n        }\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_' + type);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_' + type];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageIndex);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotationCollection = annotObject[parseInt(index.toString(), 10)].annotations;\n            }\n            else {\n                annotationCollection = shapeAnnotations;\n            }\n        }\n        else {\n            annotationCollection = shapeAnnotations;\n        }\n        return annotationCollection;\n    };\n    StickyNotesAnnotation.prototype.manageAnnotations = function (pageAnnotations, pageNumber, type) {\n        if (type === 'Stamp' || type === 'stamp') {\n            type = 'stamp';\n        }\n        else if (type === 'Sticky' || type === 'sticky') {\n            type = 'sticky';\n        }\n        else if (type === 'textMarkup') {\n            type = 'textMarkup';\n        }\n        else if (type === 'shape' || type === 'Line' || type === 'Radius' || type === 'Rectangle' || type === 'Ellipse'\n            || type === 'Polygon' || type === 'LineWidthArrowHead' || type === 'Square' || type === 'Circle') {\n            type = 'shape';\n        }\n        else if (type === 'FreeText') {\n            type = 'freetext';\n        }\n        else if (type === 'ink' || type === 'Ink') {\n            type = 'ink';\n        }\n        else {\n            type = 'shape_measure';\n        }\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_' + type);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_' + type];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            if (!this.pdfViewerBase.isStorageExceed) {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_' + type);\n            }\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotObject[parseInt(index.toString(), 10)].annotations = pageAnnotations;\n            }\n            var annotationStringified = JSON.stringify(annotObject);\n            if (this.pdfViewerBase.isStorageExceed) {\n                this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_' + type] = annotationStringified;\n            }\n            else {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_' + type, annotationStringified);\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.updateStickyNotes = function (annotation, id) {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_sticky'];\n        }\n        if (storeObject) {\n            var bounds = annotation.bounds;\n            var annotObject = JSON.parse(storeObject);\n            for (var k = 0; k < annotObject.length; k++) {\n                var currentAnnot = annotObject[parseInt(k.toString(), 10)];\n                for (var j = 0; j < currentAnnot.annotations.length; j++) {\n                    if (annotObject[parseInt(k.toString(), 10)].annotations[parseInt(j.toString(), 10)].annotName ===\n                        annotation.annotName) {\n                        if (!this.pdfViewerBase.isStorageExceed) {\n                            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n                        }\n                        var pageIndex = this.pdfViewer.annotationModule.getPageCollection(annotObject, 0);\n                        if (annotObject[parseInt(k.toString(), 10)]) {\n                            annotObject[parseInt(k.toString(), 10)].annotations[parseInt(j.toString(), 10)].bounds =\n                                { left: bounds.x, top: bounds.y, width: bounds.width, height: bounds.height,\n                                    right: bounds.right, bottom: bounds.bottom };\n                        }\n                        var annotationStringified = JSON.stringify(annotObject);\n                        if (this.pdfViewerBase.isStorageExceed) {\n                            this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_sticky'] = annotationStringified;\n                        }\n                        else {\n                            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_sticky', annotationStringified);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.saveStickyAnnotations = function () {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_sticky'];\n        }\n        var annotations = [];\n        for (var j = 0; j < this.pdfViewerBase.pageCount; j++) {\n            annotations[parseInt(j.toString(), 10)] = [];\n        }\n        if (storeObject && !this.pdfViewer.annotationSettings.skipDownload) {\n            var annotationCollection = JSON.parse(storeObject);\n            for (var i = 0; i < annotationCollection.length; i++) {\n                var newArray = [];\n                var pageAnnotationObject = annotationCollection[parseInt(i.toString(), 10)];\n                if (pageAnnotationObject) {\n                    for (var z = 0; pageAnnotationObject.annotations.length > z; z++) {\n                        this.pdfViewer.annotationModule.updateModifiedDate(pageAnnotationObject.annotations[parseInt(z.toString(), 10)]);\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds =\n                            JSON.stringify(this.pdfViewer.annotation.getBounds(pageAnnotationObject.\n                                annotations[parseInt(z.toString(), 10)].bounds, pageAnnotationObject.pageIndex));\n                    }\n                    newArray = pageAnnotationObject.annotations;\n                }\n                annotations[pageAnnotationObject.pageIndex] = newArray;\n            }\n        }\n        return JSON.stringify(annotations);\n    };\n    StickyNotesAnnotation.prototype.deleteStickyNotesAnnotations = function (pageAnnotations, pageNumber) {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_sticky'];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            if (!this.pdfViewerBase.isStorageExceed) {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n            }\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotObject[parseInt(index.toString(), 10)].annotations = pageAnnotations;\n            }\n            var annotationStringified = JSON.stringify(annotObject);\n            if (this.pdfViewerBase.isStorageExceed) {\n                this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_sticky'] = annotationStringified;\n            }\n            else {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_sticky', annotationStringified);\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.addStickyNotesAnnotations = function (pageNumber, annotationBase) {\n        var pageAnnotations = this.getAnnotations(pageNumber, null, 'sticky');\n        if (pageAnnotations) {\n            pageAnnotations.push(annotationBase);\n        }\n        this.manageAnnotations(pageAnnotations, pageNumber, 'sticky');\n    };\n    /**\n     * @param {string} annotName - It describes about the annotName\n     * @param {string} text - It describes about the text\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.addTextToComments = function (annotName, text) {\n        var commentsMainDiv = document.getElementById(annotName);\n        if (commentsMainDiv) {\n            commentsMainDiv.firstChild.firstChild.nextSibling.ej2_instances[0].value = text;\n        }\n    };\n    /**\n     * @param {any} newAnnotation - It describes about the new annotation\n     * @param {any} annotation - It describes about the annotation\n     * @param {boolean} isCut - It describes about the isCut\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateAnnotationCollection = function (newAnnotation, annotation, isCut) {\n        var type = this.findAnnotationType(annotation);\n        var pageAnnotations = this.getAnnotations(annotation.pageIndex, null, type);\n        if (isCut) {\n            pageAnnotations = this.pdfViewer.annotationModule.removedAnnotationCollection;\n        }\n        if (pageAnnotations !== null) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (isCut && !pageAnnotations[parseInt(i.toString(), 10)].annotName) {\n                    pageAnnotations[parseInt(i.toString(), 10)].annotName = pageAnnotations[parseInt(i.toString(), 10)].annotationId;\n                }\n                if (pageAnnotations[parseInt(i.toString(), 10)].annotName === annotation.annotName) {\n                    var updateAnnotation = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(pageAnnotations[parseInt(i.toString(), 10)]);\n                    updateAnnotation.annotName = newAnnotation.annotName;\n                    if (type === 'shape' || type === 'shape_measure' || type === 'freetext' || type === 'ink') {\n                        updateAnnotation.id = newAnnotation.id;\n                    }\n                    if (type === 'stamp') {\n                        updateAnnotation.randomId = newAnnotation.id;\n                    }\n                    if (type === 'ink') {\n                        updateAnnotation.bounds.x = newAnnotation.bounds.x;\n                        updateAnnotation.bounds.y = newAnnotation.bounds.y;\n                    }\n                    else {\n                        updateAnnotation.bounds.left = newAnnotation.bounds.x;\n                        updateAnnotation.bounds.top = newAnnotation.bounds.y;\n                        updateAnnotation.bounds.x = newAnnotation.bounds.x;\n                        updateAnnotation.bounds.y = newAnnotation.bounds.y;\n                        updateAnnotation.vertexPoints = newAnnotation.vertexPoints;\n                    }\n                    updateAnnotation.note = updateAnnotation.note ? updateAnnotation.note : '';\n                    updateAnnotation.comments = [];\n                    updateAnnotation.review = { state: '', stateModel: '', modifiedDate: updateAnnotation.ModifiedDate, author: updateAnnotation.author };\n                    updateAnnotation.state = '';\n                    updateAnnotation.stateModel = '';\n                    updateAnnotation.pageNumber = annotation.pageIndex;\n                    this.pdfViewer.annotationModule.storeAnnotations(annotation.pageIndex, updateAnnotation, '_annotations_' + type);\n                    this.createCommentsContainer(updateAnnotation, annotation.pageIndex + 1, true);\n                    if (isCut) {\n                        this.pdfViewer.annotationModule.removedAnnotationCollection = [];\n                    }\n                    break;\n                }\n            }\n        }\n    };\n    StickyNotesAnnotation.prototype.findAnnotationType = function (annotation) {\n        var annotType;\n        if (annotation.measureType !== '') {\n            annotType = 'shape_measure';\n        }\n        else {\n            if (annotation.shapeAnnotationType === 'StickyNotes') {\n                annotType = 'sticky';\n            }\n            else if (annotation.shapeAnnotationType === 'Stamp' || annotation.shapeAnnotationType === 'Image') {\n                annotType = 'stamp';\n            }\n            else if (annotation.shapeAnnotationType === 'FreeText') {\n                annotType = 'freetext';\n            }\n            else if (annotation.shapeAnnotationType === 'Ink') {\n                annotType = 'ink';\n            }\n            else {\n                annotType = 'shape';\n            }\n        }\n        return annotType;\n    };\n    StickyNotesAnnotation.prototype.setExistingAnnotationModifiedDate = function (date) {\n        var modifiedDateTime;\n        if (date !== '') {\n            modifiedDateTime = this.setModifiedDate(date);\n        }\n        else {\n            modifiedDateTime = this.setModifiedDate();\n        }\n        return modifiedDateTime;\n    };\n    StickyNotesAnnotation.prototype.updateModifiedTime = function (time, minutes) {\n        var modifiedTime;\n        if (time >= 12) {\n            if (time === 12) {\n                modifiedTime = time + ':' + minutes + ' PM';\n            }\n            else {\n                modifiedTime = (time - 12) + ':' + minutes + ' PM';\n            }\n        }\n        else {\n            modifiedTime = time + ':' + minutes + ' AM';\n        }\n        return modifiedTime;\n    };\n    StickyNotesAnnotation.prototype.setModifiedDate = function (data) {\n        var dateTime;\n        if (data) {\n            dateTime = this.getDateAndTimeFormat(data);\n        }\n        else {\n            dateTime = this.getDateAndTimeFormat();\n        }\n        var date = new Date(dateTime);\n        var modifiedTime;\n        var modifiedDate = dateTime.toString().split(' ').splice(0, 4).join(' ');\n        if (date.toLocaleTimeString().split(' ').length === 2) {\n            modifiedTime = date.toLocaleTimeString().split(' ')[0].split(':').splice(0, 2).join(':') + ' ' + date.toLocaleTimeString().split(' ')[1];\n        }\n        else {\n            var time = parseInt(date.toLocaleTimeString().split(':')[0], 10);\n            var minutes = date.toLocaleTimeString().split(':')[1];\n            modifiedTime = this.updateModifiedTime(time, minutes);\n        }\n        var modifiedDateTime = modifiedDate;\n        return modifiedDateTime;\n    };\n    StickyNotesAnnotation.prototype.convertUTCDateToLocalDate = function (date) {\n        this.globalize = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Internationalization();\n        var dateOptions = { format: this.pdfViewer.dateTimeFormat, type: 'dateTime' };\n        var dateTime = this.globalize.formatDate(new Date(date), dateOptions);\n        return dateTime;\n    };\n    StickyNotesAnnotation.prototype.updateModifiedDate = function (titleContainer) {\n        if (titleContainer.id === this.pdfViewer.element.id + '_commenttype_icon') {\n            titleContainer = titleContainer.nextSibling;\n        }\n        var author = titleContainer.textContent.split('-')[0];\n        titleContainer.textContent = author + ' - ' + this.setModifiedDate();\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {boolean} isBounds - It describes about the isBoolean\n     * @param {boolean} isUndoRedoAction - It describes about the isUndoRedoAction\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.updateAnnotationModifiedDate = function (annotation, isBounds, isUndoRedoAction) {\n        var titleContainer;\n        if (annotation) {\n            var commentsContainer = document.getElementById(annotation.annotName);\n            if (commentsContainer) {\n                if (!isBounds) {\n                    titleContainer = commentsContainer.firstChild.firstChild.childNodes[1];\n                    var author = titleContainer.textContent.split('-')[0];\n                    titleContainer.textContent = author + ' - ' + this.setModifiedDate();\n                }\n                else {\n                    var type = this.findAnnotationType(annotation);\n                    var pageAnnotations = this.getAnnotations(annotation.pageIndex, null, type);\n                    if (pageAnnotations !== null && annotation) {\n                        for (var i = 0; i < pageAnnotations.length; i++) {\n                            if (annotation.annotName === pageAnnotations[parseInt(i.toString(), 10)].annotName) {\n                                if (annotation.bounds.x !== pageAnnotations[parseInt(i.toString(), 10)].bounds.left ||\n                                    annotation.bounds.y !== pageAnnotations[parseInt(i.toString(), 10)].bounds.top ||\n                                    annotation.bounds.height !== pageAnnotations[parseInt(i.toString(), 10)].bounds.height ||\n                                    annotation.bounds.width !== pageAnnotations[parseInt(i.toString(), 10)].bounds.width) {\n                                    titleContainer = commentsContainer.firstChild.firstChild.childNodes[1];\n                                    var author = titleContainer.textContent.split('-')[0];\n                                    titleContainer.textContent = author + ' - ' + this.setModifiedDate();\n                                }\n                            }\n                            if (pageAnnotations[parseInt(i.toString(), 10)].shapeAnnotationType === 'sticky') {\n                                this.pdfViewer.annotationModule.\n                                    storeAnnotationCollections(pageAnnotations[parseInt(i.toString(), 10)], annotation.pageIndex);\n                            }\n                        }\n                    }\n                }\n                if (isUndoRedoAction) {\n                    titleContainer = commentsContainer.firstChild.firstChild.childNodes[1];\n                    if (annotation.modifiedDate !== undefined) {\n                        var author = titleContainer.textContent.split('-')[0];\n                        titleContainer.textContent = author + ' - ' + this.setExistingAnnotationModifiedDate(annotation.modifiedDate);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.saveImportedStickyNotesAnnotations = function (annotation, pageNumber) {\n        var annotationObject = null;\n        if (!annotation.Author) {\n            annotation.Author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.stickyNotesSettings.author;\n        }\n        var isLock = this.pdfViewer.stickyNotesSettings.isLock ?\n            this.pdfViewer.stickyNotesSettings.isLock : this.pdfViewer.annotationSettings.isLock;\n        var allowedInteractions = this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        annotationObject = {\n            shapeAnnotationType: 'sticky', author: annotation.Author, allowedInteractions: allowedInteractions, modifiedDate: annotation.ModifiedDate, subject: annotation.Subject, note: annotation.Note, opacity: annotation.Opacity, state: annotation.State, stateModel: annotation.StateModel,\n            pathData: '', comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author), review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate, author: annotation.Author }, pageNumber: pageNumber,\n            bounds: { left: annotation.Bounds.X, top: annotation.Bounds.Y, width: annotation.Bounds.Width,\n                height: annotation.Bounds.Height, right: annotation.Bounds.Right, bottom: annotation.Bounds.Bottom },\n            annotName: annotation.AnnotName, color: annotation.color,\n            annotationSelectorSettings: this.getSettings(annotation),\n            customData: this.pdfViewer.annotation.getCustomData(annotation),\n            annotationSettings: { isLock: isLock }, isPrint: annotation.IsPrint, isCommentLock: annotation.IsCommentLock\n        };\n        this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_sticky');\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.updateStickyNotesAnnotationCollections = function (annotation, pageNumber) {\n        var annotationObject = null;\n        if (!annotation.Author) {\n            annotation.Author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.stickyNotesSettings.author;\n        }\n        var isLock = this.pdfViewer.stickyNotesSettings.isLock ?\n            this.pdfViewer.stickyNotesSettings.isLock : this.pdfViewer.annotationSettings.isLock;\n        var allowedInteractions = annotation.AllowedInteraction ?\n            annotation.AllowedInteraction : this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        if (annotation.IsLock) {\n            isLock = annotation.isLock;\n        }\n        annotationObject = {\n            shapeAnnotationType: 'sticky', author: annotation.Author, allowedInteractions: allowedInteractions, modifiedDate: annotation.ModifiedDate, subject: annotation.Subject, note: annotation.Note, opacity: annotation.Opacity, state: annotation.State, stateModel: annotation.StateModel,\n            pathData: '', comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author), review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate, author: annotation.Author },\n            bounds: { left: annotation.Bounds.X, top: annotation.Bounds.Y, width: annotation.Bounds.Width,\n                height: annotation.Bounds.Height, right: annotation.Bounds.Right, bottom: annotation.Bounds.Bottom },\n            annotationId: annotation.AnnotName, color: annotation.color, pageNumber: pageNumber,\n            customData: this.pdfViewer.annotation.getCustomData(annotation),\n            annotationSettings: { isLock: isLock }, isPrint: annotation.IsPrint, isCommentLock: annotation.IsCommentLock\n        };\n        return annotationObject;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    StickyNotesAnnotation.prototype.clear = function () {\n        this.commentsCount = 0;\n        this.commentsreplyCount = 0;\n        this.isAccordionContainer = true;\n        this.isEditableElement = false;\n        this.isCreateContextMenu = false;\n        this.isPageCommentsRendered = false;\n        this.isCommentsRendered = false;\n        this.isAnnotationRendered = false;\n        if (this.commentMenuObj) {\n            this.commentMenuObj.destroy();\n        }\n        var accordionPages = document.querySelectorAll('.e-pv-accordion-page-container');\n        if (accordionPages) {\n            for (var j = 0; j < accordionPages.length; j++) {\n                accordionPages[parseInt(j.toString(), 10)].remove();\n            }\n        }\n        if (this.commentsRequestHandler) {\n            this.commentsRequestHandler.clear();\n        }\n    };\n    /**\n     * @private\n     * @returns {string} - string\n     */\n    StickyNotesAnnotation.prototype.getModuleName = function () {\n        return 'StickyNotesAnnotation';\n    };\n    /**\n     * This method used to add annotations with using program.\n     *\n     * @param {StickyNotesSettings} annotationObject - It describes type of annotation object\n     * @param {IPoint} offset - It describes about the annotation bounds or location\n     * @returns {object} - object\n     * @private\n     */\n    StickyNotesAnnotation.prototype.updateAddAnnotationDetails = function (annotationObject, offset) {\n        //Creating new object if annotationObject is null\n        if (!annotationObject) {\n            annotationObject = { offset: { x: 1, y: 1 }, pageNumber: 0 };\n            offset = annotationObject.offset;\n        }\n        else if (!annotationObject.offset) {\n            offset = { x: 1, y: 1 };\n        }\n        else {\n            offset = annotationObject.offset;\n        }\n        //Creating the CurrentDate and Annotation name\n        var currentDateString = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n        var annotationName = this.pdfViewer.annotation.createGUID();\n        //Creating annotation settings\n        var annotationSelectorSettings = this.pdfViewer.stickyNotesSettings.annotationSelectorSettings;\n        this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n        var annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.stickyNotesSettings);\n        annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('sticky', annotationSettings.annotationSubType);\n        var allowedInteractions = this.pdfViewer.stickyNotesSettings.allowedInteractions ?\n            this.pdfViewer.stickyNotesSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n        annotationSettings.isLock = annotationObject.isLock ? annotationObject.isLock : annotationSettings.isLock;\n        //Creating Annotation objects with it's proper properties\n        var stickyNotesAnnotation = [];\n        var stickyNotes = {\n            AllowedInteractions: annotationObject.allowedInteractions ? annotationObject.allowedInteractions : allowedInteractions,\n            AnnotName: annotationName,\n            AnnotType: 'sticky',\n            AnnotationFlags: null,\n            AnnotationSelectorSettings: annotationObject.annotationSelectorSettings ?\n                annotationObject.annotationSelectorSettings : annotationSelectorSettings,\n            AnnotationSettings: annotationSettings,\n            Author: annotationObject.author ? annotationObject.author : 'Guest',\n            Bounds: { X: offset.x, Y: offset.y, Width: 30, Height: 30, Left: offset.x, Top: offset.y,\n                Location: { X: offset.x, Y: offset.y }, Size: { Height: 30, IsEmpty: false, Width: 30 } },\n            Color: { IsEmpty: false, B: 51, Blue: 0.2, C: 0, G: 255 },\n            Comments: null,\n            CreatedDate: currentDateString,\n            CustomData: annotationObject.customData ? annotationObject.customData : null,\n            ExistingCustomData: null,\n            Icon: 'Comment',\n            IsCommentLock: false,\n            IsLock: annotationObject.isLock ? annotationObject.isLock : false,\n            IsPrint: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotationObject.isPrint) ? annotationObject.isPrint : true,\n            ModifiedDate: '',\n            Note: '',\n            Opacity: annotationObject.opacity ? annotationObject.opacity : 1,\n            Reference: null,\n            Size: { IsEmpty: true, Width: 0, Height: 0 },\n            State: '',\n            StateModel: '',\n            StrokeColor: null,\n            SubType: null,\n            Subject: annotationObject.subject ? annotationObject.subject : 'Sticky Note',\n            Type: null\n        };\n        //Adding the annotation object to an array and return it\n        stickyNotesAnnotation[0] = stickyNotes;\n        return { stickyNotesAnnotation: stickyNotesAnnotation };\n    };\n    /**\n     * @param {any} type - It describes about the type\n     * @private\n     * @returns {any} - any\n     */\n    StickyNotesAnnotation.prototype.getAnnotationType = function (type) {\n        var annotationType;\n        if (type === 'stamp' || type === 'Stamp') {\n            annotationType = 'stamp';\n        }\n        else if (type === 'shape' || type === 'Line' || type === 'Radius' || type === 'Rectangle' || type === 'Ellipse'\n            || type === 'Polygon' || type === 'LineWidthArrowHead' || type === 'Square' || type === 'Circle') {\n            annotationType = 'shape';\n        }\n        else if (type === 'textMarkup') {\n            annotationType = 'textMarkup';\n        }\n        else if (type === 'freeText' || type === 'FreeText') {\n            annotationType = 'freeText';\n        }\n        else if (type === 'sticky' || type === 'StickyNotes') {\n            annotationType = 'sticky';\n        }\n        else if (type === 'measure' || type === 'shape_measure') {\n            annotationType = 'measure';\n        }\n        else if (type === 'ink' || type === 'Ink') {\n            annotationType = 'ink';\n        }\n        return annotationType;\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {any} commonDiv - It describes about the commonDiv\n     * @private\n     * @returns {string} - string\n     */\n    StickyNotesAnnotation.prototype.getAuthorName = function (annotation, commonDiv) {\n        var author;\n        if (annotation) {\n            var type = annotation.shapeAnnotationType;\n            var annotationType = this.getAnnotationType(type);\n            author = this.pdfViewer.annotationModule.updateAnnotationAuthor(annotationType, type);\n        }\n        else {\n            author = commonDiv.getAttribute('author');\n        }\n        return author;\n    };\n    return StickyNotesAnnotation;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/sticky-notes-annotation.js?");

/***/ })

}]);