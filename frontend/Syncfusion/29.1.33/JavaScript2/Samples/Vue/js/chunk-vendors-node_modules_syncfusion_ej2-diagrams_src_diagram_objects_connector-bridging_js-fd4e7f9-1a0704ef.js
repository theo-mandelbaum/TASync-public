"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_objects_connector-bridging_js-fd4e7f9-1a0704ef"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector-bridging.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector-bridging.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectorBridging: () => (/* binding */ ConnectorBridging)\n/* harmony export */ });\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n\n\n\n\n/**\n * ConnectorBridging defines the bridging behavior\n */\n/** @private */\nvar ConnectorBridging = /** @class */ (function () {\n    /**\n     * Constructor for the bridging module\n     *\n     * @private\n     */\n    function ConnectorBridging() {\n        //constructs the bridging module\n    }\n    /**\n     * @param {Connector}conn - provide the target  value.\n     * @param {Diagram}diagram - provide the target  value.\n     * @private\n     */\n    ConnectorBridging.prototype.updateBridging = function (conn, diagram) {\n        var lastBridge = [];\n        var bounds;\n        conn.bridges = [];\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_3__.canBridge)(conn, diagram)) {\n            // if (this.canBridge(conn, diagram)) {\n            var points1 = this.getPoints(conn);\n            bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds(points1);\n            var bridgeSpacing = conn.bridgeSpace;\n            var bgedir = diagram.bridgeDirection || 'Top';\n            var count = -1;\n            var quads = diagram.connectors;\n            for (var q = 0; q < quads.length; q++) {\n                var connector1 = quads[parseInt(q.toString(), 10)];\n                //EJ2-868564- Bridging is enabled when connector visibility is set to False\n                if (conn && connector1 && conn.id !== connector1.id && connector1.visible) {\n                    var points2 = this.getPoints(connector1);\n                    var bounds1 = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds(points2);\n                    if (this.intersectsRect(bounds, bounds1)) {\n                        var intersectPts = this.intersect(points1, points2, false, bgedir, true);\n                        if (intersectPts.length > 0) {\n                            for (var i = 0; i < intersectPts.length; i++) {\n                                var fullLength = 0;\n                                var length_1 = 0;\n                                var segmentIndex = 0;\n                                var pointIndex = 0;\n                                var obj = this.getLengthAtFractionPoint(conn, intersectPts[parseInt(i.toString(), 10)]);\n                                if (obj.pointIndex !== -1) {\n                                    length_1 = obj.lengthFractionIndex;\n                                    fullLength = obj.fullLength;\n                                    segmentIndex = obj.segmentIndex;\n                                    pointIndex = obj.pointIndex;\n                                    var stBridge = this.getPointAtLength((length_1 - (bridgeSpacing / 2)), points1);\n                                    var enBridge = this.getPointAtLength((length_1 + (bridgeSpacing / 2)), points1);\n                                    var fractLength = (length_1 - (bridgeSpacing / 2)) / fullLength;\n                                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                                    fractLength = (length_1 + (bridgeSpacing / 2)) / fullLength;\n                                    if (this.isEmptyPoint(enBridge)) {\n                                        enBridge = stBridge;\n                                    }\n                                    var end = void 0;\n                                    var start = conn.sourcePoint;\n                                    if (conn.type === 'Straight') {\n                                        end = conn.targetPoint;\n                                    }\n                                    else {\n                                        end = conn.intermediatePoints[parseInt(pointIndex.toString(), 10)];\n                                    }\n                                    var angle = this.angleCalculation(start, end);\n                                    if (lastBridge.length) {\n                                        var fixedPoint = conn.sourcePoint;\n                                        var fix = Math.abs(this.lengthCalculation(fixedPoint, enBridge));\n                                        var var1 = 0;\n                                        var insertAt = -1;\n                                        count = -1;\n                                        for (var k = 0; k < lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.length; k++) {\n                                            count++;\n                                            var arcSeg = lastBridge[parseInt(segmentIndex.toString(), 10)].bridges[parseInt(k.toString(), 10)];\n                                            var1 = Math.abs(this.lengthCalculation(fixedPoint, arcSeg.endPoint));\n                                            if (fix < var1) {\n                                                insertAt = count;\n                                                break;\n                                            }\n                                        }\n                                        if (insertAt >= 0) {\n                                            //let paths: ArcSegment;\n                                            // eslint-disable-next-line max-len\n                                            var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                                            paths.target = connector1.id;\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.splice(insertAt, 0, paths);\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.join();\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint.splice(insertAt, 0, stBridge);\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint.join();\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].segmentIndex = segmentIndex;\n                                        }\n                                        else {\n                                            //let paths: ArcSegment;\n                                            // eslint-disable-next-line max-len\n                                            var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                                            paths.target = connector1.id;\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.push(paths);\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint.push(stBridge);\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].segmentIndex = segmentIndex;\n                                        }\n                                    }\n                                    else {\n                                        if (!isNaN(stBridge.x) && !isNaN(stBridge.y) && !this.isEmptyPoint(enBridge)) {\n                                            //let arcs: ArcSegment;\n                                            var bges = [];\n                                            var bgept = [];\n                                            // eslint-disable-next-line max-len\n                                            var arcs = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                                            var bgseg = {\n                                                bridges: bges, bridgeStartPoint: bgept, segmentIndex: segmentIndex\n                                            };\n                                            arcs.target = connector1.id;\n                                            var stPoints = [];\n                                            var edPoints = [];\n                                            stPoints.push(stBridge);\n                                            edPoints.push(enBridge);\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)] = bgseg;\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.push(arcs);\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint = stPoints;\n                                            lastBridge[parseInt(segmentIndex.toString(), 10)].segmentIndex = segmentIndex;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (lastBridge.length !== 0) {\n                this.firstBridge(lastBridge, conn, bridgeSpacing);\n            }\n        }\n    };\n    /**\n     * @param {BridgeSegment[]}bridgeList - provide the bridgeList  value.\n     * @param {Connector}connector - provide the connector  value.\n     * @param {number}bridgeSpacing - provide the bridgeSpacing  value.\n     * @private\n     */\n    ConnectorBridging.prototype.firstBridge = function (bridgeList, connector, bridgeSpacing) {\n        for (var i = 0; i < bridgeList.length; i++) {\n            var bridge = bridgeList[parseInt(i.toString(), 10)];\n            for (var k = 1; k < bridge.bridges.length; k++) {\n                if (_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(bridge.bridges[parseInt(k.toString(), 10)].endPoint, bridge.bridges[k - 1].endPoint) < bridgeSpacing) {\n                    bridge.bridges[k - 1].endPoint = bridge.bridges[parseInt(k.toString(), 10)].endPoint;\n                    var subBridge = bridge.bridges[k - 1];\n                    var arc = this.createBridgeSegment(subBridge.startPoint, subBridge.endPoint, subBridge.angle, bridgeSpacing, subBridge.sweep);\n                    bridge.bridges[k - 1].path = arc;\n                    bridge.bridges.splice(k, 1);\n                    bridge.bridgeStartPoint.splice(k, 1);\n                    k--;\n                }\n            }\n            var pre = connector.sourcePoint;\n            for (var j = 0; j < bridge.bridges.length; j++) {\n                var subBridge = bridge.bridges[parseInt(j.toString(), 10)]; //const preventChecking: boolean = true;\n                pre = subBridge.endPoint;\n                connector.bridges.push(subBridge);\n            }\n        }\n    };\n    /**\n     * @returns { ArcSegment } checkSourcePointInTarget method .\\\n     * @param {PointModel}st- provide the st  value.\n     * @param {PointModel}end- provide the end  value.\n     * @param {number}angle- provide the angle  value.\n     * @param {BridgeDirection}direction- provide the direction  value.\n     * @param {number}index- provide the index  value.\n     * @param {Connector}conn- provide the conn  value.\n     * @param {Diagram} diagram- provide the diagram  value.\n     * @private\n     */\n    ConnectorBridging.prototype.createSegment = function (st, end, angle, direction, index, conn, diagram) {\n        //let arc: string;\n        //let sweep: number;\n        var path = {\n            angle: 0, endPoint: { x: 0, y: 0 }, target: '', path: '',\n            segmentPointIndex: -1, startPoint: { x: 0, y: 0 }, sweep: 1, rendered: false\n        };\n        var sweep = this.sweepDirection(angle, direction, conn, diagram);\n        var arc = this.createBridgeSegment(st, end, angle, conn.bridgeSpace, sweep);\n        path.path = arc;\n        path.startPoint = st;\n        path.endPoint = end;\n        path.angle = angle;\n        path.segmentPointIndex = index;\n        path.sweep = sweep;\n        return path;\n    };\n    /**\n     * @param {PointModel}startPt- provide the startPt  value.\n     * @param {PointModel}endPt- provide the endPt  value.\n     * @param {number}angle- provide the angle  value.\n     * @param {number}bridgeSpace- provide the bridgeSpace  value.\n     * @param {number}sweep- provide the sweep  value.\n     * @private\n     */\n    ConnectorBridging.prototype.createBridgeSegment = function (startPt, endPt, angle, bridgeSpace, sweep) {\n        var path = 'A ' + bridgeSpace / 2 + ' ' + bridgeSpace / 2 + ' ' + angle + ' , 1 ' + sweep + ' ' + endPt.x + ',' + endPt.y;\n        return path;\n    };\n    /**\n     * @param {number}angle- provide the source value.\n     * @param {BridgeDirection}bridgeDirection- provide the source value.\n     * @param {Connector}connector- provide the source value.\n     * @param {Diagram}diagram- provide the source value.\n     * @private\n     */\n    ConnectorBridging.prototype.sweepDirection = function (angle, bridgeDirection, connector, diagram) {\n        var angle1 = Math.abs(angle);\n        var sweep;\n        switch (bridgeDirection) {\n            case 'Top':\n            case 'Bottom':\n                sweep = 1;\n                if (angle1 >= 0 && angle1 <= 90) {\n                    sweep = 0;\n                }\n                break;\n            case 'Left':\n            case 'Right':\n                sweep = 1;\n                if (angle < 0 && angle >= -180) {\n                    sweep = 0;\n                }\n                break;\n        }\n        if (bridgeDirection === 'Right' || bridgeDirection === 'Bottom') {\n            if (sweep === 0) {\n                sweep = 1;\n            }\n            else {\n                sweep = 0;\n            }\n        }\n        return sweep;\n    };\n    /** @private */\n    ConnectorBridging.prototype.getPointAtLength = function (length, pts) {\n        var run = 0;\n        var pre;\n        var found = { x: 0, y: 0 };\n        for (var i = 0; i < pts.length; i++) {\n            var pt = pts[parseInt(i.toString(), 10)];\n            if (!pre) {\n                pre = pt;\n                continue;\n            }\n            else {\n                var l = this.lengthCalculation(pre, pt);\n                if (run + l > length) {\n                    var r = length - run;\n                    var deg = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(pre, pt);\n                    var x = r * Math.cos(deg * Math.PI / 180);\n                    var y = r * Math.sin(deg * Math.PI / 180);\n                    found = { x: pre.x + x, y: pre.y + y };\n                    break;\n                }\n                else {\n                    run += l;\n                }\n            }\n            pre = pt;\n        }\n        return found;\n    };\n    /**\n     * @param {PointModel[]}connector- provide the source value.\n     * @private\n     */\n    ConnectorBridging.prototype.getPoints = function (connector) {\n        var points = [];\n        if (connector.intermediatePoints && (connector.type === 'Straight' || connector.type === 'Orthogonal')) {\n            for (var j = 0; j < connector.intermediatePoints.length; j++) {\n                points.push(connector.intermediatePoints[parseInt(j.toString(), 10)]);\n            }\n        }\n        return points;\n    };\n    ConnectorBridging.prototype.intersectsRect = function (rect1, rect2) {\n        return ((((rect2.x < (rect1.x + rect1.width)) && (rect1.x < (rect2.x + rect2.width)))\n            && (rect2.y < (rect1.y + rect1.height))) && (rect1.y < (rect2.y + rect2.height)));\n    };\n    /**\n     * @param {PointModel[]}points1- provide the source value.\n     * @param {PointModel[]}points2- provide the source value.\n     * @param {boolean}self- provide the source value.\n     * @param {BridgeDirection}bridgeDirection- provide the source value.\n     * @param {PointModel[]}zOrder- provide the source value.\n     * @private\n     */\n    ConnectorBridging.prototype.intersect = function (points1, points2, self, bridgeDirection, zOrder) {\n        if (self && points2.length >= 2) {\n            points2.splice(0, 1);\n            points2.splice(0, 1);\n        }\n        var points = [];\n        for (var i = 0; i < points1.length - 1; i++) {\n            var pt = this.inter1(points1[parseInt(i.toString(), 10)], points1[i + 1], points2, zOrder, bridgeDirection);\n            if (pt.length > 0) {\n                for (var k = 0; k < pt.length; k++) {\n                    points.push(pt[parseInt(k.toString(), 10)]);\n                }\n            }\n            if (self && points2.length >= 1) {\n                points2.splice(0, 1);\n            }\n        }\n        return points;\n    };\n    /**\n     * @param {PointModel}startPt- provide the target  value.\n     * @param {PointModel}endPt- provide the target  value.\n     * @param {PointModel[]}pts- provide the target  value.\n     * @param {boolean}zOrder- provide the target  value.\n     * @param {BridgeDirection}bridgeDirection- provide the target  value.\n     * @private\n     */\n    ConnectorBridging.prototype.inter1 = function (startPt, endPt, pts, zOrder, bridgeDirection) {\n        var points1 = [];\n        for (var i = 0; i < pts.length - 1; i++) {\n            var point = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.intersect2)(startPt, endPt, pts[parseInt(i.toString(), 10)], pts[i + 1]);\n            if (!this.isEmptyPoint(point)) {\n                var angle = this.angleCalculation(startPt, endPt);\n                var angle1 = this.angleCalculation(pts[parseInt(i.toString(), 10)], pts[i + 1]);\n                angle = this.checkForHorizontalLine(angle);\n                angle1 = this.checkForHorizontalLine(angle1);\n                switch (bridgeDirection) {\n                    case 'Left':\n                    case 'Right':\n                        if (angle > angle1) {\n                            points1.push(point);\n                        }\n                        break;\n                    case 'Top':\n                    case 'Bottom':\n                        if (angle < angle1) {\n                            points1.push(point);\n                        }\n                        break;\n                }\n                if (angle === angle1 && zOrder) {\n                    points1.push(point);\n                }\n            }\n        }\n        return points1;\n    };\n    ConnectorBridging.prototype.checkForHorizontalLine = function (angle) {\n        var temp = 0;\n        var roundedAngle = Math.abs(angle);\n        if (roundedAngle > 90) {\n            temp = 180 - roundedAngle;\n        }\n        else {\n            temp = roundedAngle;\n        }\n        return temp;\n    };\n    ConnectorBridging.prototype.isEmptyPoint = function (point) {\n        return point.x === 0 && point.y === 0;\n    };\n    ConnectorBridging.prototype.getLengthAtFractionPoint = function (connector, pointAt) {\n        var confirm = 100;\n        var pointIndex = -1;\n        var fullLength = 0;\n        var segmentIndex = -1;\n        var count = 0;\n        var lengthAtFractionPt = 0;\n        var pt1 = connector.sourcePoint;\n        var previouspt2 = pt1;\n        var points = [];\n        for (var i = 0; i < connector.intermediatePoints.length; i++) {\n            var point2 = connector.intermediatePoints[parseInt(i.toString(), 10)];\n            points.push(point2);\n        }\n        for (var j = 0; j < points.length; j++) {\n            var pt2 = points[parseInt(j.toString(), 10)];\n            var suspect = this.getSlope(pt2, pt1, pointAt, connector);\n            if (suspect < confirm) {\n                confirm = suspect;\n                lengthAtFractionPt = fullLength + this.lengthCalculation(pointAt, previouspt2);\n                segmentIndex = count;\n                pointIndex = j;\n            }\n            fullLength += _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(pt2, pt1);\n            pt1 = pt2;\n            previouspt2 = pt2;\n        }\n        count++;\n        var lengthFraction = {\n            lengthFractionIndex: lengthAtFractionPt, fullLength: fullLength,\n            segmentIndex: segmentIndex, pointIndex: pointIndex\n        };\n        return lengthFraction;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConnectorBridging.prototype.getSlope = function (startPt, endPt, point, connector) {\n        var three = 3.0;\n        var delX = Math.abs(startPt.x - endPt.x);\n        var delY = Math.abs(startPt.y - endPt.y);\n        var lhs = ((point.y - startPt.y) / (endPt.y - startPt.y));\n        var rhs = ((point.x - startPt.x) / (endPt.x - startPt.x));\n        if (!isFinite(lhs) || !isFinite(rhs) || isNaN(lhs) || isNaN(rhs)) {\n            if (startPt.x === endPt.x) {\n                if (startPt.y === endPt.y) {\n                    return 10000;\n                }\n                else if (((startPt.y > point.y) && (point.y > endPt.y)) || ((startPt.y < point.y) && (point.y < endPt.y))) {\n                    return Math.abs(startPt.x - point.x);\n                }\n            }\n            else if (startPt.y === endPt.y) {\n                if (((startPt.x > point.x) && (point.x > endPt.x)) || ((startPt.x < point.x) && (point.x < endPt.x))) {\n                    return Math.abs(startPt.y - point.y);\n                }\n            }\n        }\n        else {\n            if ((startPt.x >= point.x && point.x >= endPt.x) || (startPt.x <= point.x && point.x <= endPt.x) || delX < three) {\n                if ((startPt.y >= point.y && point.y >= endPt.y) || (startPt.y <= point.y && point.y <= endPt.y) || delY < three) {\n                    return Math.abs(lhs - rhs);\n                }\n            }\n        }\n        return 10000;\n    };\n    /**\n     * @param {PointModel}startPt- provide the target  value.\n     * @param {PointModel}endPt- provide the target  value.\n     * @private\n     */\n    ConnectorBridging.prototype.angleCalculation = function (startPt, endPt) {\n        var xDiff = startPt.x - endPt.x;\n        var yDiff = startPt.y - endPt.y;\n        return Math.atan2(yDiff, xDiff) * (180 / Math.PI);\n    };\n    ConnectorBridging.prototype.lengthCalculation = function (startPt, endPt) {\n        //removed a try catch from here\n        var len = Math.sqrt(((startPt.x - endPt.x) * (startPt.x - endPt.x)) + ((startPt.y - endPt.y) * (startPt.y - endPt.y)));\n        return len;\n    };\n    /**\n     *To destroy the ruler\n     *\n     * @returns {void} To destroy the ruler\n     */\n    ConnectorBridging.prototype.destroy = function () {\n        /**\n         * Destroys the bridging module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    ConnectorBridging.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Bridging';\n    };\n    return ConnectorBridging;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector-bridging.js?");

/***/ })

}]);