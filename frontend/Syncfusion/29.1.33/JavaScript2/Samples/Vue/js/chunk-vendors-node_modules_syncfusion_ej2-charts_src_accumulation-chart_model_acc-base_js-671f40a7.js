"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_accumulation-chart_model_acc-base_js-671f40a7"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/model/acc-base.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/model/acc-base.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccPoints: () => (/* binding */ AccPoints),\n/* harmony export */   AccumulationAnnotationSettings: () => (/* binding */ AccumulationAnnotationSettings),\n/* harmony export */   AccumulationDataLabelSettings: () => (/* binding */ AccumulationDataLabelSettings),\n/* harmony export */   AccumulationSeries: () => (/* binding */ AccumulationSeries),\n/* harmony export */   PieCenter: () => (/* binding */ PieCenter),\n/* harmony export */   getSeriesFromIndex: () => (/* binding */ getSeriesFromIndex),\n/* harmony export */   pointByIndex: () => (/* binding */ pointByIndex)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _common_model_theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/model/theme */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/theme.js\");\n/* harmony import */ var _common_user_interaction_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/user-interaction/selection */ \"./node_modules/@syncfusion/ej2-charts/src/common/user-interaction/selection.js\");\n/* harmony import */ var _common_legend_legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/legend/legend */ \"./node_modules/@syncfusion/ej2-charts/src/common/legend/legend.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * AccumulationChart base file\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Configures the annotation settings for an accumulation chart.\n * Annotations are used to highlight or provide additional information about specific points or regions in the accumulation chart.\n */\nvar AccumulationAnnotationSettings = /** @class */ (function (_super) {\n    __extends(AccumulationAnnotationSettings, _super);\n    function AccumulationAnnotationSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationAnnotationSettings.prototype, \"content\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], AccumulationAnnotationSettings.prototype, \"x\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], AccumulationAnnotationSettings.prototype, \"y\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Pixel')\n    ], AccumulationAnnotationSettings.prototype, \"coordinateUnits\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Chart')\n    ], AccumulationAnnotationSettings.prototype, \"region\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Middle')\n    ], AccumulationAnnotationSettings.prototype, \"verticalAlignment\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Center')\n    ], AccumulationAnnotationSettings.prototype, \"horizontalAlignment\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationAnnotationSettings.prototype, \"description\", void 0);\n    return AccumulationAnnotationSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * This class provides options to customize the appearance and behavior of data labels within a series.\n */\nvar AccumulationDataLabelSettings = /** @class */ (function (_super) {\n    __extends(AccumulationDataLabelSettings, _super);\n    function AccumulationDataLabelSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], AccumulationDataLabelSettings.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], AccumulationDataLabelSettings.prototype, \"showZero\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationDataLabelSettings.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('transparent')\n    ], AccumulationDataLabelSettings.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Inside')\n    ], AccumulationDataLabelSettings.prototype, \"position\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(5)\n    ], AccumulationDataLabelSettings.prototype, \"rx\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(5)\n    ], AccumulationDataLabelSettings.prototype, \"ry\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], AccumulationDataLabelSettings.prototype, \"angle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], AccumulationDataLabelSettings.prototype, \"enableRotation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ width: null, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.Border)\n    ], AccumulationDataLabelSettings.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ fontFamily: null, size: null, fontStyle: null, fontWeight: null, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.Font)\n    ], AccumulationDataLabelSettings.prototype, \"font\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.Connector)\n    ], AccumulationDataLabelSettings.prototype, \"connectorStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationDataLabelSettings.prototype, \"template\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationDataLabelSettings.prototype, \"format\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationDataLabelSettings.prototype, \"maxWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Ellipsis')\n    ], AccumulationDataLabelSettings.prototype, \"textOverflow\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Normal')\n    ], AccumulationDataLabelSettings.prototype, \"textWrap\", void 0);\n    return AccumulationDataLabelSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `PieCenter` class provides options to set the center position for the Pie series in a chart.\n */\nvar PieCenter = /** @class */ (function (_super) {\n    __extends(PieCenter, _super);\n    function PieCenter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('50%')\n    ], PieCenter.prototype, \"x\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('50%')\n    ], PieCenter.prototype, \"y\", void 0);\n    return PieCenter;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `AccPoints` class is used to define and manage the data points within a series of accumulation charts.\n *\n * @public\n */\nvar AccPoints = /** @class */ (function () {\n    function AccPoints() {\n        /** Accumulation point visibility. */\n        this.visible = true;\n        /** Accumulation point symbol location. */\n        this.symbolLocation = null;\n        /** @private */\n        this.region = null;\n        /** @private */\n        this.labelRegion = null;\n        /** @private */\n        this.labelVisible = true;\n        this.regions = null;\n        /** @private */\n        this.isExplode = false;\n        /** @private */\n        this.isClubbed = false;\n        /** @private */\n        this.isSliced = false;\n        /** @private  */\n        this.argsData = null;\n        /** @private */\n        this.isLabelUpdated = null;\n        /** @private */\n        this.initialLabelRegion = null;\n    }\n    return AccPoints;\n}());\n\n/**\n * Configures the series in the accumulation chart.\n */\nvar AccumulationSeries = /** @class */ (function (_super) {\n    __extends(AccumulationSeries, _super);\n    function AccumulationSeries() {\n        /**\n         * Specifies the data source for the series. It can be an array of JSON objects, or an instance of DataManager.\n         * ```html\n         * <div id='Pie'></div>\n         * ```\n         * ```typescript\n         * let dataManager: DataManager = new DataManager({\n         *    url: 'https://services.syncfusion.com/js/production/api/orders'\n         * });\n         * let query: Query = new Query().take(5);\n         * let pie: AccumulationChart = new AccumulationChart({\n         * ...\n         *     series: [{\n         *        dataSource: dataManager,\n         *        xName: 'CustomerID',\n         *        yName: 'Freight',\n         *        query: query\n         *    }],\n         * ...\n         * });\n         * pie.appendTo('#Pie');\n         * ```\n         *\n         * @default ''\n         */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** @private */\n        _this.points = [];\n        /** @private */\n        _this.clubbedPoints = [];\n        /** @private */\n        _this.sumOfPoints = 0;\n        /** @private */\n        _this.isRectSeries = true;\n        /** @private */\n        _this.clipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(0, 0, 0, 0);\n        /** @private */\n        _this.category = 'Series';\n        /** @private */\n        _this.rightSidePoints = [];\n        /** @private */\n        _this.leftSidePoints = [];\n        return _this;\n    }\n    /**\n     * To refresh the Datamanager for series.\n     *\n     * @private\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @param {boolean} render - Specifies whether to render the accumulation chart after refreshing the DataManager.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.refreshDataManager = function (accumulation, render) {\n        var _this = this;\n        this.accumulation = accumulation;\n        this.radius = this.radius ? this.radius : (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice && this.dataLabel.position === 'Outside') ? '40%' : '80%';\n        var dateSource = this.dataSource || accumulation.dataSource;\n        if (!(dateSource instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__.DataManager) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.query)) {\n            this.dataManagerSuccess({ result: dateSource, count: dateSource.length }, accumulation, render);\n            return;\n        }\n        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());\n        dataManager.then(function (e) { return _this.dataManagerSuccess(e, accumulation); });\n    };\n    /**\n     * To get points on dataManager is success.\n     *\n     * @private\n     * @param {Object} e - The data manager result object.\n     * @param {Object} e.result - The result of the data manager process.\n     * @param {number} e.count - The count of items in the result.\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @param {boolean} render - Specifies whether to render the accumulation chart after retrieving the points.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.dataManagerSuccess = function (e, accumulation, render) {\n        if (render === void 0) { render = true; }\n        var argsData = {\n            name: _common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, series: this, data: e.result\n        };\n        accumulation.allowServerDataBinding = false;\n        accumulation.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, argsData);\n        this.resultData = e.result !== '' ? e.result : [];\n        if (!accumulation.isBlazor && !render) {\n            this.getPoints(this.resultData, accumulation); // To update datasource using onPropertyChanged method. incident id: 290690\n        }\n        if ((++accumulation.seriesCounts === accumulation.visibleSeries.length && render)\n            || (window['Blazor'] && !render && accumulation.seriesCounts === 1)) {\n            this.getPoints(this.resultData, accumulation);\n            accumulation.refreshChart();\n        }\n    };\n    /**\n     * To find points from result data.\n     *\n     * @private\n     * @param {Object} result - The result of the process.\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.getPoints = function (result, accumulation) {\n        var length = Object.keys(result).length;\n        this.sumOfPoints = 0;\n        if (length === 0) {\n            // fix for Pie datalabels are not removed for empty datasource\n            this.points = [];\n            return null;\n        }\n        this.findSumOfPoints(result);\n        this.points = [];\n        this.clubbedPoints = [];\n        this.sumOfClub = 0;\n        var point;\n        var colors = this.palettes.length ? this.palettes : (0,_common_model_theme__WEBPACK_IMPORTED_MODULE_6__.getSeriesColor)(accumulation.theme);\n        var clubValue = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.stringToNumber)(this.groupTo, this.sumOfPoints);\n        for (var i = 0; i < length; i++) {\n            point = this.setPoints(result, i, colors, accumulation);\n            if (!this.isClub(point, clubValue, i)) {\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y)) {\n                    point.visible = false;\n                }\n                this.pushPoints(point, colors);\n            }\n            else {\n                point.index = this.clubbedPoints.length;\n                point.isExplode = true;\n                this.clubbedPoints.push(point);\n                point.isSliced = true;\n            }\n        }\n        this.lastGroupTo = this.groupTo;\n        if (this.sumOfClub > 0) {\n            var clubPoint_1 = this.generateClubPoint();\n            this.pushPoints(clubPoint_1, colors);\n            var pointsLength_1 = this.points.length - 1;\n            this.clubbedPoints.map(function (point) {\n                point.index += pointsLength_1;\n                point.color = clubPoint_1.color;\n            });\n        }\n        if (this.clubbedPoints.length && this.explode && this.type === 'Pie'\n            && (this.explodeAll || this.points[this.points.length - 1].index === this.explodeIndex)) {\n            this.points.splice(this.points.length - 1, 1);\n            this.points = this.points.concat(this.clubbedPoints);\n        }\n    };\n    AccumulationSeries.prototype.generateClubPoint = function () {\n        var clubPoint = new AccPoints();\n        clubPoint.isClubbed = true;\n        clubPoint.x = 'Others';\n        clubPoint.y = this.sumOfClub;\n        clubPoint.text = clubPoint.originalText = clubPoint.x + ': ' + this.sumOfClub;\n        clubPoint.sliceRadius = '80%';\n        return clubPoint;\n    };\n    /**\n     * Method to set point index and color.\n     *\n     * @param {AccPoints} point - The point data.\n     * @param {string[]} colors - The array of colors used in the accumulation chart.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.pushPoints = function (point, colors) {\n        point.index = this.points.length;\n        point.isExplode = this.explodeAll || (point.index === this.explodeIndex);\n        point.color = point.color || colors[point.index % colors.length];\n        this.points.push(point);\n    };\n    /**\n     * Method to find club point.\n     *\n     * @param {AccPoints} point - The point data.\n     * @param {number} clubValue - The club value for accumulation chart.\n     * @param {number} index - The index of the point in the data set.\n     * @returns {boolean} - false\n     */\n    AccumulationSeries.prototype.isClub = function (point, clubValue, index) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(clubValue)) {\n            if (this.groupMode === 'Value' && Math.abs(point.y) <= clubValue) {\n                this.sumOfClub += Math.abs(point.y);\n                return true;\n            }\n            else if (this.groupMode === 'Point' && index >= clubValue) {\n                this.sumOfClub += Math.abs(point.y);\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Method to find sum of points in the series.\n     *\n     * @param {Object} result - The result of the process.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.findSumOfPoints = function (result) {\n        var length = Object.keys(result).length;\n        for (var i = 0; i < length; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(result[i]) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(result[i][this.yName])\n                && !isNaN(result[i][this.yName])) {\n                this.sumOfPoints += Math.abs(result[i][this.yName]);\n            }\n        }\n    };\n    /**\n     * Method to set points x, y and text from data source.\n     *\n     * @param {Object} data - The data containing information for the points.\n     * @param {number} i - The index of the current point in the data set.\n     * @param {string[]} colors - The array of colors used in the accumulation chart.\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @returns {AccPoints} - The point data retrieved from the specified index.\n     */\n    AccumulationSeries.prototype.setPoints = function (data, i, colors, accumulation) {\n        var point = new AccPoints();\n        point.x = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.xName, data[i]);\n        point.y = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.yName, data[i]);\n        point.legendImageUrl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.legendImageUrl, data[i]);\n        point.color = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.pointColorMapping, data[i]);\n        point.text = point.originalText = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.dataLabel.name || '', data[i]);\n        point.tooltip = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.tooltipMappingName || '', data[i]);\n        point.sliceRadius = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.radius, data[i]);\n        point.sliceRadius = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.sliceRadius) ? '80%' : point.sliceRadius;\n        point.separatorY = accumulation.intl.formatNumber(point.y, { useGrouping: accumulation.useGroupingSeparator });\n        this.setAccEmptyPoint(point, i, data);\n        return point;\n    };\n    /**\n     * Method render the series elements for accumulation chart.\n     *\n     * @private\n     * @param {AccumulationChart} accumulation - The AccumulationChart control.\n     * @param {boolean} redraw - Specifies whether to redraw the points.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.renderSeries = function (accumulation, redraw) {\n        var seriesGroup = redraw ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(accumulation.element.id + '_Series_' + this.index) :\n            accumulation.renderer.createGroup({ id: accumulation.element.id + '_Series_' + this.index });\n        this.renderPoints(accumulation, seriesGroup, redraw);\n        var datalabelGroup;\n        if (accumulation.accumulationDataLabelModule && this.dataLabel.visible) {\n            datalabelGroup = accumulation.renderer.createGroup({ id: accumulation.element.id + '_datalabel_Series_' + this.index });\n            datalabelGroup.style.visibility =\n                (((this.animation.enable && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode !== 'Disable') || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') && accumulation.animateSeries && this.type === 'Pie') ? 'hidden' : 'visible';\n            this.renderDataLabel(accumulation, datalabelGroup, redraw);\n        }\n        if (this.type === 'Pie') {\n            if (!accumulation.redraw) {\n                this.findMaxBounds(this.labelBound, this.accumulationBound);\n            }\n            accumulation.pieSeriesModule.animateSeries(accumulation, this.animation, this, seriesGroup, this.borderRadius, this.points);\n        }\n        if (!accumulation.redraw && accumulation.accumulationLegendModule) {\n            this.labelBound.x -= accumulation.explodeDistance;\n            this.labelBound.y -= accumulation.explodeDistance;\n            this.labelBound.height += (accumulation.explodeDistance - this.labelBound.y);\n            this.labelBound.width += (accumulation.explodeDistance - this.labelBound.x);\n        }\n    };\n    /**\n     * Method render the points elements for accumulation chart series.\n     *\n     * @param {AccumulationChart} accumulation - The AccumulationChart control.\n     * @param {Element} seriesGroup - The group element to contain the point elements.\n     * @param {boolean} redraw - Specifies whether to redraw the points.\n     * @param {boolean} previouRadius - Specifies the previous radius of the pie when animating the individual series point.\n     * @param {boolean} previousCenter - Specifies the previous center of the pie when animating the individual series point.\n     * @param {boolean} pointAnimation - Specifies whether the point based animation is enabled.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.renderPoints = function (accumulation, seriesGroup, redraw, previouRadius, previousCenter, pointAnimation) {\n        var pointId = accumulation.element.id + '_Series_' + this.index + '_Point_';\n        var option;\n        var patternFill;\n        var options = [];\n        var visiblePoints = [];\n        var patterns = ['Chessboard', 'Dots', 'DiagonalForward', 'Crosshatch', 'Pacman', 'DiagonalBackward', 'Grid', 'Turquoise', 'Star', 'Triangle', 'Circle', 'Tile', 'HorizontalDash', 'VerticalDash', 'Rectangle', 'Box', 'VerticalStripe', 'HorizontalStripe', 'Bubble'];\n        for (var _i = 0, _a = this.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            point.percentage = (+(point.y / this.sumOfPoints * 100).toFixed(2));\n            var argsData = {\n                cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_5__.pointRender, series: this, point: point, fill: point.color,\n                border: this.isEmpty(point) ? { width: this.emptyPointSettings.border.width, color: this.emptyPointSettings.border.color } :\n                    { width: this.border.width, color: this.border.color }, pattern: this.applyPattern ? patterns[point.index % patterns.length] : 'None'\n            };\n            accumulation.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.pointRender, argsData);\n            point.color = argsData.fill;\n            patternFill = point.color;\n            if (this.applyPattern) {\n                var selection = new _common_user_interaction_selection__WEBPACK_IMPORTED_MODULE_7__.BaseSelection(accumulation);\n                patternFill = selection.pattern(accumulation, point.color, point.index, argsData.pattern, this.opacity);\n            }\n            option = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.PathOption(pointId + point.index, patternFill, argsData.border.width || 1, argsData.border.color || point.color, this.opacity, argsData.series.dashArray, '');\n            if (this.funnelMode === 'Trapezoidal' && this.type === 'Funnel') {\n                options.push(option);\n                if (point.visible) {\n                    visiblePoints.push(point);\n                }\n            }\n            else {\n                accumulation[((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.firstToLowerCase)(this.type) + 'SeriesModule')].\n                    renderPoint(point, this, accumulation, option, seriesGroup, redraw, previouRadius, previousCenter, pointAnimation);\n            }\n        }\n        if (this.funnelMode === 'Trapezoidal' && this.type === 'Funnel') {\n            accumulation[((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.firstToLowerCase)(this.type) + 'SeriesModule')].\n                renderTrapezoidalFunnel(this, visiblePoints, accumulation, options, seriesGroup, redraw);\n        }\n        else {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.appendChildElement)(false, accumulation.getSeriesElement(), seriesGroup, redraw);\n        }\n    };\n    /**\n     * Method render the datalabel elements for accumulation chart.\n     *\n     * @param {AccumulationChart} accumulation - The AccumulationChart control.\n     * @param {Element} datalabelGroup - The group element to contain the data label elements.\n     * @param {boolean} redraw - Specifies whether to redraw the data labels.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.renderDataLabel = function (accumulation, datalabelGroup, redraw) {\n        accumulation.accumulationDataLabelModule.findAreaRect();\n        var element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n            id: accumulation.element.id + '_Series_0' + '_DataLabelCollections'\n        });\n        this.leftSidePoints = [];\n        this.rightSidePoints = [];\n        var firstQuarter = [];\n        var secondQuarter = [];\n        for (var _i = 0, _a = this.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            if (point.visible) {\n                if (this.dataLabel.showZero || (!this.dataLabel.showZero && ((point.y !== 0) || (point.y === 0 &&\n                    this.emptyPointSettings.mode === 'Zero')))) {\n                    accumulation.accumulationDataLabelModule.renderDataLabel(point, this.dataLabel, datalabelGroup, this.points, this.index, element, redraw);\n                }\n            }\n            if (point.midAngle >= 90 && point.midAngle <= 270) {\n                this.leftSidePoints.push(point);\n            }\n            else {\n                if (point.midAngle >= 0 && point.midAngle <= 90) {\n                    secondQuarter.push(point);\n                }\n                else {\n                    firstQuarter.push(point);\n                }\n            }\n        }\n        firstQuarter.sort(function (a, b) { return a.midAngle - b.midAngle; });\n        secondQuarter.sort(function (a, b) { return a.midAngle - b.midAngle; });\n        this.leftSidePoints.sort(function (a, b) { return a.midAngle - b.midAngle; });\n        this.rightSidePoints = firstQuarter.concat(secondQuarter);\n        accumulation.accumulationDataLabelModule.drawDataLabels(this, this.dataLabel, datalabelGroup, element, redraw);\n        if (this.dataLabel.template !== null && element.childElementCount) {\n            var dataLabelCallBack = accumulation.accumulationDataLabelModule.drawDataLabels.bind(accumulation.accumulationDataLabelModule, this, this.dataLabel, datalabelGroup, element, redraw);\n            if (accumulation.isReact) {\n                accumulation.renderReactTemplates(dataLabelCallBack);\n            }\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.appendChildElement)(false, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(accumulation.element.id + '_Secondary_Element'), element, redraw);\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.appendChildElement)(false, accumulation.getSeriesElement(), datalabelGroup, redraw);\n    };\n    /**\n     * To find maximum bounds for smart legend placing.\n     *\n     * @private\n     * @param {Rect} totalbound - The total bounding rect.\n     * @param {Rect} bound - The bounding rect to be compared.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.findMaxBounds = function (totalbound, bound) {\n        totalbound.x = bound.x < totalbound.x ? bound.x : totalbound.x;\n        totalbound.y = bound.y < totalbound.y ? bound.y : totalbound.y;\n        totalbound.height = (bound.y + bound.height) > totalbound.height ? (bound.y + bound.height) : totalbound.height;\n        totalbound.width = (bound.x + bound.width) > totalbound.width ? (bound.x + bound.width) : totalbound.width;\n    };\n    /**\n     * Finds the maximum width of the labels for legend placement.\n     *\n     * @private\n     * @returns {number} The maximum label width.\n     */\n    AccumulationSeries.prototype.findMaxLabelWidth = function () {\n        var max;\n        for (var i = 0; i < this.points.length; i++) {\n            max = this.points[0].textSize.width;\n            if (max < this.points[i].textSize.width) {\n                max = this.points[i].textSize.width;\n            }\n        }\n        return max;\n    };\n    /**\n     * To set empty point value for null points.\n     *\n     * @private\n     * @param {AccPoints} point - The point to set as empty.\n     * @param {number} i - The index of the point in the data set.\n     * @param {Object} data - The data object.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.setAccEmptyPoint = function (point, i, data) {\n        if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y) || isNaN(point.y))) {\n            return null;\n        }\n        point.color = this.emptyPointSettings.fill || point.color;\n        switch (this.emptyPointSettings.mode) {\n            case 'Zero':\n                point.y = 0;\n                point.visible = true;\n                break;\n            case 'Average': {\n                var previous = data[i - 1] ? (data[i - 1][this.yName] || 0) : 0;\n                var next = data[i + 1] ? (data[i + 1][this.yName] || 0) : 0;\n                point.y = (Math.abs(previous) + Math.abs(next)) / 2;\n                this.sumOfPoints += point.y;\n                point.visible = true;\n                break;\n            }\n            default:\n                point.visible = false;\n                break;\n        }\n    };\n    /**\n     * Updates the data source for the series.\n     *\n     * @function setData\n     * @param {Object} data – Updated data source for the series.\n     * @param {number} duration – The duration for the animation.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.setData = function (data, duration) {\n        if (!data) {\n            return null;\n        }\n        var samePoints = false;\n        if (this.dataSource.length === data.length) {\n            samePoints = true;\n            for (var i = 0; i < data.length; i++) {\n                if (this.dataSource[i][this.xName] === data[i][this.xName]) {\n                    var point = this.points[i];\n                    var existingPoint = this.dataSource[i];\n                    if ((existingPoint[this.yName] !== data[i][this.yName])) {\n                        point.y = data[i][this.yName];\n                        this.dataSource[i] = data[i];\n                    }\n                }\n                else {\n                    samePoints = false;\n                    break;\n                }\n            }\n        }\n        if (!samePoints) {\n            this.dataSource = data;\n        }\n        else {\n            this.sumOfPoints = 0;\n            var visiblePoints = [];\n            for (var i = 0; i < this.resultData.length; i++) {\n                if (this.points[i] && this.points[i].visible) {\n                    visiblePoints.push(this.resultData[i]);\n                }\n            }\n            this.findSumOfPoints(visiblePoints);\n            this.accumulation.redraw = this.borderRadius ? false : this.accumulation.enableAnimation;\n            this.accumulation.animateSeries = false;\n            var chartDuration = this.accumulation.duration;\n            this.accumulation.duration = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(duration) ? 500 : duration;\n            this.accumulation[((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.firstToLowerCase)(this.type) + 'SeriesModule')].initProperties(this.accumulation, this);\n            this.renderPoints(this.accumulation, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_Series_' + this.index), this.accumulation.redraw, null, null, true);\n            if (this.accumulation.centerLabel.text) {\n                this.accumulation.renderCenterLabel(true, true);\n            }\n            if (this.accumulation.annotationModule) {\n                this.accumulation.annotationModule.renderAnnotations((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_Secondary_Element'));\n            }\n            if (this.accumulation.accumulationDataLabelModule && this.dataLabel.visible) {\n                this.renderDataLabel(this.accumulation, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_datalabel_Series_' + this.index), this.accumulation.redraw);\n            }\n            this.accumulation.redraw = false;\n            this.accumulation.duration = chartDuration;\n        }\n    };\n    /**\n     * Adds a data point to the data source for the series.\n     *\n     * @function addPoint\n     * @param {Object} dataPoint - The data point to be added.\n     * @param {number} duration – The duration for the animation.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.addPoint = function (dataPoint, duration) {\n        var maxWidth;\n        if (this.accumulation.series[0].dataLabel.visible) {\n            maxWidth = this.findMaxLabelWidth();\n        }\n        this.dataSource.push(dataPoint);\n        this.resultData = this.dataSource;\n        this.sumOfPoints = 0;\n        var visiblepoints = [];\n        for (var i = 0; i < this.resultData.length; i++) {\n            if (this.points[i] && this.points[i].visible) {\n                visiblepoints.push(this.resultData[i]);\n            }\n            else if (i === this.resultData.length - 1) {\n                visiblepoints.push(this.resultData[i]);\n            }\n        }\n        this.findSumOfPoints(visiblepoints);\n        var pointIndex = this.points.length === 0 ? 0 : this.points[this.points.length - 1].index + 1;\n        var colors = this.palettes.length ? this.palettes : (0,_common_model_theme__WEBPACK_IMPORTED_MODULE_6__.getSeriesColor)(this.accumulation.theme);\n        var point = this.setPoints(this.dataSource, pointIndex, colors, this.accumulation);\n        this.pushPoints(point, colors);\n        this.accumulation.redraw = this.borderRadius ? false : this.accumulation.enableAnimation;\n        var chartDuration = this.accumulation.duration;\n        this.accumulation.duration = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(duration) ? 500 : duration;\n        this.updateSeries((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_Series_' + this.index), maxWidth, 'addPoint');\n        this.accumulation.redraw = false;\n        this.accumulation.duration = chartDuration;\n    };\n    /**\n     * Removes a data point from the series data source at the specified index.\n     *\n     * @function removePoint\n     * @param {number} index – The index of the data point to be removed from the series.\n     * @param {number} duration – The duration for the animation.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.removePoint = function (index, duration) {\n        var dataSource = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSource, null, true);\n        var chartDuration = this.accumulation.duration;\n        if (dataSource.length > 0 && index >= 0 && index < dataSource.length) {\n            this.sumOfPoints = 0;\n            var removepoints = [];\n            for (var i = 0; i < this.dataSource.length; i++) {\n                if (i !== index && this.points[i] && this.points[i].visible) {\n                    removepoints.push(this.dataSource[i]);\n                }\n            }\n            dataSource.splice(index, 1);\n            this.dataSource.splice(index, 1);\n            this.findSumOfPoints(removepoints);\n            this.accumulation.redraw = this.borderRadius ? false : this.accumulation.enableAnimation;\n            this.accumulation.duration = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(duration) ? 500 : duration;\n            this.points.splice(index, 1);\n            for (var i = index; i < this.points.length; i++) {\n                var point = this.points[i];\n                point.index = i;\n                point.y = this.points[i].y;\n            }\n            var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_Series_0_Point_' + (this.points.length));\n            if (element) {\n                element.parentNode.removeChild(element);\n            }\n            this.updateSeries((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_Series_' + this.index), undefined, 'removePoint', index);\n            this.accumulation.redraw = false;\n            this.accumulation.duration = chartDuration;\n        }\n    };\n    /**\n     * Update the series based on addPoint and removePoint function.\n     *\n     * @param {Element} seriesGroup - Series group needs to be update.\n     * @param {number} maxLabelWidth - Specifies the maximum label width.\n     * @param {string} updatePoint - Specifies remove or add point.\n     * @param {number} index - specifies point index to remove.\n     * @returns {void}\n     */\n    AccumulationSeries.prototype.updateSeries = function (seriesGroup, maxLabelWidth, updatePoint, index) {\n        var previousRadius = this.accumulation[((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.firstToLowerCase)(this.type) + 'SeriesModule')].radius;\n        var previousCenter = this.accumulation[((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.firstToLowerCase)(this.type) + 'SeriesModule')].center;\n        var previousLegendBounds;\n        if (this.accumulation.legendSettings.visible) {\n            if (updatePoint === 'addPoint') {\n                this.accumulation.accumulationLegendModule.\n                    legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_8__.LegendOptions(this.points[this.points.length - 1].x.toString(), this.points[this.points.length - 1].color, this.legendShape, this.points[this.points.length - 1].visible, this.type, this.points[this.points.length - 1].legendImageUrl, null, null, this.points[this.points.length - 1].index, this.index));\n            }\n            else {\n                this.accumulation.accumulationLegendModule.legendCollections.splice(index, 1);\n                for (var i = index; i < this.accumulation.accumulationLegendModule.legendCollections.length; i++) {\n                    this.accumulation.accumulationLegendModule.legendCollections[i].pointIndex = i;\n                }\n            }\n            if (this.accumulation.accumulationLegendModule.legendCollections.length >= 1) {\n                previousLegendBounds = this.accumulation.accumulationLegendModule.legendBounds;\n                this.accumulation.accumulationLegendModule.calculateLegendBounds(this.accumulation.initialClipRect, this.accumulation.availableSize, null, previousLegendBounds, true);\n                if (this.dataLabel && this.dataLabel.position === 'Outside' && (this.accumulation.legendSettings.position === 'Bottom' || (this.accumulation.legendSettings.position === 'Top')) ? (previousLegendBounds.height !== this.accumulation.accumulationLegendModule.legendBounds.height) : (previousLegendBounds.width !== this.accumulation.accumulationLegendModule.legendBounds.width)) {\n                    var titleHeight = (this.accumulation.title ? (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.chartTitleFont).height *\n                        this.accumulation.titleCollection.length : 0);\n                    var subTitleHeight = (this.accumulation.subTitle ?\n                        ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(this.accumulation.subTitle, this.accumulation.subTitleStyle, this.accumulation.themeStyle.chartSubTitleFont).height *\n                            this.accumulation.subTitleCollection.length) : 0);\n                    this.accumulation.initialClipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(this.accumulation.margin.left, this.accumulation.margin.top, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.subtractRect)(this.accumulation.initialClipRect, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(0, (subTitleHeight\n                        + titleHeight), this.accumulation.margin.right +\n                        this.accumulation.margin.left, this.accumulation.margin.bottom + this.accumulation.margin.top));\n                    this.accumulation.accumulationLegendModule.calculateLegendBounds(this.accumulation.initialClipRect, this.accumulation.availableSize, null);\n                }\n            }\n        }\n        this.accumulation[((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.firstToLowerCase)(this.type) + 'SeriesModule')].initProperties(this.accumulation, this);\n        this.renderPoints(this.accumulation, seriesGroup, this.accumulation.redraw, previousRadius, previousCenter, true);\n        if (previousLegendBounds && ((this.accumulation.legendSettings.position === 'Bottom' || (this.accumulation.legendSettings.position === 'Top')) ? (previousLegendBounds.height !== this.accumulation.accumulationLegendModule.legendBounds.height) : (previousLegendBounds.width !== this.accumulation.accumulationLegendModule.legendBounds.width)) && this.accumulation.centerLabel.text) {\n            this.accumulation.renderCenterLabel(true, true);\n        }\n        if (this.accumulation.annotationModule) {\n            this.accumulation.annotationModule.renderAnnotations((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.accumulation.element.id + '_Secondary_Element'));\n        }\n        if (this.accumulation.accumulationDataLabelModule && this.dataLabel.visible) {\n            var datalabelGroup = this.accumulation.renderer.createGroup({ id: this.accumulation.element.id + '_datalabel_Series_' + this.index });\n            this.renderDataLabel(this.accumulation, datalabelGroup, this.accumulation.redraw);\n        }\n        if (this.accumulation.legendSettings.visible) {\n            if (this.type === 'Pie') {\n                if (this.dataLabel.visible && this.points[this.points.length - 1] && this.points[this.points.length - 1].textSize.width > maxLabelWidth && this.accumulation.legendSettings.position !== 'Top' && this.accumulation.legendSettings.position !== 'Bottom') {\n                    this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, this.points[this.points.length - 1].labelRegion);\n                    this.findMaxBounds(this.labelBound, this.accumulationBound);\n                    this.labelBound.x -= this.accumulation.explodeDistance;\n                    this.labelBound.y -= this.accumulation.explodeDistance;\n                    this.labelBound.height += (this.accumulation.explodeDistance - this.labelBound.y);\n                    this.labelBound.width += (this.accumulation.explodeDistance - this.labelBound.x);\n                }\n                this.accumulation.accumulationLegendModule.getSmartLegendLocation(this.accumulation.visibleSeries[0].labelBound, this.accumulation.accumulationLegendModule.legendBounds, this.accumulation.margin);\n            }\n            this.accumulation.accumulationLegendModule.renderLegend(this.accumulation, this.accumulation.legendSettings, this.accumulation.accumulationLegendModule.legendBounds, this.accumulation.redraw, true);\n        }\n    };\n    /**\n     * To find point is empty.\n     *\n     * @param {AccPoints} point - The point to check.\n     * @returns {boolean} - True if the point is empty, otherwise false.\n     */\n    AccumulationSeries.prototype.isEmpty = function (point) {\n        return point.color === this.emptyPointSettings.fill;\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"dataSource\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], AccumulationSeries.prototype, \"query\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"xName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"tooltipMappingName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"yName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], AccumulationSeries.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ color: null, width: 0 }, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.Border)\n    ], AccumulationSeries.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.Animation)\n    ], AccumulationSeries.prototype, \"animation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('SeriesType')\n    ], AccumulationSeries.prototype, \"legendShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"legendImageUrl\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], AccumulationSeries.prototype, \"pointColorMapping\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], AccumulationSeries.prototype, \"applyPattern\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationSeries.prototype, \"selectionStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationSeries.prototype, \"groupTo\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Value')\n    ], AccumulationSeries.prototype, \"groupMode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, AccumulationDataLabelSettings)\n    ], AccumulationSeries.prototype, \"dataLabel\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)([])\n    ], AccumulationSeries.prototype, \"palettes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], AccumulationSeries.prototype, \"startAngle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationSeries.prototype, \"endAngle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationSeries.prototype, \"radius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], AccumulationSeries.prototype, \"innerRadius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Pie')\n    ], AccumulationSeries.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], AccumulationSeries.prototype, \"enableTooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], AccumulationSeries.prototype, \"explode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('30%')\n    ], AccumulationSeries.prototype, \"explodeOffset\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], AccumulationSeries.prototype, \"explodeAll\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], AccumulationSeries.prototype, \"explodeIndex\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ mode: 'Drop' }, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.EmptyPointSettings)\n    ], AccumulationSeries.prototype, \"emptyPointSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], AccumulationSeries.prototype, \"gapRatio\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('80%')\n    ], AccumulationSeries.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('80%')\n    ], AccumulationSeries.prototype, \"height\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('20%')\n    ], AccumulationSeries.prototype, \"neckWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('20%')\n    ], AccumulationSeries.prototype, \"neckHeight\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Linear')\n    ], AccumulationSeries.prototype, \"pyramidMode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Standard')\n    ], AccumulationSeries.prototype, \"funnelMode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], AccumulationSeries.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], AccumulationSeries.prototype, \"dashArray\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_2__.Accessibility)\n    ], AccumulationSeries.prototype, \"accessibility\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], AccumulationSeries.prototype, \"borderRadius\", void 0);\n    return AccumulationSeries;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * method to get series from index.\n *\n * @private\n * @param {number} index - The index of the series to retrieve.\n * @param {AccumulationSeries[]} visibleSeries - The array of visible series in the chart.\n * @returns {AccumulationSeries} - The series retrieved from the specified index.\n */\nfunction getSeriesFromIndex(index, visibleSeries) {\n    for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n        var series = visibleSeries_1[_i];\n        if (index === series.index) {\n            return series;\n        }\n    }\n    return visibleSeries[0];\n}\n/**\n * method to get point from index.\n *\n * @private\n * @param {number} index - The index of the point to retrieve.\n * @param {AccPoints[]} points - The array of points in the data set.\n * @returns {AccPoints} - The point retrieved from the specified index.\n */\nfunction pointByIndex(index, points) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n        var point = points_1[_i];\n        if (point.index === index) {\n            return point;\n        }\n    }\n    return null;\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/model/acc-base.js?");

/***/ })

}]);