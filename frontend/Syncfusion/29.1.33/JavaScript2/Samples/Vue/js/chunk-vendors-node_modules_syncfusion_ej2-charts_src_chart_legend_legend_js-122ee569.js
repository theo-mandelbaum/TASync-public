"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_legend_legend_js-122ee569"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/legend/legend.js":
/*!************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/legend/legend.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Legend: () => (/* binding */ Legend)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_legend_legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/legend/legend */ \"./node_modules/@syncfusion/ej2-charts/src/common/legend/legend.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Chart legend\n */\n\n\n\n\n\n\n\n/**\n * The `Legend` module is used to render the legend for the chart.\n */\nvar Legend = /** @class */ (function (_super) {\n    __extends(Legend, _super);\n    function Legend(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.library = _this;\n        _this.addEventListener();\n        return _this;\n    }\n    /**\n     * Binding events for legend module.\n     *\n     * @returns {void}\n     */\n    Legend.prototype.addEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove, this);\n        this.chart.on('click', this.click, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseEnd, this);\n    };\n    /**\n     * UnBinding events for legend module.\n     *\n     * @returns {void}\n     */\n    Legend.prototype.removeEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove);\n        this.chart.off('click', this.click);\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseEnd);\n    };\n    /**\n     * To handle mosue move for legend module.\n     *\n     * @param {MouseEvent} e - The mouse event.\n     * @returns {void}\n     */\n    Legend.prototype.mouseMove = function (e) {\n        if (this.chart.legendSettings.visible && !this.chart.isTouch) {\n            this.move(e);\n            if (this.chart.highlightModule && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {\n                var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',\n                    this.legendID + '_shape_', this.legendID + '_g_'];\n                var targetId = e.target.id;\n                var index = void 0;\n                for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {\n                    var id = legendItemsId_1[_i];\n                    if (targetId.indexOf(id) > -1) {\n                        index = parseInt(targetId.split(id)[1], 10);\n                        this.chart.highlightModule.legendSelection(this.chart, index, e.target, e.type);\n                        break;\n                    }\n                }\n                // this.click(e);\n            }\n        }\n    };\n    /**\n     * To handle mosue end for legend module.\n     *\n     * @param {MouseEvent} e - The mouse event.\n     * @returns {void}\n     */\n    Legend.prototype.mouseEnd = function (e) {\n        if (this.chart.legendSettings.visible && this.chart.isTouch) {\n            this.move(e);\n        }\n    };\n    /**\n     * Retrieves the legend options based on the visible series collection and chart.\n     *\n     * @param {Series[]} visibleSeriesCollection - The collection of visible series.\n     * @param {Chart} chart - The chart instance.\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.getLegendOptions = function (visibleSeriesCollection, chart) {\n        this.legendCollections = [];\n        var seriesType;\n        var fill;\n        var dashArray;\n        var colors = [];\n        this.isRtlEnable = chart.enableRtl;\n        this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;\n        if (visibleSeriesCollection.length > 1) {\n            this.legend.mode = 'Series';\n        }\n        for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {\n            var series = visibleSeriesCollection_1[_i];\n            if (this.legend.mode === 'Series') {\n                if (series.category !== 'Indicator') {\n                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :\n                        series.type;\n                    dashArray = !series.marker.visible && (seriesType.indexOf('Line') > -1 && seriesType.indexOf('Area') === -1) ? series.dashArray : '';\n                    // To set legend color when use pointColorMapping\n                    fill = (series.pointColorMapping && series.points.length > 0) ?\n                        (series.points[0].interior ? series.points[0].interior : series.interior) : series.interior;\n                    this.legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_1__.LegendOptions(series.name, fill, series.legendShape, (series.category === 'TrendLine' ?\n                        this.chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible), seriesType, series.legendImageUrl ? series.legendImageUrl : (series.type === 'Scatter' && series.marker.shape === 'Image' ?\n                        series.marker.imageUrl : ''), series.marker.shape, series.marker.visible, null, null, dashArray));\n                }\n            }\n            else if (this.legend.mode === 'Point') {\n                for (var _a = 0, _b = series.points; _a < _b.length; _a++) {\n                    var points = _b[_a];\n                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :\n                        series.type;\n                    fill = points.interior ? points.interior : series.interior;\n                    this.legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_1__.LegendOptions(points.x.toString(), fill, series.legendShape, (series.category === 'TrendLine' ?\n                        this.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible), seriesType, (series.type === 'Scatter' && series.marker.shape === 'Image') ? series.marker.imageUrl : '', series.marker.shape, series.marker.visible));\n                }\n            }\n            else if (this.legend.mode === 'Range') {\n                for (var _c = 0, _d = series.points; _c < _d.length; _c++) {\n                    var points = _d[_c];\n                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :\n                        series.type;\n                    fill = points.interior ? points.interior : series.interior;\n                    var legendLabel = 'Others';\n                    if (colors.indexOf(fill) < 0) {\n                        colors.push(fill);\n                        if (chart.rangeColorSettings.length >= 1 && chart.rangeColorSettings[0].colors.length === 1) {\n                            for (var _e = 0, _f = chart.rangeColorSettings; _e < _f.length; _e++) {\n                                var rangeMap = _f[_e];\n                                if (rangeMap.colors[0] === fill) {\n                                    legendLabel = rangeMap.label;\n                                }\n                            }\n                            this.legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_1__.LegendOptions(legendLabel, fill, series.legendShape, (series.category === 'TrendLine' ?\n                                this.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible), seriesType, (series.type === 'Scatter' && series.marker.shape === 'Image') ? series.marker.imageUrl : '', series.marker.shape, series.marker.visible));\n                        }\n                    }\n                }\n            }\n            else {\n                if (this.legendCollections.length === 0 && chart.rangeColorSettings.length > 0) {\n                    var startLabel = chart.rangeColorSettings[0].start.toString();\n                    var endLabel = chart.rangeColorSettings[chart.rangeColorSettings.length - 1].end.toString();\n                    this.legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_1__.LegendOptions(startLabel, series.interior, 'Rectangle', true, seriesType, '', series.marker.shape, series.marker.visible));\n                    this.legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_1__.LegendOptions(endLabel, series.interior, 'Rectangle', true, seriesType, '', series.marker.shape, series.marker.visible));\n                }\n            }\n        }\n        if (this.isReverse && chart.legendSettings.mode !== 'Gradient') {\n            this.legendCollections.reverse();\n        }\n    };\n    /**\n     * Calculates the legend bounds based on the available size and legend settings.\n     *\n     * @param {Size} availableSize - The available size for the legend.\n     * @param {Rect} legendBounds - The current bounds of the legend.\n     * @param {LegendSettingsModel} legend - The legend settings.\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.getLegendBounds = function (availableSize, legendBounds, legend) {\n        this.calculateLegendTitle(legend, legendBounds);\n        this.isTitle = legend.title ? true : false;\n        this.chartRowCount = 1;\n        this.rowHeights = [];\n        this.columnHeights = [];\n        this.pageHeights = [];\n        var padding = legend.padding;\n        var titlePosition = legend.titlePosition;\n        var extraHeight = 0;\n        var legendOption;\n        var extraWidth = 0;\n        var arrowWidth = this.arrowWidth;\n        var arrowHeight = this.arrowHeight;\n        var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;\n        var titleSpace = this.isTitle && titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;\n        titleSpace = this.isTitle && this.isVertical && titlePosition !== 'Top' ? this.legendTitleSize.height + this.fivePixel : titleSpace;\n        if (!this.isVertical) {\n            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;\n        }\n        else {\n            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;\n        }\n        legendBounds.height += (extraHeight);\n        legendBounds.width += extraWidth;\n        var shapeWidth = legend.shapeWidth;\n        var shapePadding = legend.shapePadding;\n        var maximumWidth = 0;\n        var rowWidth = 0;\n        var legendWidth = 0;\n        var columnHeight = 0;\n        var columnCount = 0;\n        var rowCount = 0;\n        var titlePlusArrowSpace = 0;\n        var legendEventArgs;\n        var render = false;\n        this.maxItemHeight = Math.max((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);\n        var maxColumn = legend.layout === 'Auto' && legend.maximumColumns > 0;\n        if (legend.fixedWidth) {\n            for (var i = 0; i < this.legendCollections.length; i++) {\n                var textWidth = shapeWidth + shapePadding + (!this.isVertical ? (i === 0) ? padding : this.itemPadding\n                    : padding) + (legend.maximumLabelWidth ? legend.maximumLabelWidth :\n                    (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(this.legendCollections[i].text, legend.textStyle, this.chart.themeStyle.legendLabelFont).width);\n                this.maxWidth = Math.max(this.maxWidth, textWidth);\n            }\n        }\n        for (var i = 0; i < this.legendCollections.length; i++) {\n            legendOption = this.legendCollections[i];\n            if (_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.regSub.test(legendOption.text)) {\n                legendOption.text = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getUnicodeText)(legendOption.text, _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.regSub);\n            }\n            if (_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.regSup.test(legendOption.text)) {\n                legendOption.text = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getUnicodeText)(legendOption.text, _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.regSup);\n            }\n            legendEventArgs = {\n                fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,\n                markerShape: legendOption.markerShape, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendRender, cancel: false\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendRender, legendEventArgs);\n            legendOption.render = !legendEventArgs.cancel;\n            legendOption.text = legendEventArgs.text;\n            legendOption.fill = legendEventArgs.fill;\n            legendOption.shape = legendEventArgs.shape;\n            legendOption.markerShape = legendEventArgs.markerShape;\n            legendOption.textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);\n            shapeWidth = legendOption.text ? legend.shapeWidth : 0;\n            shapePadding = legendOption.text ? legend.shapePadding : 0;\n            if (legendOption.render && legendOption.text) {\n                render = true;\n                legendWidth = legend.fixedWidth ? this.maxWidth : shapeWidth + shapePadding +\n                    (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) +\n                    ((!this.isVertical || legend.layout === 'Horizontal') ? (i === 0 || (columnCount === 1 && rowCount > 0 && legend.layout === 'Horizontal')) ? padding : this.itemPadding : padding);\n                rowWidth = rowWidth + legendWidth;\n                if (!legend.enablePages && !this.isVertical) {\n                    titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;\n                    titlePlusArrowSpace += arrowWidth;\n                }\n                this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);\n                if (maxColumn ? columnCount === legend.maximumColumns : legend.layout === 'Vertical' || (legendBounds.width < (padding + rowWidth + titlePlusArrowSpace)) || (this.isVertical && legend.layout === 'Auto')) {\n                    maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace - (this.isVertical &&\n                        this.legend.layout === 'Auto' ? 0 : legendWidth)));\n                    if (rowCount === 0 && (legendWidth !== rowWidth)) {\n                        rowCount = 1;\n                    }\n                    rowWidth = this.isVertical && this.legend.layout === 'Auto' ? 0 : legendWidth;\n                    rowCount++;\n                    columnCount = 0;\n                    columnHeight = verticalArrowSpace;\n                    //columnHeight = (rowCount * (this.maxItemHeight + padding)) + padding + titleSpace + verticalArrowSpace;\n                }\n                var len = (rowCount > 0 ? (rowCount - 1) : 0);\n                this.rowHeights[len] = Math.max((this.rowHeights[len] ?\n                    this.rowHeights[len] : 0), Math.max(legendOption.textSize.height, legend.shapeHeight));\n                // this.maxItemHeight = Math.max(this.maxItemHeight, legendOption.textSize.height);\n                this.columnHeights[columnCount] = (this.columnHeights[columnCount] ?\n                    this.columnHeights[columnCount] : 0) + Math.max(legendOption.textSize.height, legend.shapeHeight) +\n                    ((this.isVertical || (rowCount > 0 && this.legend.itemPadding)) ? (i === 0) ? padding : this.itemPadding : padding);\n                columnCount++;\n            }\n        }\n        columnHeight = Math.max.apply(null, this.columnHeights) + padding + titleSpace;\n        columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleSpace);\n        if (legend.layout === 'Horizontal') {\n            columnHeight = this.maxItemHeight + (padding * 2) + titleSpace + this.pageButtonSize + legend.border.width;\n        }\n        this.isPaging = (legendBounds.height < columnHeight || (legend.layout === 'Horizontal' && this.rowHeights.length > 1)) && !maxColumn;\n        if (this.isPaging && !legend.enablePages) {\n            if (!this.isVertical) {\n                columnHeight = (this.maxItemHeight + padding) + padding + (titlePosition === 'Top' ? titleSpace : 0);\n            }\n        }\n        this.totalPages = rowCount;\n        if (maxColumn && this.maxWidth && legend.fixedWidth) {\n            rowWidth = this.maxWidth * legend.maximumColumns;\n            this.isPaging = false;\n        }\n        if ((!this.isPaging || this.legend.layout !== 'Auto') && !this.isVertical) {\n            rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;\n        }\n        if (render) {\n            this.setBounds(Math.max((rowWidth + padding), maximumWidth), columnHeight, legend, legendBounds);\n        }\n        else {\n            this.setBounds(0, 0, legend, legendBounds);\n        }\n    };\n    /**\n     * Calculates the height of the legend based on the legend options, settings, and available space.\n     *\n     * @param {LegendOptions} legendOption - The legend options.\n     * @param {LegendSettingsModel} legend - The legend settings.\n     * @param {Rect} legendBounds - The current bounds of the legend.\n     * @param {number} rowWidth - The width of the legend rows.\n     * @param {number} legendHeight - The current height of the legend.\n     * @param {number} padding - The padding around the legend items.\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.getLegendHeight = function (legendOption, legend, legendBounds, rowWidth, legendHeight, padding) {\n        var legendWidth = legendOption.textSize.width;\n        var textPadding = legend.shapePadding + (padding * 2) + legend.shapeWidth;\n        switch (legend.textWrap) {\n            case 'Wrap':\n            case 'AnyWhere':\n                if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > legendBounds.width) {\n                    legendOption.textCollection = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textWrap)(legendOption.text, (legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, (legendBounds.width - textPadding)) :\n                        (legendBounds.width - textPadding)), legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);\n                }\n                else {\n                    legendOption.textCollection.push(legendOption.text);\n                }\n                legendOption.textSize.height = (legendHeight * legendOption.textCollection.length);\n                break;\n        }\n    };\n    /**\n     * Calculates the rendering point for the legend item based on various parameters.\n     *\n     * @param {LegendOptions} legendOption - The legend options.\n     * @param {ChartLocation} start - The starting location for the legend.\n     * @param {number} textPadding - The padding around the legend text.\n     * @param {LegendOptions} previousLegend - The options of the previous legend item.\n     * @param {Rect} rect - The bounding rectangle for the legend.\n     * @param {number} count - The count of legend items.\n     * @param {number} firstLegend - The index of the first legend item.\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.getRenderPoint = function (legendOption, start, textPadding, previousLegend, rect, count, firstLegend) {\n        var padding = this.legend.padding;\n        var textWidth = this.legend.fixedWidth ? this.maxWidth : textPadding + (this.legend.maximumLabelWidth ?\n            this.legend.maximumLabelWidth : previousLegend.textSize.width);\n        var previousBound = previousLegend.location.x + ((!this.isRtlEnable) ? textWidth : -textWidth);\n        if (this.legend.layout === 'Auto' && this.legend.maximumColumns > 0 ? count % this.legend.maximumColumns === 0 : this.legend.layout === 'Vertical' || this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ?\n            this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect) || (this.isVertical && this.legend.layout === 'Auto')) {\n            legendOption.location.x = start.x;\n            if (count !== firstLegend) {\n                this.chartRowCount++;\n            }\n            legendOption.location.y = (count === firstLegend) ? previousLegend.location.y :\n                previousLegend.location.y + (this.isVertical && this.legend.layout !== 'Horizontal' && !(this.legend.maximumColumns > 0) ? Math.max(previousLegend.textSize.height, this.legend.shapeHeight) :\n                    this.rowHeights[(this.chartRowCount - 2)]) + ((this.isVertical || (this.chartRowCount > 1 &&\n                    this.legend.itemPadding)) ? this.itemPadding : padding);\n        }\n        else {\n            legendOption.location.x = (count === firstLegend) ? previousLegend.location.x : previousBound;\n            legendOption.location.y = previousLegend.location.y;\n        }\n        var availwidth = (!this.isRtlEnable) ? (this.legendBounds.x + this.legendBounds.width) - (legendOption.location.x +\n            textPadding - this.itemPadding - this.legend.shapeWidth / 2) : (legendOption.location.x - textPadding + this.itemPadding +\n            (this.legend.shapeWidth / 2)) - this.legendBounds.x;\n        if (!this.isVertical && this.isPaging && !this.legend.enablePages) {\n            availwidth = this.legendBounds.width - legendOption.location.x - this.fivePixel;\n        }\n        availwidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availwidth) : availwidth;\n        if (this.legend.textOverflow === 'Ellipsis' && this.legend.textWrap === 'Normal') {\n            legendOption.text = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);\n        }\n    };\n    Legend.prototype.isWithinBounds = function (previousBound, textWidth, rect) {\n        if (!this.isRtlEnable) {\n            return (previousBound + textWidth) > (rect.x + rect.width + (this.legend.shapeWidth / 2));\n        }\n        else {\n            return (previousBound - textWidth) < (rect.x - (this.legend.shapeWidth / 2));\n        }\n    };\n    /**\n     * Handles the click event for a legend item.\n     *\n     * @param {number} index - The index of the clicked legend item.\n     * @param {Event | PointerEvent} event - The click event.\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.LegendClick = function (index, event) {\n        var chart = this.chart;\n        var seriesIndex = chart.legendSettings.mode === 'Series' ? index : 0;\n        var legendIndex = !this.isReverse ? index : (this.legendCollections.length - 1) - index;\n        var series = chart.visibleSeries[seriesIndex];\n        var legend = this.legendCollections[legendIndex];\n        var changeDetection = 'isProtectedOnChange';\n        if (chart.legendSettings.mode === 'Series') {\n            var legendClickArgs = {\n                legendText: legend.text, legendShape: legend.shape,\n                chart: chart.isBlazor ? {} : chart, series: series, points: series.points, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendClick, cancel: false\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendClick, legendClickArgs);\n            series.legendShape = legendClickArgs.legendShape;\n            if (!legendClickArgs.cancel) {\n                if (series.fill !== null) {\n                    chart.visibleSeries[index].interior = series.fill;\n                }\n                if (chart.legendSettings.toggleVisibility) {\n                    series.chart[changeDetection] = true;\n                    if (series.category === 'TrendLine') {\n                        if (!chart.series[series.sourceIndex].trendlines[series.index].visible &&\n                            chart.series[series.sourceIndex].visible) {\n                            chart.series[series.sourceIndex].trendlines[series.index].visible = true;\n                        }\n                        else {\n                            chart.series[series.sourceIndex].trendlines[series.index].visible = false;\n                        }\n                    }\n                    else {\n                        this.changeSeriesVisiblity(series, series.visible);\n                    }\n                    legend.visible = series.category === 'TrendLine' ? chart.series[series.sourceIndex].trendlines[series.index].visible :\n                        (series.visible);\n                    this.refreshLegendToggle(chart, series);\n                    if (chart.highlightModule && chart.legendSettings.enableHighlight) {\n                        chart.highlightModule.legendSelection(chart, index, event.target, 'mousemove');\n                    }\n                }\n                else if (chart.highlightModule) {\n                    chart.highlightModule.legendSelection(chart, index, event.target, event.type);\n                }\n                else if (chart.selectionModule) {\n                    chart.selectionModule.legendSelection(chart, index, event.target, event.type);\n                }\n                series.chart[changeDetection] = false;\n            }\n        }\n        else if (chart.legendSettings.mode === 'Point') {\n            var point = series.points[index];\n            var legendClickArgs = {\n                legendText: legend.text, legendShape: legend.shape,\n                chart: chart.isBlazor ? {} : chart, series: series, points: [point], name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendClick, cancel: false\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendClick, legendClickArgs);\n            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {\n                point.visible = !point.visible;\n                var legendOption = this.legendCollections[index];\n                legendOption.visible = point.visible;\n                this.refreshLegendToggle(chart, series);\n            }\n        }\n        else if (chart.legendSettings.mode === 'Range') {\n            var points = [];\n            var legendOption = this.legendCollections[index];\n            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n                var point = _a[_i];\n                if (legendOption.fill === (point.interior || series.interior)) {\n                    points.push(point);\n                }\n            }\n            var legendClickArgs = {\n                legendText: legend.text, legendShape: legend.shape,\n                chart: chart.isBlazor ? {} : chart, series: series, points: points, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendClick, cancel: false\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.legendClick, legendClickArgs);\n            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {\n                legendOption.visible = !legendOption.visible;\n                for (var _b = 0, points_1 = points; _b < points_1.length; _b++) {\n                    var point = points_1[_b];\n                    point.visible = !point.visible;\n                }\n                this.refreshLegendToggle(chart, series);\n            }\n        }\n    };\n    Legend.prototype.refreshLegendToggle = function (chart, series) {\n        var selectedDataIndexes = [];\n        if (chart.selectionModule) {\n            selectedDataIndexes = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], chart.selectionModule.selectedDataIndexes, null, true);\n        }\n        if ((chart.svgObject.childNodes.length > 0) && !chart.enableAnimation && !chart.enableCanvas) {\n            while (chart.svgObject.lastChild) {\n                chart.svgObject.removeChild(chart.svgObject.lastChild);\n            }\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(chart.svgObject);\n        }\n        chart.animateSeries = false;\n        chart.redraw = chart.enableAnimation;\n        series.isLegendClicked = true;\n        chart.rotatedDataLabelCollections = [];\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.removeElement)((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.getElement)(chart.element.id + '_Secondary_Element').querySelectorAll('.ejSVGTooltip')[0]);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.blazorTemplatesReset)(chart);\n        this.redrawSeriesElements(series, chart);\n        chart.removeSvg();\n        chart.refreshAxis();\n        series.refreshAxisLabel();\n        this.refreshSeries(chart.visibleSeries);\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n            var series_1 = _a[_i];\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series_1)) {\n                chart.markerRender.removeHighlightedMarker(series_1, null, true);\n            }\n        }\n        chart.refreshBound();\n        chart.trigger('loaded', { chart: chart });\n        if (selectedDataIndexes.length > 0) {\n            chart.selectionModule.selectedDataIndexes = selectedDataIndexes;\n            chart.selectionModule.redrawSelection(chart, chart.selectionMode);\n        }\n        if (!chart.enableCanvas && chart.highlightModule && (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight)) {\n            chart.highlightModule.redrawSelection(chart, chart.highlightMode);\n        }\n        chart.redraw = false;\n        series.isLegendClicked = false;\n    };\n    Legend.prototype.changeSeriesVisiblity = function (series, visibility) {\n        series.visible = !visibility;\n        if (this.isSecondaryAxis(series.xAxis)) {\n            series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });\n        }\n        if (this.isSecondaryAxis(series.yAxis) || (series.category === 'Pareto' && series.type === 'Line')) {\n            series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });\n        }\n        if (series.trendlines.length && series.visible) {\n            series.trendlines.forEach(function (trendline) {\n                trendline.visible = true;\n            });\n        }\n    };\n    Legend.prototype.isSecondaryAxis = function (axis) {\n        return (this.chart.axes.indexOf(axis) > -1);\n    };\n    Legend.prototype.redrawSeriesElements = function (series, chart) {\n        if (!chart.redraw) {\n            return null;\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.removeElement)(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) +\n            '_DataLabelCollections');\n    };\n    Legend.prototype.refreshSeries = function (seriesCollection) {\n        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n            var series = seriesCollection_1[_i];\n            if (series.type.indexOf('Spline') > -1) {\n                var isArea = (series.type.indexOf('Area') > -1 || series.drawType.indexOf('Area') > -1);\n                var isRange = series.type.indexOf('Range') > -1;\n                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(series);\n            }\n            if (series.visible) {\n                series.position = undefined;\n            }\n        }\n    };\n    /**\n     * Handles the click event for showing tooltip on trimmed text in legend.\n     *\n     * @param {Event | PointerEvent} event - The click event.\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.click = function (event) {\n        var _this = this;\n        if (!this.chart.legendSettings.visible) {\n            return;\n        }\n        var pageX = this.chart.mouseX;\n        var pageY = this.chart.mouseY;\n        var legendRegion = [];\n        var targetId = event.target.id.indexOf('_chart_legend_g_') > -1 ?\n            event.target.firstChild['id'] : event.target.id;\n        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',\n            this.legendID + '_shape_'];\n        var seriesIndex;\n        for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {\n            var id = legendItemsId_2[_i];\n            if (targetId.indexOf(id) > -1) {\n                seriesIndex = parseInt(targetId.split(id)[1], 10);\n                this.LegendClick(seriesIndex, event);\n                break;\n            }\n        }\n        if (targetId.indexOf(this.legendID + '_pageup') > -1) {\n            this.changePage(event, true);\n        }\n        else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {\n            this.changePage(event, false);\n        }\n        if (this.chart.enableCanvas && this.pagingRegions.length) {\n            this.checkWithinBounds(pageX, pageY);\n        }\n        legendRegion = this.legendRegions.filter(function (region) {\n            return ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.withInBounds)(pageX, (pageY + (_this.isPaging ? (_this.currentPageNumber - 1) *\n                _this.translatePage(_this.chart.enableCanvas, null, 1, 2) : 0)), region.rect));\n        });\n        if (legendRegion.length && this.chart.enableCanvas) {\n            this.LegendClick(legendRegion[0].index, event);\n        }\n    };\n    /**\n     * Checks whether the provided coordinates are within the bounds.\n     *\n     * @param {number} pageX - The x-coordinate of the mouse pointer.\n     * @param {number} pageY - The y-coordinate of the mouse pointer.\n     * @returns {void}\n     * @protected\n     */\n    Legend.prototype.checkWithinBounds = function (pageX, pageY) {\n        var cRender = this.chart.renderer;\n        var bounds = this.legendBounds;\n        var borderWidth = this.chart.legendSettings.border.width;\n        var canvasRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(bounds.x, bounds.y, bounds.width, bounds.height);\n        canvasRect.x = canvasRect.x - borderWidth / 2;\n        canvasRect.y = canvasRect.y - borderWidth / 2;\n        canvasRect.width = canvasRect.width + borderWidth;\n        canvasRect.height = canvasRect.height + borderWidth;\n        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.withInBounds)(pageX, pageY, this.pagingRegions[0])) {\n            // pageDown calculations are performing here\n            if (!this.isRtlEnable) {\n                this.canvasPageDown(cRender, canvasRect, bounds);\n            }\n            else {\n                this.canvasPageUp(cRender, canvasRect, bounds);\n            }\n            return null;\n        }\n        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.withInBounds)(pageX, pageY, this.pagingRegions[1])) {\n            // pageUp calculations are performing here\n            if (!this.isRtlEnable) {\n                this.canvasPageUp(cRender, canvasRect, bounds);\n            }\n            else {\n                this.canvasPageDown(cRender, canvasRect, bounds);\n            }\n            return null;\n        }\n    };\n    Legend.prototype.canvasPageDown = function (cRender, canvasRect, bounds) {\n        if (--this.currentPageNumber > 0) {\n            this.legendRegions = [];\n            cRender.clearRect(canvasRect);\n            cRender.canvasClip(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.RectOption('legendClipPath', 'transparent', { width: 0, color: '' }, null, canvasRect));\n            this.renderLegend(this.chart, this.legend, bounds);\n            cRender.canvasRestore();\n        }\n        else {\n            ++this.currentPageNumber;\n        }\n    };\n    Legend.prototype.canvasPageUp = function (cRender, canvasRect, bounds) {\n        if (++this.currentPageNumber > 0 && this.currentPageNumber <= this.totalNoOfPages) {\n            this.legendRegions = [];\n            cRender.clearRect(canvasRect);\n            cRender.canvasClip(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.RectOption('legendClipPath', 'transpaent', { width: 0, color: '' }, null, canvasRect));\n            this.renderLegend(this.chart, this.legend, bounds);\n            cRender.canvasRestore();\n        }\n        else {\n            --this.currentPageNumber;\n        }\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    Legend.prototype.getModuleName = function () {\n        return 'Legend';\n    };\n    /**\n     * To destroy the Legend.\n     *\n     * @returns {void}\n     * @private\n     */\n    Legend.prototype.destroy = function () {\n        this.removeEventListener();\n    };\n    return Legend;\n}(_common_legend_legend__WEBPACK_IMPORTED_MODULE_1__.BaseLegend));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/legend/legend.js?");

/***/ })

}]);