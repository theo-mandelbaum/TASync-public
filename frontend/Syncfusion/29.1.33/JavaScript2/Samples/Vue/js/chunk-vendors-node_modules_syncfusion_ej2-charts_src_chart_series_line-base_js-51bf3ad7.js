"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_line-base_js-51bf3ad7"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineBase: () => (/* binding */ LineBase)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n/**\n * Base class for line-type series.\n * This class provides common properties and methods for line-type series in the chart.\n *\n * @private\n */\nvar LineBase = /** @class */ (function () {\n    /**\n     * Initializes the tooltip module for the chart.\n     *\n     * @param {Chart} [chartModule] - The chart instance to which the tooltip module is initialized.\n     */\n    function LineBase(chartModule) {\n        this.chart = chartModule;\n    }\n    /**\n     * Enhances the performance of the chart by enabling complex properties.\n     *\n     * @param {Series} series - The series for which complex properties are enabled.\n     * @returns {Points[]} An array of points.\n     * @private\n     */\n    LineBase.prototype.enableComplexProperty = function (series) {\n        var tempPoints = [];\n        var tempPoints2 = [];\n        var xVisibleRange = series.xAxis.visibleRange;\n        var yVisibleRange = series.yAxis.visibleRange;\n        var seriesPoints = series.points;\n        var areaBounds = series.clipRect;\n        var xTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousX :\n            Math.abs(xVisibleRange.delta / areaBounds.width);\n        var yTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousY :\n            Math.abs(yVisibleRange.delta / areaBounds.height);\n        var prevXValue = (seriesPoints[0] && seriesPoints[0].xValue > xTolerance) ? 0 : xTolerance;\n        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;\n        this.previousX = xTolerance;\n        this.previousY = yTolerance;\n        var xVal = 0;\n        var yVal = 0;\n        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n            var currentPoint = seriesPoints_1[_i];\n            currentPoint.symbolLocations = [];\n            xVal = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(currentPoint.xValue) ? currentPoint.xValue : xVisibleRange.min;\n            yVal = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(currentPoint.yValue) ? currentPoint.yValue : yVisibleRange.min;\n            if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {\n                tempPoints.push(currentPoint);\n                prevXValue = xVal;\n                prevYValue = yVal;\n            }\n        }\n        var tempPoint;\n        for (var i = 0; i < tempPoints.length; i++) {\n            tempPoint = tempPoints[i];\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(tempPoint.x) || (series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue)))) {\n                continue;\n            }\n            else {\n                tempPoints2.push(tempPoint);\n            }\n        }\n        return tempPoints2;\n    };\n    /**\n     * To generate the line path direction.\n     *\n     * @param {Points} firstPoint firstPoint\n     * @param {Points} secondPoint secondPoint\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     * @param {string} startPoint startPoint\n     * @returns {string} get line path direction\n     * @private\n     */\n    LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {\n        var direction = '';\n        if (firstPoint != null) {\n            var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n            var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n            direction = startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ' +\n                'L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ';\n        }\n        return direction;\n    };\n    /**\n     * Appends a line path to the chart.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clipping rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.appendLinePath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.pathAnimation)(points.element, options.d, series.chart.redraw, points.previousDirection, points.chart.duration);\n    };\n    LineBase.prototype.appendPathElement = function (options, series, clipRect) {\n        var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(options.id);\n        var chart = series.chart;\n        var previousDirection = element ? element.getAttribute('d') : null;\n        var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (htmlObject) {\n            htmlObject.setAttribute('clip-path', clipRect);\n        }\n        if (series.category === 'TrendLine' && htmlObject) {\n            var trendline = chart.series[series.sourceIndex].trendlines[series.index];\n            if (!trendline.marker.visible) {\n                htmlObject.setAttribute('tabindex', trendline.accessibility.focusable ? String(trendline.accessibility.tabIndex) : '-1');\n            }\n            htmlObject.setAttribute('role', trendline.accessibility.accessibilityRole ? trendline.accessibility.accessibilityRole : '');\n            htmlObject.setAttribute('aria-label', trendline.accessibility.accessibilityDescription ? trendline.accessibility.accessibilityDescription : '');\n        }\n        series.pathElement = htmlObject;\n        if (!series.chart.enableCanvas) {\n            series.seriesElement.appendChild(htmlObject);\n        }\n        series.isRectSeries = false;\n        return { element: element, previousDirection: previousDirection, chart: chart };\n    };\n    /**\n     * Adds a line path to equate the start and end paths.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clip rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.addPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.push((startPathCommands[startPathCommands.length - 1]).replace('M', 'L'));\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        if (series.removedPointIndex === series.points.length) {\n                            endPathCommands.push((endPathCommands[endPathCommands.length - 1]).replace('M', 'L'));\n                        }\n                        else {\n                            endPathCommands.splice(1, 0, endPathCommands[0].replace('M', 'L'));\n                        }\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Adds a area path to equate the start and end paths.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clip rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.addAreaPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (minLength < endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        if (endPathCommands.length !== startPathCommands.length) {\n                            if (startPathCommands.length === 1) {\n                                startPathCommands.push(startPathCommands[startPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)].replace('M', 'L'));\n                            }\n                            else {\n                                startPathCommands.splice(startPathCommands.length - 1, 0, startPathCommands[startPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)]);\n                            }\n                        }\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        if (series.removedPointIndex === series.points.length) {\n                            if (endPathCommands.length === 1) {\n                                endPathCommands.push(endPathCommands[endPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)].replace('M', 'L'));\n                            }\n                            else {\n                                endPathCommands.splice(endPathCommands.length - 1, 0, endPathCommands[endPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)]);\n                            }\n                        }\n                        else {\n                            endPathCommands.splice(1, 0, endPathCommands[1] ? endPathCommands[1] : endPathCommands[0]);\n                        }\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * To render the marker for the series.\n     *\n     * @param {Series} series - The series for which markers are rendered.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.renderMarker = function (series) {\n        if (series.marker && series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * Executes progressive animation for the series.\n     *\n     * @param {Series} series - The series for which progressive animation is executed.\n     * @param {AnimationModel} option - The animation option.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.doProgressiveAnimation = function (series, option) {\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Animation({});\n        var path = series.pathElement;\n        var strokeDashArray = path.getAttribute('stroke-dasharray');\n        var pathLength = series.pathElement.getTotalLength();\n        var currentTime;\n        path.style.visibility = 'hidden';\n        animation.animate(path, {\n            duration: (option.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.animationMode === 'Enable') ? 1000 : option.duration,\n            delay: option.delay,\n            progress: function (args) {\n                path.style.visibility = 'visible';\n                currentTime = Math.abs(Math.round(((args.timeStamp) * pathLength) / args.duration));\n                path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);\n            },\n            end: function () {\n                var annotations = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(series.chart.element.id + '_Annotation_Collections');\n                if (annotations) {\n                    annotations.style.visibility = 'visible';\n                }\n                path.setAttribute('stroke-dasharray', strokeDashArray);\n                path.style.visibility = '';\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    /**\n     * To store the symbol location and region.\n     *\n     * @param {Points} point point\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getLocation getLocation\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {\n        var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;\n        var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;\n        point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));\n        point.regions.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n    };\n    /**\n     * Checks if the y-value of a point falls within the y-axis range.\n     *\n     * @param {Points} point - The point to be checked.\n     * @param {Axis} yAxis - The y-axis.\n     * @returns {boolean} - Returns true if the y-value falls within the y-axis range, otherwise false.\n     * @private\n     */\n    LineBase.prototype.withinYRange = function (point, yAxis) {\n        return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;\n    };\n    LineBase.prototype.GetStepLineDirection = function (currentPoint, previousPoint, stepLineType, command, series, isBorder) {\n        if (command === void 0) { command = 'L'; }\n        var X = (series.noRisers && isBorder) ? ' M ' : ' L ';\n        if (stepLineType === 'Right') {\n            command = (series.noRisers && isBorder) ? 'M' : 'L';\n            return (command + ' ' +\n                (previousPoint.x) + ' ' + (currentPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n        }\n        else if (stepLineType === 'Center') {\n            var centerX = previousPoint.x + (currentPoint.x - previousPoint.x) / 2;\n            return (command + ' ' +\n                (centerX) + ' ' + (previousPoint.y) + X + (centerX) + ' ' + (currentPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n        }\n        else {\n            return (command + ' ' +\n                (currentPoint.x) + ' ' + (previousPoint.y) + X + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n        }\n    };\n    /**\n     * Gets the first and last visible points from a collection of points.\n     *\n     * @param {Points[]} points - Collection of points.\n     * @returns {{ first: Points, last: Points }} - Returns an object containing the first and last visible points.\n     * @private\n     */\n    LineBase.prototype.getFirstLastVisiblePoint = function (points) {\n        var first = null;\n        var last = null;\n        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n            var point = points_1[_i];\n            if (first === null && point.visible) {\n                first = last = point;\n            }\n            last = point.visible ? point : last;\n        }\n        return { first: first ? first : points[0], last: last ? last : points[points.length - 1] };\n    };\n    /**\n     * Gets the border direction based on the provided direction.\n     *\n     * @param {string} direction - The direction string.\n     * @returns {string} - Returns the border direction.\n     * @private\n     */\n    LineBase.prototype.getBorderDirection = function (direction) {\n        var coordinates = direction.split(' ');\n        if (coordinates.length > 3 && !(this.chart.stackingAreaSeriesModule) && !(this.chart.stackingStepAreaSeriesModule)) {\n            coordinates.splice(coordinates.length - 4, 3);\n        }\n        else if (this.chart.stackingAreaSeriesModule || this.chart.stackingStepAreaSeriesModule) {\n            coordinates.splice(coordinates.length / 2 + 1, coordinates.length / 2 + 1);\n            if (coordinates[coordinates.length - 1] === 'L' || coordinates[coordinates.length - 1] === 'M') {\n                coordinates.splice(coordinates.length - 1, 1);\n            }\n        }\n        return coordinates.join(' ');\n    };\n    /**\n     * Removes the border from the empty points based on the provided border direction.\n     *\n     * @param {string} borderDirection - The border direction.\n     * @returns {string} - Returns the updated border direction.\n     * @private\n     */\n    LineBase.prototype.removeEmptyPointsBorder = function (borderDirection) {\n        var startIndex = 0;\n        var coordinates = borderDirection.split(' ');\n        var point;\n        if (coordinates.length === 4) {\n            return coordinates.join(' ');\n        }\n        do {\n            point = coordinates.indexOf('M', startIndex);\n            if (point > -1) {\n                coordinates.splice(point + 1, 3);\n                startIndex = point + 1;\n                if (point - 6 > 0) {\n                    coordinates.splice(point - 6, 6);\n                    startIndex -= 6;\n                }\n            }\n        } while (point !== -1);\n        return coordinates.join(' ');\n    };\n    /**\n     * Performs linear animation for the series based on the provided animation model.\n     *\n     * @param {Series} series - The series to animate.\n     * @param {AnimationModel} animation - The animation model containing animation details.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.doLinearAnimation = function (series, animation) {\n        var clipRect = series.clipRectElement.childNodes[0].childNodes[0];\n        var duration = series.chart.animated ? series.chart.duration : animation.duration;\n        var effect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getAnimationFunction)('Linear');\n        var elementHeight = +clipRect.getAttribute('height');\n        var elementWidth = +clipRect.getAttribute('width');\n        var xCenter = +clipRect.getAttribute('x');\n        var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') :\n            +clipRect.getAttribute('y');\n        var value;\n        clipRect.style.visibility = 'hidden';\n        this.animateRect(series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);\n        if (series.marker && series.marker.visible && series.symbolElement) {\n            var markerClipRect = series.symbolElement.childNodes[0].childNodes[0];\n            markerClipRect.style.visibility = 'hidden';\n            this.animateRect(series, animation, markerClipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);\n        }\n    };\n    /**\n     * Animates the given clip rectangle with the specified animation parameters.\n     *\n     * @param {Series} series - The series to which the clip rectangle belongs.\n     * @param {AnimationModel} animation - The animation model containing animation details.\n     * @param {HTMLElement} clipRect - The clip rectangle to animate.\n     * @param {number} duration - The duration of the animation.\n     * @param {Function} effect - The animation function to use.\n     * @param {number} elementHeight - The height of the clip rectangle element.\n     * @param {number} elementWidth - The width of the clip rectangle element.\n     * @param {number} xCenter - The x-coordinate of the clip rectangle's center.\n     * @param {number} yCenter - The y-coordinate of the clip rectangle's center.\n     * @param {number} value - The animation value.\n     * @returns {void}\n     */\n    LineBase.prototype.animateRect = function (series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value) {\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Animation({}).animate(clipRect, {\n            duration: (duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.animationMode === 'Enable') ? 1000 : duration,\n            delay: animation.delay,\n            progress: function (args) {\n                clipRect.style.visibility = 'visible';\n                if (series.chart.requireInvertedAxis) {\n                    value = effect(args.timeStamp, 0, elementHeight, args.duration);\n                    clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +\n                        ') scale(1,' + (value / elementHeight) + ') translate(' + (-xCenter) + ' ' + (-yCenter) + ')');\n                }\n                else {\n                    value = effect(args.timeStamp, 0, elementWidth, args.duration);\n                    clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +\n                        ') scale(' + (value / elementWidth) + ', 1) translate(' + (-xCenter) + ' ' + (-yCenter) + ')');\n                }\n            },\n            end: function () {\n                var annotations = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(series.chart.element.id + '_Annotation_Collections');\n                if (annotations) {\n                    annotations.style.visibility = 'visible';\n                }\n                var stackLabelGroup = document.getElementById(series.chart.element.id + '_StackLabelGroup');\n                if (stackLabelGroup) {\n                    stackLabelGroup.setAttribute('visibility', 'visible');\n                }\n                clipRect.setAttribute('transform', 'translate(0,0)');\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    return LineBase;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js?");

/***/ })

}]);