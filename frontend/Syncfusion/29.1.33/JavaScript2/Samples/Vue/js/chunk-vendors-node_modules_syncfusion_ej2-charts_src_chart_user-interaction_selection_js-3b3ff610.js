"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_user-interaction_selection_js-3b3ff610"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/selection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/selection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Selection: () => (/* binding */ Selection)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _common_user_interaction_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/user-interaction/selection */ \"./node_modules/@syncfusion/ej2-charts/src/common/user-interaction/selection.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Selection src file\n */\n\n\n\n\n\n\n\n\n/**\n * The `Selection` module handles the selection of chart elements.\n *\n * @private\n */\nvar Selection = /** @class */ (function (_super) {\n    __extends(Selection, _super);\n    /**\n     * Constructor for selection module.\n     *\n     * @private\n     */\n    function Selection(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.isdrawRect = true;\n        _this.multiDataIndexes = [];\n        _this.pathIndex = 0;\n        _this.seriesIndex = 0;\n        _this.count = -1;\n        _this.dragRectArray = [];\n        _this.filterArray = [];\n        _this.totalSelectedPoints = [];\n        _this.chart = chart;\n        _this.renderer = chart.renderer;\n        var mode = chart.selectionMode;\n        _this.isMultiDrag = chart.isMultiSelect && (mode.indexOf('Drag') > -1);\n        _this.addEventListener();\n        return _this;\n    }\n    /**\n     * Adds event listeners for the chart.\n     *\n     * @returns {void}\n     */\n    Selection.prototype.addEventListener = function () {\n        if (this.chart.isDestroyed || (this.chart.stockChart && this.chart.stockChart.onPanning)) {\n            return;\n        }\n        var cancelEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave';\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove, this);\n        this.chart.on(cancelEvent, this.mouseLeave, this);\n        this.chart.on('click', this.mouseClick, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.mousedown, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseLeave, this);\n    };\n    /**\n     * Handles the mousedown event.\n     *\n     * @private\n     * @param {Event} e - The event object.\n     * @returns {void}\n     */\n    Selection.prototype.mousedown = function (e) {\n        var chart = this.chart;\n        if (chart.isPointMouseDown || chart.selectionMode === 'None' || chart.isChartDrag) {\n            return;\n        }\n        if (chart.isDoubleTap || !chart.isTouch || this.rectPoints) {\n            this.dragStart(chart, chart.chartAxisLayoutPanel.seriesClipRect, chart.mouseDownX, chart.mouseDownY, e);\n        }\n    };\n    /**\n     * UnBinding events for selection module.\n     *\n     * @returns {void}\n     */\n    Selection.prototype.removeEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove);\n        this.chart.off('pointerleave' || 0, this.mouseLeave);\n        this.chart.off('click', this.mouseClick);\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.mousedown);\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseLeave);\n    };\n    /**\n     * Initializes private variables for the chart.\n     *\n     * @private\n     * @param {Chart} chart - The chart instance.\n     * @returns {void}\n     */\n    Selection.prototype.initPrivateVariables = function (chart) {\n        this.styleId = chart.element.id + '_ej2_chart_selection';\n        this.unselected = chart.element.id + '_ej2_deselected';\n        this.closeIconId = chart.element.id + '_ej2_drag_close';\n        this.draggedRectGroup = chart.element.id + '_ej2_drag_group';\n        this.multiRectGroup = chart.element.id + '_ej2_drag_multi_group';\n        this.draggedRect = chart.element.id + '_ej2_drag_rect';\n        this.lassoPath = chart.element.id + '_ej2_drag_path';\n        this.selectedDataIndexes = [];\n        this.rectPoints = null;\n        this.isSeriesMode = chart.selectionMode === 'Series';\n    };\n    /**\n     * Method to select the point and series.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @returns {void}\n     */\n    Selection.prototype.invokeSelection = function (chart) {\n        this.initPrivateVariables(chart);\n        this.series = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, chart.visibleSeries, null, true);\n        this.seriesStyles();\n        this.currentMode = chart.selectionMode;\n        if (!(chart.selectionMode.indexOf('Drag') > -1)) {\n            this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));\n        }\n    };\n    Selection.prototype.generateStyle = function (series) {\n        if (series) {\n            if (this.styleId.indexOf('selection') > 1 && this.chart.selectionMode !== 'None') {\n                this.unselected = series.unSelectedStyle || this.unselected;\n            }\n            if (this.styleId.indexOf('highlight') > 0 && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {\n                this.unselected = series.nonHighlightStyle || this.unselected;\n            }\n            return (series.selectionStyle || this.styleId + '_series_' + series.index);\n        }\n        return 'undefined';\n    };\n    /**\n     * Selects data points in the chart based on the provided indexes.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index[]} indexes - An array of Index objects specifying the series and point indexes to be selected.\n     * @returns {void}\n     */\n    Selection.prototype.selectDataIndex = function (chart, indexes) {\n        for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n            var index = indexes_1[_i];\n            this.performSelection(index, chart, this.getElementByIndex(chart, index, '', this.series[index.series].marker.visible)[0]);\n        }\n    };\n    /**\n     * Retrieves the DOM elements corresponding to the specified data point index.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index} index - The index object specifying the series and point indexes.\n     * @param {string} [suffix=''] - Optional suffix to be appended to the element IDs.\n     * @param {boolean} [marker] - Optional parameter to specify whether to retrieve marker elements. Default is false.\n     * @param {boolean} [dataLabel] - Optional parameter to specify whether to retrieve datalabel elements. Default is false.\n     * @returns {Element[]} - An array of DOM elements corresponding to the specified data point index.\n     */\n    Selection.prototype.getElementByIndex = function (chart, index, suffix, marker, dataLabel) {\n        if (suffix === void 0) { suffix = ''; }\n        var elementId = chart.element.id + '_Series_' + index.series + '_Point' + '_' + index.point;\n        var series = chart.series[index.series];\n        elementId = (series.type !== 'Scatter' && series.type !== 'Bubble' && marker) ? (elementId + '_Symbol' + suffix) : elementId;\n        if (!marker && dataLabel) {\n            return [(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(elementId + '_Text_0' + suffix), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(elementId + '_TextShape_0' + suffix)];\n        }\n        return [(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(elementId), ((series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') && series.marker.visible) ?\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(elementId + '1') : null];\n    };\n    /**\n     * Retrieves the DOM elements corresponding to the cluster of data points at the specified index.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index} index - The index object specifying the series and point indexes.\n     * @returns {Element[]} - An array of DOM elements corresponding to the cluster of data points at the specified index.\n     */\n    Selection.prototype.getClusterElements = function (chart, index) {\n        var clusters = [];\n        var seriesStyle;\n        var selectedElements;\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n            var series = _a[_i];\n            if (series.visible) {\n                index = new _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Index(series.index, index.point);\n                if (series.isRectSeries) {\n                    clusters.push(this.getElementByIndex(chart, index)[0]);\n                }\n                clusters.push(this.getElementByIndex(chart, index, '', series.marker.visible)[0]);\n                var dataLabelTextElement = document.getElementById(chart.element.id + '_Series_' + series.index + '_Point_' + index.point + '_Text_0');\n                var dataLabelShapeElement = document.getElementById(chart.element.id + '_Series_' + series.index + '_Point_' + index.point + '_TextShape_0');\n                if (dataLabelTextElement) {\n                    clusters.push(dataLabelTextElement);\n                }\n                if (dataLabelShapeElement) {\n                    clusters.push(dataLabelShapeElement);\n                }\n                seriesStyle = this.generateStyle(chart.visibleSeries[index.series]);\n                selectedElements = document.querySelectorAll('.' + seriesStyle);\n                this.findTrackballElements(selectedElements, seriesStyle);\n                var clusterIndex = series.marker.visible && series.isRectSeries ? 2 : 1;\n                clusterIndex += (dataLabelTextElement && dataLabelShapeElement) ? 2 :\n                    (dataLabelTextElement || dataLabelShapeElement) ? 1 : 0;\n                if (!chart.isMultiSelect && selectedElements.length > 0 &&\n                    selectedElements[0].id !== (clusters[clusters.length - clusterIndex] ? clusters[clusters.length - clusterIndex].id : '')) {\n                    this.removeSelection(chart, index.series, selectedElements, seriesStyle, true);\n                }\n            }\n        }\n        return clusters;\n    };\n    /**\n     * Finds the elements within the selected elements that match the specified class name.\n     *\n     * @param {Element[] | NodeListOf<HTMLElement>} selectedElements - The elements to search within.\n     * @param {string} className - The class name to search for.\n     * @returns {void}\n     */\n    Selection.prototype.findTrackballElements = function (selectedElements, className) {\n        var trackballElements;\n        var elements;\n        for (var i = 0; i < selectedElements.length; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(selectedElements[i])) {\n                trackballElements = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(selectedElements[i].parentNode) ?\n                    [].slice.call(selectedElements[0].parentNode.querySelectorAll('.' + className)) : [];\n                if (trackballElements.length > 0) {\n                    elements = [];\n                    for (var i_1 = 0; i_1 < trackballElements.length; i_1++) {\n                        if (trackballElements[i_1].id.indexOf('Trackball') > -1) {\n                            elements.push(trackballElements[i_1]);\n                        }\n                    }\n                    this.removeStyles(elements);\n                }\n            }\n        }\n    };\n    /**\n     * Finds the elements in the chart corresponding to the specified series and data point index.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {SeriesModel} series - The series for which to find the elements.\n     * @param {Index} index - The index of the data point.\n     * @param {string} [suffix=''] - A suffix to append to the element IDs.\n     * @param {boolean} [marker] - Specifies whether to include marker elements.\n     * @param {boolean} [dataLabel] - Specifies whether to include datalabel elements.\n     * @returns {Element[]} - An array of elements corresponding to the specified series and data point index.\n     */\n    Selection.prototype.findElements = function (chart, series, index, suffix, marker, dataLabel) {\n        if (suffix === void 0) { suffix = ''; }\n        if (this.isSeriesMode) {\n            return this.getSeriesElements(series);\n        }\n        else if (this.currentMode === 'Cluster') {\n            return this.getClusterElements(chart, index);\n        }\n        else {\n            return this.getElementByIndex(chart, index, suffix, marker, dataLabel);\n        }\n    };\n    /**\n     * Checks if the target element is already selected for the specified event type.\n     *\n     * @param {Element} targetElem - The target element to check.\n     * @param {string} eventType - The type of event (e.g., 'mouse move', 'touch move').\n     * @returns {boolean} - A boolean value indicating whether the target element is already selected for the specified event type.\n     */\n    Selection.prototype.isAlreadySelected = function (targetElem, eventType) {\n        if (eventType === 'click') {\n            this.currentMode = this.chart.selectionMode;\n            this.styleId = this.chart.element.id + (this.chart.selectionModule && this.chart.selectionMode !== 'None' ? '_ej2_chart_selection' : '_ej2_chart_highlight');\n        }\n        else if (eventType === 'mousemove' || eventType === 'pointermove') {\n            this.currentMode = this.chart.highlightMode;\n            this.highlightDataIndexes = [];\n            this.styleId = this.chart.element.id + '_ej2_chart_highlight';\n        }\n        if (this.chart.highlightMode !== 'None' && this.chart.selectionMode === 'None') {\n            if (eventType === 'click') {\n                return false;\n            }\n        }\n        if (((this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) && this.previousSelectedEle && this.previousSelectedEle[0])) {\n            var parentNodeId = targetElem.parentNode ? targetElem.parentNode.id : '';\n            var isElement = void 0;\n            if (targetElem.parentNode) {\n                isElement = (parentNodeId.indexOf('SeriesGroup') > 0 || parentNodeId.indexOf('SymbolGroup') > 0) ? true : false;\n            }\n            for (var i = 0; i < this.previousSelectedEle.length; i++) {\n                if (this.previousSelectedEle[i] && this.previousSelectedEle[i].hasAttribute('class')) {\n                    if (this.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1 &&\n                        (isElement || eventType === 'click')) {\n                        this.previousSelectedEle[i].removeAttribute('class');\n                        if (this.previousSelectedEle[i].id.indexOf('Group') > 0) {\n                            for (var j = 0; j < this.previousSelectedEle[i].children.length; j++) {\n                                if (this.chart.highlightColor !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor) && this.chart.highlightPattern === 'None') {\n                                    this.previousSelectedEle[i].children[j].setAttribute('fill', (this.previousSelectedEle[i].children[j].id.indexOf('Text') > -1 || this.previousSelectedEle[i].children[j].id.indexOf('TextShape') > -1) ? this.previousSelectedEle[i].children[j].getAttribute('fill') : this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);\n                                }\n                                this.previousSelectedEle[i].children[j].removeAttribute('style');\n                            }\n                        }\n                        else {\n                            if (this.chart.highlightColor !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor) && this.chart.highlightPattern === 'None') {\n                                this.previousSelectedEle[i].setAttribute('fill', (this.previousSelectedEle[i].id.indexOf('Text') > -1 || this.previousSelectedEle[i].id.indexOf('TextShape') > -1) ? this.previousSelectedEle[i].getAttribute('fill') : this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);\n                            }\n                            this.previousSelectedEle[i].removeAttribute('style');\n                        }\n                        this.addOrRemoveIndex(this.highlightDataIndexes, this.indexFinder(this.previousSelectedEle[i].id));\n                    }\n                    else if (!isElement && this.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1) {\n                        this.performSelection(this.indexFinder(this.previousSelectedEle[i].id), this.chart, this.previousSelectedEle[i]);\n                    }\n                }\n            }\n        }\n        return true;\n    };\n    Selection.prototype.mouseClick = function (event) {\n        this.calculateSelectedElements(event.target, event.type, true);\n        if (this.chart.highlightModule && this.chart.highlightModule.highlightDataIndexes\n            && this.chart.highlightModule.highlightDataIndexes.length > 0 && event.target.id.indexOf('_chart_legend_') === -1\n            && event.target.id.indexOf('_Series_') === -1 && this.chart.isTouch && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n            this.removeLegendHighlightStyles();\n        }\n    };\n    /**\n     * Calculates the selected elements based on the target element and event type.\n     *\n     * @param {HTMLElement} targetElement - The target element for which to calculate selected elements.\n     * @param {string} eventType - The type of event (e.g., 'mouse move', 'touch move').\n     * @param {boolean} pointClick - Selection of series points.\n     * @returns {void}\n     */\n    Selection.prototype.calculateSelectedElements = function (targetElement, eventType, pointClick) {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(targetElement)) {\n            return;\n        }\n        if ((this.chart.selectionMode === 'None' && this.chart.highlightMode === 'None') ||\n            targetElement.id && targetElement.id.indexOf(this.chart.element.id + '_') === -1) {\n            return;\n        }\n        if (eventType === 'mousemove' || eventType === 'pointermove') {\n            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||\n                targetElement.getAttribute('class').indexOf('selection') > -1)) {\n                return;\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(targetElement.parentNode) && targetElement.parentNode.hasAttribute('class') &&\n                (targetElement.parentNode.getAttribute('class').indexOf('highlight') > 0 ||\n                    targetElement.parentNode.getAttribute('class').indexOf('selection') > 0)) {\n                return;\n            }\n        }\n        this.isAlreadySelected(targetElement, eventType);\n        if (targetElement.id && targetElement.id.indexOf('_Series_') > -1 && targetElement.id.indexOf('_Text_') === -1) {\n            var element = void 0;\n            if (targetElement.id.indexOf('_Trackball_1') > -1) {\n                element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(targetElement.id.split('_Trackball_')[0] + '_Symbol');\n                element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(element) ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(targetElement.id.split('_Trackball_')[0]) : element;\n            }\n            else if (targetElement.id.indexOf('_Trackball_0') > -1) {\n                return null;\n            }\n            this.performSelection(this.indexFinder(targetElement.id), this.chart, element || targetElement, pointClick);\n        }\n    };\n    /**\n     * Performs selection based on the provided index and chart.\n     *\n     * @param {Index} index - The index for which to perform the selection.\n     * @param {Chart} chart - The chart instance.\n     * @param {Element} [element] - Optional. The element associated with the selection.\n     * @param {boolean} pointClick - Selection of series points.\n     * @returns {void}\n     */\n    Selection.prototype.performSelection = function (index, chart, element, pointClick) {\n        this.isSeriesMode = this.currentMode === 'Series';\n        if (chart.visibleSeries[index.series].type === 'BoxAndWhisker' && element &&\n            element.id === chart.element.id + '_Series_' + index.series + '_Point_' + index.point + '_BoxPath') {\n            element = element.parentNode;\n        }\n        if (chart.visibleSeries[index.series].type === 'Area' && (this.currentMode === 'Point' || this.currentMode === 'Cluster') && element &&\n            (element.id === this.chart.element.id + '_Series_' + index.series)) {\n            var className = this.generateStyle(chart.series[index.series]);\n            var selectionEle = document.querySelectorAll('.' + className);\n            this.findTrackballElements(selectionEle, className);\n            this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);\n        }\n        switch (this.currentMode) {\n            case 'Series':\n                this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));\n                this.selectionComplete(chart, index, this.currentMode);\n                this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);\n                break;\n            case 'Point':\n                if ((!isNaN(index.point) && element) || (!pointClick && isNaN(index.point))) {\n                    var pointElements = [];\n                    pointElements.push(element);\n                    var series = this.chart.visibleSeries[index.series];\n                    var baseId = chart.element.id + \"_Series_\" + index.series + \"_Point_\" + index.point;\n                    var textElement = document.getElementById(baseId + \"_Text_0\");\n                    if (series.marker.dataLabel.visible && textElement !== null) {\n                        pointElements.push(textElement);\n                        pointElements.push(document.getElementById(baseId + \"_TextShape_0\"));\n                    }\n                    if (pointElements[0] !== null && chart.series[index.series].marker.visible &&\n                        (chart.series[index.series].type.indexOf('Column') !== -1 || chart.series[index.series].type.indexOf('Bar') !== -1)) {\n                        if (!(element.id.indexOf('_Symbol') !== -1) && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(element.id + '_Symbol')) {\n                            pointElements.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(element.id + '_Symbol'));\n                        }\n                        else if (element.id.indexOf('_Symbol') !== -1 && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(element.id.replace('_Symbol', ''))) {\n                            pointElements.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(element.id.replace('_Symbol', '')));\n                        }\n                    }\n                    this.selection(chart, index, (!pointClick && isNaN(index.point)) ?\n                        this.getSeriesElements(chart.series[index.series]) : pointElements);\n                    this.selectionComplete(chart, index, this.currentMode);\n                    this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);\n                }\n                break;\n            case 'Cluster':\n                if (!isNaN(index.point) || (!pointClick && isNaN(index.point))) {\n                    if (!pointClick && isNaN(index.point)) {\n                        this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));\n                    }\n                    else {\n                        this.clusterSelection(chart, index);\n                    }\n                    this.selectionComplete(chart, index, this.currentMode);\n                    this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);\n                }\n                break;\n        }\n    };\n    /**\n     * Completes the selection process based on the provided index and selection mode.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index} index - The index for which the selection is completed.\n     * @param {SelectionMode | HighlightMode} selectionMode - The selection mode.\n     * @returns {void}\n     */\n    Selection.prototype.selectionComplete = function (chart, index, selectionMode) {\n        var points;\n        var pointIndex;\n        var seriesIndex;\n        var selectedPointValues = [];\n        var yValue;\n        var selectedPointX;\n        if (selectionMode === 'Cluster') {\n            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (series.visible) {\n                    for (var i = 0; i < this.selectedDataIndexes.length; i++) {\n                        pointIndex = chart.isMultiSelect ? this.selectedDataIndexes[i].point : index.point;\n                        seriesIndex = series.index;\n                        points = series.points;\n                        if (!isNaN(pointIndex) && (pointIndex < points.length)) {\n                            yValue = (series.type !== 'RangeArea' || series.type.indexOf('SplineRangeArea') > -1 || series.type.indexOf('RangeStepArea') > -1) ? points[pointIndex].yValue :\n                                points[pointIndex].regions[0].y;\n                            selectedPointX = points[pointIndex].xValue;\n                            if (chart.primaryXAxis.valueType === 'Category') {\n                                selectedPointX = points[pointIndex].x.toLocaleString();\n                            }\n                            else if (chart.primaryXAxis.valueType === 'DateTime') {\n                                selectedPointX = new Date(points[pointIndex].xValue);\n                            }\n                            if (series.category !== 'Indicator') {\n                                selectedPointValues.push({\n                                    x: selectedPointX, y: yValue, seriesIndex: seriesIndex,\n                                    pointIndex: pointIndex\n                                });\n                            }\n                            if (series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') {\n                                selectedPointValues.push({\n                                    x: selectedPointX, y: points[pointIndex].regions[0].y,\n                                    seriesIndex: seriesIndex, pointIndex: pointIndex\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (selectionMode === 'Series') {\n            if (chart.isMultiSelect) {\n                for (var i = 0; i < this.selectedDataIndexes.length; i++) {\n                    seriesIndex = this.selectedDataIndexes[i].series;\n                    if (this.selectedDataIndexes.length > 0) {\n                        selectedPointValues.push({\n                            seriesIndex: seriesIndex\n                        });\n                    }\n                }\n            }\n            else {\n                seriesIndex = (this.selectedDataIndexes.length > 0) ? this.selectedDataIndexes[0].series :\n                    (this.highlightDataIndexes && this.highlightDataIndexes.length > 0) ? this.highlightDataIndexes[0].series : 0;\n                if (this.selectedDataIndexes.length > 0 || (this.highlightDataIndexes && this.highlightDataIndexes.length > 0)) {\n                    selectedPointValues.push({\n                        seriesIndex: seriesIndex\n                    });\n                }\n            }\n        }\n        else if (selectionMode === 'Point') {\n            var selectedData = [];\n            if (this.styleId.indexOf('highlight') > -1) {\n                selectedData = this.highlightDataIndexes;\n            }\n            else {\n                selectedData = this.selectedDataIndexes;\n            }\n            for (var i = 0; i < selectedData.length; i++) {\n                pointIndex = selectedData[i].point;\n                seriesIndex = selectedData[i].series;\n                var series = chart.series[seriesIndex];\n                points = series.points;\n                if (!isNaN(pointIndex)) {\n                    selectedPointX = points[pointIndex].xValue;\n                    yValue = (series.type !== 'RangeArea' || series.type.indexOf('SplineRangeArea') > -1 || series.type.indexOf('RangeStepArea') > -1) ? points[pointIndex].yValue :\n                        points[pointIndex].regions[0].y;\n                    if (chart.primaryXAxis.valueType === 'Category') {\n                        selectedPointX = points[pointIndex].x.toLocaleString();\n                    }\n                    else if (chart.primaryXAxis.valueType === 'DateTime') {\n                        selectedPointX = new Date(points[pointIndex].xValue);\n                    }\n                    selectedPointValues.push({\n                        x: selectedPointX, y: yValue, seriesIndex: seriesIndex,\n                        pointIndex: pointIndex\n                    });\n                }\n            }\n        }\n        var args = {\n            name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.selectionComplete,\n            selectedDataValues: selectedPointValues,\n            cancel: false,\n            chart: chart\n        };\n        chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.selectionComplete, args);\n    };\n    /**\n     * Handles the selection logic for the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index} index - The index of the selected data point.\n     * @param {Element[]} selectedElements - The elements representing the selected data point.\n     * @returns {void}\n     */\n    Selection.prototype.selection = function (chart, index, selectedElements) {\n        if (!(this.currentMode === 'Lasso')) {\n            if (!chart.isMultiSelect && (this.currentMode.indexOf('Drag') === -1 && this.styleId.indexOf('highlight') === -1 &&\n                chart.selectionMode !== 'None')) {\n                this.removeMultiSelectElements(chart, this.selectedDataIndexes, index, chart.series);\n            }\n        }\n        var indexValue = (this.rangeColorMappingEnabled()) ? 0 : index.series;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(selectedElements[0])) {\n            if (chart.visibleSeries[indexValue].isRectSeries) {\n                if (selectedElements[0].id) {\n                    if (document.getElementById(selectedElements[0].id + '_Symbol')) {\n                        selectedElements.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(selectedElements[0].id + '_Symbol'));\n                    }\n                    else if (selectedElements[0].id.indexOf('SeriesGroup') !== -1) {\n                        if (document.getElementById(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup'))) {\n                            selectedElements.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup')));\n                        }\n                    }\n                }\n            }\n            var isAdd = void 0;\n            var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');\n            className = className.replace('e-chart-focused', '').trim();\n            var pClassName = selectedElements[0].parentNode &&\n                (selectedElements[0].parentNode.getAttribute('class') || '');\n            if (className !== '' && this.currentMode !== 'Cluster') {\n                this.findTrackballElements(selectedElements, className);\n            }\n            if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {\n                this.removeStyles(selectedElements);\n            }\n            else if (selectedElements[0].parentNode && pClassName.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {\n                this.removeStyles([selectedElements[0].parentNode]);\n            }\n            else {\n                this.previousSelectedEle = (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) ? selectedElements : [];\n                this.applyStyles(selectedElements);\n                isAdd = true;\n            }\n            if (this.styleId.indexOf('highlight') > 0 && (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight)) {\n                this.addOrRemoveIndex(this.highlightDataIndexes, index, isAdd);\n            }\n            else {\n                this.addOrRemoveIndex(this.selectedDataIndexes, index, isAdd);\n            }\n        }\n    };\n    /**\n     * Handles the selection logic for clustered data points in the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index} index - The index of the selected clustered data point.\n     * @returns {void}\n     */\n    Selection.prototype.clusterSelection = function (chart, index) {\n        this.selection(chart, index, this.getClusterElements(chart, new _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Index(index.series, index.point)));\n    };\n    /**\n     * Removes the multi-selected elements from the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Index[]} index - The indices of the multi-selected elements to be removed.\n     * @param {Index} currentIndex - The index of the current selected element.\n     * @param {SeriesModel[]} seriesCollection - The collection of series in the chart.\n     * @returns {void}\n     */\n    Selection.prototype.removeMultiSelectElements = function (chart, index, currentIndex, seriesCollection) {\n        var series;\n        for (var i = 0; i < index.length; i++) {\n            series = seriesCollection[index[i].series];\n            if ((this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode)) ||\n                (this.currentMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false)) ||\n                (!this.isSeriesMode && this.toEquals(index[i], currentIndex, true) &&\n                    !this.toEquals(index[i], currentIndex, false))) {\n                this.removeStyles(this.findElements(chart, series, index[i], '', false));\n                if (series.marker.visible) {\n                    this.removeStyles(this.findElements(chart, series, index[i], '', true));\n                }\n                if (series.marker.dataLabel.visible) {\n                    this.removeStyles(this.findElements(chart, series, index[i], '', false, true));\n                }\n                index.splice(i, 1);\n                i--;\n            }\n        }\n    };\n    /**\n     * Applies a blur effect to a specific chart or legend.\n     *\n     * @param {string} chartId - The ID of the chart or legend.\n     * @param {Series[]} visibleSeries - The collection of visible series in the chart.\n     * @param {boolean} isLegend - Indicates whether the blur effect should be applied to a legend. Defaults to false.\n     * @param {number} index - The index of the series or legend item to which the blur effect should be applied. Defaults to 0.\n     * @returns {void}\n     */\n    Selection.prototype.blurEffect = function (chartId, visibleSeries, isLegend, index) {\n        if (isLegend === void 0) { isLegend = false; }\n        if (index === void 0) { index = 0; }\n        var visibility = (this.checkVisibility(this.highlightDataIndexes, this.chart) ||\n            this.checkVisibility(this.selectedDataIndexes, this.chart)); // legend click scenario\n        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n            var series = visibleSeries_1[_i];\n            var legendIndex = void 0;\n            var legendStrokeColor = void 0;\n            if (this.rangeColorMappingEnabled()) {\n                if (isLegend === false) {\n                    legendIndex = Object.keys(series.rangeColorPoints).indexOf(series.points[index].interior);\n                    legendStrokeColor = series.points[index].interior;\n                }\n                else {\n                    legendIndex = index;\n                    legendStrokeColor = document.getElementById(chartId + '_chart_legend_shape_' + index).getAttribute('fill');\n                }\n            }\n            else {\n                legendIndex = series.index;\n                legendStrokeColor = this.chart.visibleSeries[series.index].interior;\n            }\n            if (series.visible) {\n                this.checkSelectionElements((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chartId + 'SeriesGroup' + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);\n                if (series.marker.dataLabel.visible && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series.shapeElement)) {\n                    this.checkSelectionElements(series.shapeElement, this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);\n                    this.checkSelectionElements(series.textElement, this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);\n                }\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chartId + 'SymbolGroup' + series.index))) {\n                    this.checkSelectionElements((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chartId + 'SymbolGroup' + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);\n                }\n            }\n        }\n    };\n    /**\n     * Checks and updates the selection state of elements based on the provided criteria.\n     *\n     * @param {Element} element - The element to check for selection.\n     * @param {string} className - The class name used for selecting elements.\n     * @param {boolean} visibility - The visibility state of the element.\n     * @param {boolean} isLegend - Indicates whether the element is a legend. Defaults to true.\n     * @param {number} series - The index of the series associated with the element. Defaults to 0.\n     * @param {string} legendStrokeColor - The stroke color of the legend. Defaults to '#D3D3D3'.\n     * @returns {void}\n     */\n    Selection.prototype.checkSelectionElements = function (element, className, visibility, isLegend, series, legendStrokeColor) {\n        if (isLegend === void 0) { isLegend = true; }\n        if (series === void 0) { series = 0; }\n        if (legendStrokeColor === void 0) { legendStrokeColor = '#D3D3D3'; }\n        var children = (this.isSeriesMode ?\n            element.childNodes || [element] : element.childNodes || element);\n        if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {\n            children = (element.childNodes || element);\n        }\n        if (this.chart.selectionMode === 'Cluster' && element.tagName.toLowerCase() === 'text' && element.id.indexOf('_Text_') >= 0) {\n            children = [element];\n        }\n        var elementClassName;\n        var parentClassName;\n        var legendShape;\n        var selectElement = element;\n        var isDataLabelTextElement = (this.chart.visibleSeries[this.rangeColorMappingEnabled() ? 0 : series].marker.dataLabel.visible && (element.id.indexOf('Text') > -1 || element.id.indexOf('TextShape') > -1) && element.tagName !== 'g');\n        for (var i = 0; i < children.length && !isDataLabelTextElement; i++) {\n            elementClassName = children[i].getAttribute('class') || '';\n            parentClassName = children[i].parentNode.getAttribute('class') || '';\n            if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {\n                className = elementClassName.indexOf('selection') > 0 ||\n                    elementClassName.indexOf('highlight') > 0 ? elementClassName : className;\n                className = (parentClassName.indexOf('selection') > 0 ||\n                    parentClassName.indexOf('highlight') > 0) ? parentClassName : className;\n            }\n            if (elementClassName.indexOf(className) === -1 &&\n                parentClassName.indexOf(className) === -1 && visibility) {\n                this.addSvgClass(children[i], this.unselected);\n            }\n            else {\n                selectElement = children[i];\n                this.removeSvgClass(children[i], this.unselected);\n                this.removeSvgClass(children[i].parentNode, this.unselected);\n                if (children[i].id !== '' && elementClassName.indexOf(this.unselected) !== -1 && parentClassName.indexOf(className) === -1) {\n                    this.highlightAnimation(children[i], this.chart.series.length === 1 ? 0 :\n                        this.indexFinder(children[i].id).series, 700, 0.3);\n                }\n            }\n            if (children[i].id.indexOf('Trackball') > 0 && selectElement.classList[0] === className) {\n                this.removeSvgClass(children[i], this.unselected);\n                this.removeSvgClass(children[i].parentNode, this.unselected);\n                this.addSvgClass(children[i], className);\n            }\n        }\n        if (element.id.indexOf('Symbol') > -1) {\n            if ((element.querySelectorAll('.' + className)[0]) && element.querySelectorAll('.' + className)[0].getAttribute('class')\n                === className) {\n                var symbolEle = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.control.element.id + '_Series_' + element.id[element.id.length - 1]);\n                var seriesClassName = symbolEle && symbolEle.hasAttribute('class') ? symbolEle.getAttribute('class') : '';\n                if (seriesClassName.indexOf(this.unselected) > -1) {\n                    this.removeSvgClass(symbolEle, this.unselected);\n                }\n            }\n        }\n        if (this.control.legendModule && this.control.legendSettings.visible && this.control.legendSettings.visible\n            && !(isLegend && this.rangeColorMappingEnabled && (element === this.control.visibleSeries[0].textElement\n                || element === this.control.visibleSeries[0].shapeElement))) {\n            legendShape = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.control.element.id + '_chart_legend_shape_' + series);\n            if (legendShape) {\n                if (legendShape.hasAttribute('class')) {\n                    this.removeSvgClass(legendShape, legendShape.getAttribute('class'));\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor && this.chart.highlightColor !== '') && !this.chart.legendSettings.enableHighlight) {\n                        legendShape.setAttribute('stroke', legendStrokeColor);\n                        if (this.chart.highlightPattern === 'None') {\n                            legendShape.setAttribute('fill', legendStrokeColor);\n                        }\n                    }\n                }\n                elementClassName = selectElement.getAttribute('class') || '';\n                parentClassName = selectElement.parentNode.getAttribute('class') || '';\n                if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {\n                    this.addSvgClass(legendShape, (this.chart.highlightMode === 'None' && this.chart.legendSettings.enableHighlight && (!this.chart.selectionModule || this.chart.selectionModule.selectedDataIndexes.length === 0)) ? className : this.unselected);\n                    this.removeSvgClass(legendShape, className);\n                    if (this.chart.highlightColor !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor)) {\n                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);\n                        if (this.chart.highlightPattern === 'None') {\n                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);\n                        }\n                    }\n                }\n                else {\n                    this.removeSvgClass(legendShape, this.unselected);\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor) && this.chart.highlightColor !== '') {\n                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);\n                        if (this.chart.highlightPattern === 'None') {\n                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);\n                        }\n                    }\n                    if ((elementClassName === '' && parentClassName === '') || elementClassName.trim() === 'EJ2-Trackball') {\n                        this.removeSvgClass(legendShape, className);\n                    }\n                    else {\n                        this.addSvgClass(legendShape, className);\n                        if (className.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && this.chart.highlightColor !== 'transparent' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor)) {\n                            legendShape.setAttribute('stroke', this.chart.highlightColor);\n                            if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightPattern === 'None') {\n                                legendShape.setAttribute('fill', this.chart.highlightColor);\n                            }\n                        }\n                    }\n                }\n                var legendItemsId = void 0;\n                if (this.rangeColorMappingEnabled()) {\n                    for (var i = 0; i < this.chart.rangeColorSettings.length; i++) {\n                        legendItemsId = document.getElementById(this.chart.element.id + '_chart_legend_shape_' + i);\n                        if (legendShape !== legendItemsId) {\n                            this.addSvgClass(legendItemsId, this.unselected);\n                            this.removeSvgClass(legendItemsId, className);\n                        }\n                        else if (isLegend === true) {\n                            this.addSvgClass(legendItemsId, className);\n                        }\n                        if (elementClassName.indexOf(className) === -1 && isLegend === false) {\n                            this.removeSvgClass(legendItemsId, this.unselected);\n                        }\n                    }\n                }\n                if (isLegend && parentClassName.indexOf(className) > -1) {\n                    this.addSvgClass(legendShape, className);\n                }\n            }\n        }\n    };\n    /**\n     * Applies styles to the specified elements.\n     *\n     * @param {Element[]} elements - The elements to which styles will be applied.\n     * @returns {void}\n     */\n    Selection.prototype.applyStyles = function (elements) {\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n            var element = elements_1[_i];\n            if (element) {\n                this.removeSvgClass(element.parentNode, this.unselected);\n                this.removeSvgClass(element, this.unselected);\n                if (this.chart.series[0].pointColorMapping === 'fill' || this.rangeColorMappingEnabled()) {\n                    var className = this.getSelectionClass(element.id);\n                    var index = className.indexOf('highlight') > -1 ? parseInt(className.split(this.chart.element.id + '_ej2_chart_highlight_series_')[1], 10) : parseInt(className.split(this.chart.element.id + '_ej2_chart_selection_series_')[1], 10);\n                    var patternName = this.styleId.indexOf('highlight') > 0 ? this.chart.highlightPattern : this.chart.selectionPattern;\n                    var pattern = void 0;\n                    if (className.indexOf('highlight') > -1 || className.indexOf('selection') > -1) {\n                        pattern = document.getElementById(this.chart.element.id + '_' + patternName + '_' + 'Selection' + '_' + index);\n                    }\n                    if (element.id.indexOf('legend') === -1 && element.id.indexOf('Text') === -1 && element.id.indexOf('TextShape') === -1 && element.id.indexOf('Group') === -1 && pattern != null) {\n                        for (var i = 1; i < pattern.children.length; i++) {\n                            pattern.children[i].setAttribute('fill', element.getAttribute('fill'));\n                            pattern.children[i].setAttribute('stroke', element.getAttribute('fill'));\n                        }\n                    }\n                }\n                this.addSvgClass(element, this.getSelectionClass(element.id));\n                if (element.id.indexOf('Group') > 0) {\n                    var seriesIndex = this.indexFinder(element.id);\n                    for (var i = 0; i < element.children.length; i++) {\n                        if (element.children[i].nodeName !== 'defs') {\n                            this.stopElementAnimation(element.children[i], seriesIndex.series);\n                        }\n                    }\n                }\n                if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor) && this.chart.highlightPattern === 'None' && this.chart.highlightColor !== 'transparent') {\n                    if (element.id.indexOf('Group') > 0) {\n                        for (var i = 0; i < element.children.length; i++) {\n                            element.children[i].setAttribute('fill', (element.id.indexOf('Text') > -1\n                                || element.id.indexOf('TextShape') > -1) ? element.children[i].getAttribute('fill')\n                                : this.chart.highlightColor);\n                        }\n                    }\n                    else {\n                        element.setAttribute('fill', (element.id.indexOf('Text') > -1\n                            || element.id.indexOf('TextShape') > -1) ? element.getAttribute('fill')\n                            : this.chart.highlightColor);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Gets the CSS class for selection based on the provided identifier.\n     *\n     * @param {string} id - The identifier used to determine the selection class.\n     * @returns {string} - The CSS class for selection.\n     */\n    Selection.prototype.getSelectionClass = function (id) {\n        return this.generateStyle(this.control.visibleSeries[this.indexFinder(id).series]);\n    };\n    /**\n     * Removes styles from the provided elements.\n     *\n     * @param {Element[]} elements - The elements from which styles will be removed.\n     * @returns {void}\n     */\n    Selection.prototype.removeStyles = function (elements) {\n        for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {\n            var element = elements_2[_i];\n            if (element) {\n                this.removeSvgClass(element, this.getSelectionClass(element.id));\n                if (this.chart.highlightPattern === 'None' && this.chart.highlightColor !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor) && this.chart.highlightColor !== 'transparent') {\n                    if (element.id.indexOf('Group') > 0) {\n                        for (var i = 0; i < element.children.length; i++) {\n                            element.children[i].setAttribute('fill', (element.id.indexOf('Text') > -1\n                                || element.id.indexOf('TextShape') > -1) ? element.children[i].getAttribute('fill')\n                                : this.control.visibleSeries[this.indexFinder(element.id).series].interior);\n                        }\n                    }\n                    else {\n                        element.setAttribute('fill', (element.id.indexOf('Text') > -1\n                            || element.id.indexOf('TextShape') > -1) ? element.getAttribute('fill')\n                            : this.control.visibleSeries[this.indexFinder(element.id).series].interior);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Adds or removes an index from the provided array of indexes.\n     *\n     * @param {Index[]} indexes - The array of indexes.\n     * @param {Index} index - The index to add or remove.\n     * @param {boolean} [isAdd] - Optional parameter to specify whether to add or remove the index. Defaults to true (add).\n     * @returns {void}\n     */\n    Selection.prototype.addOrRemoveIndex = function (indexes, index, isAdd) {\n        for (var i = 0; i < indexes.length; i++) {\n            if (this.toEquals(indexes[i], index, this.isSeriesMode)) {\n                indexes.splice(i, 1);\n                i--;\n            }\n        }\n        if (isAdd) {\n            indexes.push(index);\n        }\n    };\n    /**\n     * Checks if two Index objects are equal.\n     *\n     * @param {Index} first - The first Index object.\n     * @param {Index} second - The second Index object.\n     * @param {boolean} checkSeriesOnly - Specifies whether to check series properties only.\n     * @returns {boolean} - True if the two Index objects are equal, otherwise false.\n     */\n    Selection.prototype.toEquals = function (first, second, checkSeriesOnly) {\n        return ((first.series === second.series || (this.currentMode === 'Cluster' && !checkSeriesOnly))\n            && (checkSeriesOnly || (first.point === second.point)));\n    };\n    /**\n     * Redraws the selection or highlight on the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {SelectionMode | HighlightMode} oldMode - The previous selection or highlight mode.\n     * @param {boolean} chartRedraw - Specifies whether to redraw the entire chart.\n     * @returns {void}\n     */\n    Selection.prototype.redrawSelection = function (chart, oldMode, chartRedraw) {\n        this.isSeriesMode = oldMode === 'Series';\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(oldMode)) {\n            if (oldMode.indexOf('Drag') !== -1 || oldMode === 'Lasso' || chartRedraw) {\n                chart.isRedrawSelection = false;\n            }\n            else {\n                chart.isRedrawSelection = true;\n            }\n        }\n        var selectedDataIndexes = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selectedDataIndexes, null, true);\n        var highlightDataIndexes = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.highlightDataIndexes, null, true);\n        if (this.styleId.indexOf('highlight') > 0 && highlightDataIndexes.length > 0) {\n            this.removeSelectedElements(chart, this.highlightDataIndexes, chart.series);\n            selectedDataIndexes = highlightDataIndexes;\n        }\n        else {\n            this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);\n        }\n        this.blurEffect(chart.element.id, chart.visibleSeries, false);\n        this.selectDataIndex(chart, selectedDataIndexes);\n    };\n    /**\n     * Handles selection on legend item click.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {number} series - The index of the series.\n     * @param {Element} targetElement - The target element clicked.\n     * @param {string} eventType - The type of event triggered.\n     * @returns {void}\n     */\n    Selection.prototype.legendSelection = function (chart, series, targetElement, eventType) {\n        if (eventType === 'mousemove') {\n            if (targetElement.id.indexOf('text') > 1) {\n                targetElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(targetElement.id.replace('text', 'shape'));\n            }\n            if (targetElement.id.indexOf('marker') > 1) {\n                targetElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(targetElement.id.replace('_marker', ''));\n            }\n            if (targetElement.id.indexOf('g') > 1) {\n                targetElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(targetElement.id.replace('_g_', '_shape_'));\n            }\n            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||\n                targetElement.getAttribute('class').indexOf('selection') > -1)) {\n                return;\n            }\n            this.currentMode = this.chart.highlightMode;\n        }\n        var isPreSelected = this.isAlreadySelected(targetElement, eventType);\n        if (isPreSelected) {\n            var seriesStyle = this.generateStyle(chart.visibleSeries[series]);\n            var selectedElements = (document.querySelectorAll('.' + seriesStyle));\n            this.isSeriesMode = this.currentMode === 'Series';\n            var isBlurEffectNeeded = true;\n            if (selectedElements.length > 0) {\n                this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);\n            }\n            else {\n                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                    var element = _a[_i];\n                    if (element.index !== series && !chart.isMultiSelect) {\n                        seriesStyle = this.generateStyle(chart.visibleSeries[element.index]);\n                        selectedElements = document.querySelectorAll('.' + seriesStyle);\n                        this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);\n                    }\n                }\n                var seriesElements = [];\n                if (this.rangeColorMappingEnabled()) {\n                    for (var i = 0, a = chart.visibleSeries[0].seriesElement.children; i < a.length; i++) {\n                        var point = a[i];\n                        if (targetElement.getAttribute('fill') === point.getAttribute('fill')) {\n                            if (chart.visibleSeries[0].marker.dataLabel.visible) {\n                                var pointIndex = this.indexFinder(point.id).point;\n                                if (!isNaN(pointIndex) && pointIndex >= 0) {\n                                    var dataLabel = document.getElementById(this.chart.element.id + \"_Series_0_Point_\" + pointIndex + \"_Text_0\");\n                                    var dataLabelBorder = document.getElementById(this.chart.element.id + \"_Series_0_Point_\" + pointIndex + \"_TextShape_0\");\n                                    if (dataLabel) {\n                                        seriesElements.push(dataLabel);\n                                    }\n                                    if (dataLabelBorder) {\n                                        seriesElements.push(dataLabelBorder);\n                                    }\n                                }\n                            }\n                            seriesElements.push(point);\n                        }\n                    }\n                    for (var _b = 0, seriesElements_1 = seriesElements; _b < seriesElements_1.length; _b++) {\n                        var element = seriesElements_1[_b];\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(element)) {\n                            return;\n                        }\n                        this.checkSelectionElements(element, seriesStyle, false, true, series);\n                    }\n                }\n                else {\n                    if (chart.visibleSeries[series].visible) {\n                        seriesElements = this.getSeriesElements(chart.visibleSeries[series]);\n                        for (var _c = 0, seriesElements_2 = seriesElements; _c < seriesElements_2.length; _c++) {\n                            var seriesElement = seriesElements_2[_c];\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesElement)) {\n                                return;\n                            }\n                            this.checkSelectionElements(seriesElement, seriesStyle, false, true, series);\n                        }\n                    }\n                }\n                this.isSeriesMode = true;\n                this.selection(chart, new _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Index(series, NaN), seriesElements);\n                this.isSeriesMode = chart.selectionMode === 'Series';\n                this.blurEffect(chart.element.id, chart.visibleSeries, true, series);\n            }\n        }\n    };\n    /**\n     * Checks if range color mapping is enabled for the chart.\n     *\n     * @returns {boolean} - Returns true if range color mapping is enabled, otherwise false.\n     */\n    Selection.prototype.rangeColorMappingEnabled = function () {\n        if ((this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 &&\n            this.chart.rangeColorSettings[0].colors.length > 0 &&\n            (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||\n                this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble'))) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Selection.prototype.removeSelection = function (chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {\n        if (selectedElements.length > 0) {\n            var elements = [];\n            for (var i = 0; i < selectedElements.length; i++) {\n                elements.push(selectedElements[i]);\n            }\n            this.removeStyles(elements);\n            this.isSeriesMode = true;\n            this.addOrRemoveIndex(this.selectedDataIndexes, new _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Index(series, NaN));\n            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                var value = _a[_i];\n                seriesStyle = this.generateStyle(value);\n                if (document.querySelectorAll('.' + seriesStyle).length > 0) {\n                    for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {\n                        var element = elements_3[_b];\n                        this.checkSelectionElements(element, seriesStyle, true, true, series);\n                    }\n                    isBlurEffectNeeded = false;\n                    break;\n                }\n            }\n            if (isBlurEffectNeeded) {\n                this.isSeriesMode = chart.selectionMode === 'Series';\n                this.blurEffect(chart.element.id, chart.visibleSeries);\n            }\n        }\n    };\n    /**\n     * Retrieves the SVG elements associated with a particular series in the chart.\n     *\n     * @param {SeriesModel} series - The series for which to retrieve the SVG elements.\n     * @returns {Element[]} - An array of SVG elements representing the series.\n     */\n    Selection.prototype.getSeriesElements = function (series) {\n        var seriesElements = [series.seriesElement];\n        if (series.marker.visible && series.type !== 'Scatter' && series.type !== 'Bubble' && !series.isRectSeries) {\n            seriesElements.push(series.symbolElement);\n        }\n        else if (series.marker.visible && series.isRectSeries) {\n            seriesElements.push(series.symbolElement);\n        }\n        if (series.marker.dataLabel.visible) {\n            seriesElements.push(series.textElement);\n            seriesElements.push(series.shapeElement);\n        }\n        return seriesElements;\n    };\n    /**\n     * Finds the index associated with a particular element ID.\n     *\n     * @param {string} id - The ID of the element to find the index for.\n     * @returns {Index} - The index associated with the element ID.\n     */\n    Selection.prototype.indexFinder = function (id) {\n        var ids = ['NaN', 'NaN'];\n        if (id.indexOf('SeriesGroup') > -1) {\n            ids = id.split('SeriesGroup');\n            ids[0] = ids[1];\n        }\n        else if (id.indexOf('SymbolGroup') > -1) {\n            ids = id.split('SymbolGroup');\n            ids[0] = ids[1];\n        }\n        else if (id.indexOf('_Point_') > -1) {\n            ids = id.split('_Series_')[1].split('_Point_');\n        }\n        else if (id.indexOf('_border_') > -1) {\n            ids[0] = id.split('_border_')[1];\n        }\n        else if (id.indexOf('_Series_') > -1) {\n            ids[0] = id.split('_Series_')[1];\n        }\n        else if (id.indexOf('_chart_legend_shape_') > -1) {\n            ids = id.split('_chart_legend_shape_');\n            ids[0] = ids[1];\n        }\n        else if (id.indexOf('TextGroup') > -1) {\n            ids = id.split('TextGroup');\n            ids[0] = ids[1];\n        }\n        else if (id.indexOf('ShapeGroup') > -1) {\n            ids = id.split('ShapeGroup');\n            ids[0] = ids[1];\n        }\n        return new _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Index(parseInt(ids[0], 10), parseInt(ids[1], 10));\n    };\n    /**\n     * Calculates the elements selected by dragging a rectangle on the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Rect} dragRect - The rectangle representing the selection area.\n     * @param {boolean} isClose - Flag indicating whether the selection should be close.\n     * @returns {void}\n     */\n    Selection.prototype.calculateDragSelectedElements = function (chart, dragRect, isClose) {\n        this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);\n        var isLasso = chart.selectionMode === 'Lasso';\n        var rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);\n        var axisOffset = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(chart.chartAxisLayoutPanel.seriesClipRect.x, chart.chartAxisLayoutPanel.seriesClipRect.y);\n        this.removeOffset(rect, axisOffset);\n        var points;\n        var index;\n        var selectedPointValues = [];\n        var selectedSeriesValues = [];\n        this.isSeriesMode = false;\n        var isDragResize = (chart.allowMultiSelection) && (this.rectGrabbing || this.resizing);\n        this.rectPoints = this.dragRectArray[isDragResize ? this.targetIndex : this.count] =\n            new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);\n        if (dragRect.width && dragRect.height && !isClose) {\n            var rt = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);\n            this.removeOffset(rt, axisOffset);\n            this.filterArray[isDragResize ? this.targetIndex : this.count] = rt;\n        }\n        var _loop_1 = function (series) {\n            if (series.visible) {\n                points = series.points;\n                selectedPointValues = [];\n                var xAxisOffset_1;\n                var yAxisOffset_1;\n                if ((chart.isTransposed || series.type.indexOf('Bar') !== -1) &&\n                    !(chart.isTransposed && series.type.indexOf('Bar') !== -1)) {\n                    xAxisOffset_1 = series.xAxis.rect.y - axisOffset.y;\n                    yAxisOffset_1 = series.yAxis.rect.x - axisOffset.x;\n                }\n                else {\n                    xAxisOffset_1 = series.xAxis.rect.x - axisOffset.x;\n                    yAxisOffset_1 = series.yAxis.rect.y - axisOffset.y;\n                }\n                for (var j = 0; j < points.length; j++) {\n                    var yValue = (series.type !== 'RangeArea' || series.type.indexOf('SplineRangeArea') > -1 || series.type.indexOf('RangeStepArea') > -1) ? points[j].yValue :\n                        points[j].regions[0].y;\n                    var isCurrentPoint = void 0;\n                    var selectedPointX = points[j].xValue;\n                    if (chart.primaryXAxis.valueType === 'Category') {\n                        selectedPointX = points[j].x.toLocaleString();\n                    }\n                    else if (chart.primaryXAxis.valueType === 'DateTime') {\n                        selectedPointX = new Date(points[j].xValue);\n                    }\n                    if (series.type === 'BoxAndWhisker') {\n                        isCurrentPoint = points[j].regions.some(function (region) {\n                            return (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(region.x + xAxisOffset_1, region.y + yAxisOffset_1, rect);\n                        });\n                    }\n                    else {\n                        if (chart.selectionMode === 'Lasso') {\n                            isCurrentPoint = points[j].isSelect;\n                        }\n                        else {\n                            isCurrentPoint = (chart.allowMultiSelection) ?\n                                this_1.isPointSelect(points[j], xAxisOffset_1, yAxisOffset_1, this_1.filterArray) :\n                                points[j].symbolLocations.some(function (location) {\n                                    return location && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(location.x + xAxisOffset_1, location.y + yAxisOffset_1, rect);\n                                });\n                        }\n                    }\n                    if (isCurrentPoint && series.category !== 'Indicator') {\n                        index = new _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Index(series.index, points[j].index);\n                        this_1.selection(chart, index, this_1.findElements(chart, series, index, '', !series.isRectSeries ? series.marker.visible : false));\n                        selectedPointValues.push({ x: selectedPointX, y: yValue });\n                    }\n                    if (isCurrentPoint && (series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea')) {\n                        selectedPointValues.push({ x: selectedPointX, y: points[j].regions[0].y });\n                    }\n                }\n                selectedSeriesValues.push(selectedPointValues);\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n            var series = _a[_i];\n            _loop_1(series);\n        }\n        this.blurEffect(chart.element.id, chart.visibleSeries);\n        var x = isLasso ? chart.mouseDownX : (dragRect.x + dragRect.width);\n        var y = isLasso ? chart.mouseDownY : dragRect.y;\n        if (!isClose) {\n            this.createCloseButton(x, y);\n        }\n        var args = {\n            name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.dragComplete,\n            selectedDataValues: selectedSeriesValues,\n            cancel: false\n        };\n        chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.dragComplete, args);\n    };\n    Selection.prototype.removeOffset = function (rect, clip) {\n        rect.x -= clip.x;\n        rect.y -= clip.y;\n    };\n    Selection.prototype.isPointSelect = function (points, xAxisOffset, yAxisOffset, rectCollection) {\n        var location = points.symbolLocations[0];\n        for (var _i = 0, rectCollection_1 = rectCollection; _i < rectCollection_1.length; _i++) {\n            var rect = rectCollection_1[_i];\n            if (rect && location && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(location.x + xAxisOffset, location.y + yAxisOffset, rect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Draws the dragging rectangle on the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Rect} dragRect - The rectangle representing the dragging area.\n     * @returns {void}\n     */\n    Selection.prototype.drawDraggingRect = function (chart, dragRect) {\n        var cartesianLayout = chart.chartAxisLayoutPanel.seriesClipRect;\n        var border = chart.chartArea.border.width;\n        var rectFill = chart.themeStyle.selectionRectFill;\n        var rectStroke = chart.themeStyle.selectionRectStroke;\n        var isLasso = chart.selectionMode === 'Lasso';\n        if (this.isdrawRect) {\n            cartesianLayout.x = cartesianLayout.x - border / 2;\n            cartesianLayout.y = cartesianLayout.y - border / 2;\n            cartesianLayout.width = cartesianLayout.width + border;\n            cartesianLayout.height = cartesianLayout.height + border;\n            this.isdrawRect = false;\n        }\n        switch (chart.selectionMode) {\n            case 'DragX':\n                dragRect.y = cartesianLayout.y;\n                dragRect.height = cartesianLayout.height;\n                break;\n            case 'DragY':\n                dragRect.x = cartesianLayout.x;\n                dragRect.width = cartesianLayout.width;\n                break;\n        }\n        if ((dragRect.width < 5 || dragRect.height < 5) && !isLasso) {\n            return null;\n        }\n        var isDragMode = chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode === 'Lasso';\n        if ((chart.allowMultiSelection) && isDragMode) {\n            var element = void 0;\n            var dragGroup = void 0;\n            var multiGroup = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.multiRectGroup);\n            if (!multiGroup) {\n                multiGroup = chart.svgRenderer.createGroup({ id: this.multiRectGroup });\n                chart.svgObject.appendChild(multiGroup);\n            }\n            if (this.rectGrabbing || this.resizing) {\n                var rectElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRect + this.targetIndex);\n                if (rectElement.nextSibling) {\n                    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(rectElement.nextSibling);\n                }\n                this.setAttributes(rectElement, dragRect);\n            }\n            else if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRectGroup + this.count)) {\n                dragGroup = chart.svgRenderer.createGroup({ id: this.draggedRectGroup + this.count });\n                var svgElement = document.getElementById(chart.element.id + '_series_svg');\n                if (chart.enableCanvas) {\n                    svgElement.appendChild(dragGroup);\n                }\n                else {\n                    multiGroup.appendChild(dragGroup);\n                }\n                // chart.enableCanvas ? svgElement.appendChild(dragGroup) : multiGroup.appendChild(dragGroup);\n            }\n            if (!(chart.selectionMode === 'Lasso')) {\n                element = chart.svgRenderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.RectOption(this.draggedRect + this.count, rectFill, { color: rectStroke, width: 1 }, 1, dragRect, 0, 0, '', chart.theme.indexOf('Fluent2') < 1 ? '3' : ''));\n                element.style.cursor = 'move';\n            }\n            else {\n                element = chart.svgRenderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.lassoPath + this.count, rectFill, 3, rectStroke, 1, '', this.path));\n            }\n            if (!dragGroup && !this.rectGrabbing && !this.resizing) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRectGroup + this.count).appendChild(element);\n            }\n            else if (!this.rectGrabbing && !this.resizing) {\n                dragGroup.appendChild(element);\n            }\n        }\n        else {\n            var element = isLasso ?\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.lassoPath) : (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRect);\n            if (this.closeIcon) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(this.closeIconId);\n            }\n            if (element) {\n                if (isLasso) {\n                    element.setAttribute('d', this.path);\n                }\n                else {\n                    this.setAttributes(element, dragRect);\n                }\n            }\n            else {\n                var dragGroup = chart.svgRenderer.createGroup({ id: this.draggedRectGroup });\n                var svgElement = document.getElementById(chart.element.id + '_series_svg');\n                if (chart.enableCanvas) {\n                    svgElement.appendChild(dragGroup);\n                }\n                else {\n                    chart.svgObject.appendChild(dragGroup);\n                }\n                // chart.enableCanvas ? svgElement.appendChild(dragGroup) : chart.svgObject.appendChild(dragGroup);\n                if (!(chart.selectionMode === 'Lasso')) {\n                    element = chart.svgRenderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.RectOption(this.draggedRect, rectFill, { color: rectStroke, width: 1 }, 1, dragRect, 0, 0, '', chart.theme.indexOf('Fluent2') < 1 ? '3' : ''));\n                }\n                else {\n                    element = chart.svgRenderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.lassoPath, rectFill, 3, rectStroke, 1, '', this.path));\n                }\n                //element.setAttribute('style', 'cursor:move;');\n                dragGroup.appendChild(element);\n            }\n        }\n    };\n    /**\n     * Retrieves the index of a particular item based on its identifier.\n     *\n     * @param {string} id - The identifier of the item.\n     * @returns {number} - The index of the item, or -1 if not found.\n     */\n    Selection.prototype.getIndex = function (id) {\n        var i;\n        for (i = id.length - 1; i > 0; i--) {\n            var x = Number(id[i]);\n            if (!isNaN(x)) {\n                continue;\n            }\n            else {\n                break;\n            }\n        }\n        var index = +id.substr(i + 1, id.length - 1);\n        return index;\n    };\n    Selection.prototype.createCloseButton = function (x, y) {\n        var isMultiDrag = this.chart.allowMultiSelection;\n        var circleStroke = this.chart.themeStyle.selectionCircleStroke;\n        var isDrag = this.rectGrabbing || this.resizing;\n        var closeIcon = this.chart.svgRenderer.createGroup({\n            id: this.closeIconId + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''),\n            style: 'cursor:pointer; visibility: visible;'\n        });\n        closeIcon.appendChild(this.chart.svgRenderer.drawCircle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.CircleOption(this.closeIconId + '_circle' + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''), '#FFFFFF', { color: circleStroke, width: 1 }, 1, x, y, 10)));\n        var direction = 'M ' + (x - 4) + ' ' + (y - 4) + ' L ' + (x + 4) + ' ' + (y + 4) + ' M ' + (x - 4) + ' ' + (y + 4) +\n            ' L ' + (x + 4) + ' ' + (y - 4);\n        closeIcon.appendChild(this.chart.svgRenderer.drawPath({\n            id: this.closeIconId + '_cross' +\n                (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''), d: direction,\n            stroke: circleStroke, 'stroke-width': 2, fill: circleStroke\n        }));\n        this.closeIcon = closeIcon;\n        var pathElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRectGroup + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''));\n        if (pathElement) {\n            pathElement.appendChild(closeIcon);\n        }\n    };\n    /**\n     * Method to remove dragged element.\n     *\n     * @returns {void}\n     * @private\n     */\n    Selection.prototype.removeDraggedElements = function (chart, targetElement, eventType) {\n        if ((targetElement.id && targetElement.id.indexOf(this.closeIconId) > -1) && (eventType.indexOf('move') === -1)) {\n            var isSelectedvalues = true;\n            if ((chart.allowMultiSelection)) {\n                var index = this.getIndex(targetElement.id);\n                var multiRectGroupElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.multiRectGroup);\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRectGroup + index));\n                this.dragRectArray[index] = null;\n                this.filterArray[index] = null;\n                this.totalSelectedPoints[index] = null;\n                if (multiRectGroupElement && multiRectGroupElement.childElementCount === 0) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(multiRectGroupElement);\n                    this.dragRectArray = [];\n                    this.filterArray = [];\n                    this.totalSelectedPoints = [];\n                }\n                if (this.currentMode === 'Lasso') {\n                    if (this.multiDataIndexes[index] != null) {\n                        for (var i = 0; i < this.multiDataIndexes[index].length; i++) {\n                            this.multiDataIndexes[index][i].isSelect = false;\n                        }\n                    }\n                    this.multiDataIndexes[index] = null;\n                    for (var j = 0; j < this.multiDataIndexes.length; j++) {\n                        if (this.multiDataIndexes[j] != null) {\n                            isSelectedvalues = false;\n                            for (var k = 0; k < this.multiDataIndexes[j].length; k++) {\n                                this.multiDataIndexes[j][k].isSelect = true;\n                            }\n                        }\n                    }\n                    this.calculateDragSelectedElements(chart, this.dragRect, true);\n                }\n                else if (this.filterArray.length) {\n                    for (var i = 0; i < this.filterArray.length; i++) {\n                        if (this.filterArray[i]) {\n                            isSelectedvalues = false;\n                            this.calculateDragSelectedElements(chart, this.filterArray[i], true);\n                        }\n                    }\n                }\n                else {\n                    this.calculateDragSelectedElements(chart, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0), true);\n                }\n            }\n            else {\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.draggedRectGroup));\n                this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);\n            }\n            this.blurEffect(chart.element.id, chart.visibleSeries);\n            this.changeCursorStyle(false, chart.svgObject, 'auto');\n            if (!(chart.allowMultiSelection) || isSelectedvalues) {\n                this.rectPoints = null;\n            }\n        }\n    };\n    /**\n     * Updates the selection rectangle during resizing.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {ChartLocation} location - The location of the resizing action.\n     * @param {boolean} [tapped=false] - Indicates whether the resizing action was initiated by tapping.\n     * @param {Element} [target] - The target element of the resizing action.\n     * @returns {void}\n     */\n    Selection.prototype.resizingSelectionRect = function (chart, location, tapped, target) {\n        var rect;\n        if (((chart.allowMultiSelection) && (target.id.indexOf('_ej2_drag_rect') > -1)) ||\n            this.dragRectArray[this.targetIndex]) {\n            if (target.id.indexOf('_ej2_drag_rect') > -1) {\n                this.targetIndex = this.getIndex(target.id);\n            }\n            var r = this.dragRectArray[this.targetIndex];\n            rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(r.x, r.y, r.width, r.height);\n        }\n        if (!(chart.allowMultiSelection)) {\n            rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);\n        }\n        if (rect) {\n            var resize = this.findResizeMode(chart.svgObject, rect, location);\n            if (this.resizing) {\n                rect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getDraggedRectLocation)(rect.x, rect.y, (rect.x + rect.width), (rect.y + rect.height), chart.chartAxisLayoutPanel.seriesClipRect);\n                this.drawDraggingRect(chart, rect);\n                this.dragRect = rect;\n            }\n            if (tapped) {\n                this.resizing = resize;\n            }\n        }\n        else {\n            return;\n        }\n    };\n    Selection.prototype.findResizeMode = function (chartSvgObject, rect, location) {\n        var cursorStyle = 'se-resize';\n        var resize = false;\n        if (!this.resizing) {\n            var resizeEdges = [new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(rect.x, (rect.y), rect.width - 5, 5),\n                new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect((rect.x), rect.y, 5, rect.height),\n                new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(rect.x, (rect.y + rect.height - 5), rect.width - 5, 5),\n                new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect((rect.x + rect.width - 5), rect.y + 5, 5, rect.height - 15),\n                new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect((rect.x + rect.width - 10), (rect.y + rect.height - 10), 10, 10)]; //corner\n            for (var i = 0; i < resizeEdges.length; i++) {\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(location.x, location.y, resizeEdges[i])) {\n                    cursorStyle = (i === 4) ? cursorStyle : (i % 2 === 0) ? 'ns-resize' : 'ew-resize';\n                    resize = true;\n                    this.resizeMode = i;\n                    break;\n                }\n            }\n        }\n        else {\n            var x = rect.x;\n            var y = rect.y;\n            var width = (location.x - x);\n            var height = (location.y - y);\n            switch (this.resizeMode) {\n                case 0:\n                    height = Math.abs((rect.height + rect.y) - location.y);\n                    rect.y = Math.min((rect.height + rect.y), location.y);\n                    rect.height = height;\n                    break;\n                case 1:\n                    width = Math.abs((rect.width + rect.x) - location.x);\n                    rect.x = Math.min((rect.width + rect.x), location.x);\n                    rect.width = width;\n                    break;\n                case 2:\n                    rect.height = Math.abs(height);\n                    rect.y = Math.min(location.y, y);\n                    break;\n                case 3:\n                    rect.width = Math.abs(width);\n                    rect.x = Math.min(location.x, x);\n                    break;\n                case 4:\n                    rect.width = Math.abs(width);\n                    rect.height = Math.abs(height);\n                    rect.x = Math.min(location.x, x);\n                    rect.y = Math.min(location.y, y);\n                    break;\n            }\n        }\n        if (this.currentMode !== 'Lasso') {\n            this.changeCursorStyle(resize, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)((this.chart.allowMultiSelection) ? this.draggedRect +\n                this.targetIndex : this.draggedRect), cursorStyle);\n        }\n        this.changeCursorStyle(resize, chartSvgObject, cursorStyle);\n        return resize;\n    };\n    Selection.prototype.changeCursorStyle = function (isResize, rectelement, cursorStyle) {\n        cursorStyle = isResize ? cursorStyle : (this.control.svgObject === rectelement) ? 'auto' : 'move';\n        if (rectelement) {\n            rectelement.style.cursor = cursorStyle;\n        }\n    };\n    Selection.prototype.removeSelectedElements = function (chart, index, seriesCollection) {\n        index = chart.isRedrawSelection ? index : index.splice(0, index.length); // No need to remove selected indexes while redrawing\n        var seriesElements;\n        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n            var series = seriesCollection_1[_i];\n            if (series.visible) {\n                seriesElements = this.getSeriesElements(series);\n                this.removeStyles(seriesElements);\n                for (var _a = 0, seriesElements_3 = seriesElements; _a < seriesElements_3.length; _a++) {\n                    var seriesElement = seriesElements_3[_a];\n                    this.removeStyles(this.getChildren(seriesElement));\n                }\n            }\n        }\n    };\n    Selection.prototype.setAttributes = function (ele, object) {\n        var keys = Object.keys(object);\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            ele.setAttribute(key, object[key]);\n        }\n    };\n    /**\n     * Updates the position of the dragged rectangle.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Rect} grabbedPoint - The rectangle representing the grabbed point.\n     * @param {boolean} [doDrawing=false] - Indicates whether to redraw the dragging rectangle.\n    //  * @param {Element} [target] - The target element related to the dragging action.\n     * @returns {void}\n     */\n    Selection.prototype.draggedRectMoved = function (chart, grabbedPoint, doDrawing) {\n        var rect;\n        if ((this.resizing || this.rectGrabbing) && (chart.allowMultiSelection)) {\n            var r = this.dragRectArray[this.targetIndex];\n            rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(r.x, r.y, r.width, r.height);\n        }\n        else {\n            rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);\n        }\n        rect.x -= (grabbedPoint.x - chart.mouseX);\n        rect.y -= (grabbedPoint.y - chart.mouseY);\n        rect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getDraggedRectLocation)(rect.x, rect.y, rect.x + rect.width, rect.height + rect.y, chart.chartAxisLayoutPanel.seriesClipRect);\n        if (doDrawing) {\n            this.drawDraggingRect(chart, rect);\n        }\n        else {\n            this.calculateDragSelectedElements(chart, rect);\n        }\n    };\n    Selection.prototype.mouseLeave = function (event) {\n        this.completeSelection(event.target, event.type);\n    };\n    /**\n     * Completes the selection process.\n     *\n     * @param {HTMLElement} target - The target element where the selection is completed.\n     * @param {string} eventType - The type of event that triggered the selection completion.\n     * @returns {void}\n     */\n    Selection.prototype.completeSelection = function (target, eventType) {\n        var chart = this.chart;\n        if (chart.selectionMode === 'None') {\n            return;\n        }\n        this.currentMode = chart.selectionMode;\n        if ((this.dragging || this.resizing) && this.dragRect.width > 5 && this.dragRect.height > 5) {\n            this.calculateDragSelectedElements(chart, this.dragRect);\n        }\n        else if (!(chart.allowMultiSelection) && this.rectGrabbing &&\n            this.rectPoints.width && this.rectPoints.height) {\n            this.draggedRectMoved(chart, this.dragRect);\n        }\n        else if (this.rectGrabbing && this.dragRectArray[this.targetIndex].width && this.dragRectArray[this.targetIndex].height) {\n            this.draggedRectMoved(chart, this.dragRect);\n        }\n        if (chart.selectionMode === 'Lasso' && this.dragging && this.path) {\n            if (this.path.indexOf('L') !== -1) {\n                if (!(chart.allowMultiSelection)) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.lassoPath).setAttribute('d', this.path + 'Z');\n                    this.pointChecking((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.lassoPath));\n                }\n                else if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.lassoPath + this.count)) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.lassoPath + this.count).setAttribute('d', this.path + 'Z');\n                    this.pointChecking((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.lassoPath + this.count));\n                }\n                if (this.dragging || this.resizing) {\n                    this.calculateDragSelectedElements(chart, this.dragRect);\n                }\n            }\n        }\n        this.dragging = false;\n        this.rectGrabbing = false;\n        this.resizing = false;\n        this.removeDraggedElements(chart, target, eventType);\n    };\n    Selection.prototype.getDragRect = function (chart, seriesClipRect) {\n        return (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getDraggedRectLocation)(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY, seriesClipRect);\n    };\n    /**\n     * Initiates the drag operation.\n     *\n     * @param {Chart} chart - The chart instance where the drag operation is initiated.\n     * @param {Rect} seriesClipRect - The clipping rectangle of the series.\n     * @param {number} mouseDownX - The X-coordinate where the mouse was pressed down.\n     * @param {number} mouseDownY - The Y-coordinate where the mouse was pressed down.\n     * @param {Event} event - The event object associated with the mouse down event.\n     * @returns {void}\n     */\n    Selection.prototype.dragStart = function (chart, seriesClipRect, mouseDownX, mouseDownY, event) {\n        var mode = chart.selectionMode;\n        this.currentMode = chart.selectionMode;\n        this.dragging = (mode.indexOf('Drag') > -1 || mode === 'Lasso') && (chart.isDoubleTap || !chart.isTouch) &&\n            chart.chartAreaType !== 'PolarRadar';\n        var target = event.target;\n        this.path = undefined;\n        if (this.dragging) {\n            this.count = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.multiRectGroup) ? (this.count + 1) : 0;\n            this.dragRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);\n            if (chart.mouseDownX < seriesClipRect.x || chart.mouseDownX > (seriesClipRect.x + seriesClipRect.width) ||\n                chart.mouseDownY < seriesClipRect.y || chart.mouseDownY > (seriesClipRect.y + seriesClipRect.height)) {\n                this.dragging = false;\n            }\n        }\n        if (mode === 'Lasso') {\n            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (series.visible) {\n                    for (var _b = 0, _c = series.points; _b < _c.length; _b++) {\n                        var point = _c[_b];\n                        if (!(chart.allowMultiSelection)) {\n                            point.isSelect = false;\n                        }\n                    }\n                }\n            }\n        }\n        if (!(mode === 'Lasso')) {\n            if (this.rectPoints && !(chart.allowMultiSelection)) {\n                this.dragRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);\n                this.resizingSelectionRect(chart, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(mouseDownX, mouseDownY), true);\n                this.rectGrabbing = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(mouseDownX, mouseDownY, this.rectPoints);\n            }\n            if ((chart.allowMultiSelection)) {\n                var index = this.getIndex(target.id);\n                this.targetIndex = this.isDragRect(target.id) ? index : undefined;\n                if (this.dragRectArray.length && this.isDragRect(target.id)) {\n                    this.resizingSelectionRect(chart, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(mouseDownX, mouseDownY), true, target);\n                    this.rectGrabbing = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(mouseDownX, mouseDownY, this.dragRectArray[index]);\n                }\n            }\n        }\n    };\n    Selection.prototype.isDragRect = function (id) {\n        return id.indexOf('_ej2_drag_rect') > -1;\n    };\n    /**\n     * Handles the mouse move event.\n     *\n     * @param {PointerEvent | TouchEvent} event - The pointer event or touch event associated with the mouse move.\n     * @returns {void}\n     */\n    Selection.prototype.mouseMove = function (event) {\n        var chart = this.chart;\n        var target = event.target;\n        var eventType = event.type;\n        this.highlightChart(target, eventType);\n        if (chart.selectionMode === 'None') {\n            return;\n        }\n        if (eventType === 'touchmove' && (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIos || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIos7) && this.dragging && event.preventDefault) {\n            event.preventDefault();\n        }\n        this.selectionAndDrag(chart, target, eventType);\n    };\n    /**\n     * Highlights the specified chart element.\n     *\n     * @param {Element} target - The target element to highlight.\n     * @param {string} eventType - The type of event triggering the highlighting.\n     * @returns {void}\n     */\n    Selection.prototype.highlightChart = function (target, eventType) {\n        if (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(target)) {\n                if (target.id.indexOf('_legend_text') > 1) {\n                    target = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(target.id.replace('text', 'shape'));\n                }\n                if ((target).hasAttribute('class') && ((target).getAttribute('class').indexOf('highlight') > -1 ||\n                    target.getAttribute('class').indexOf('selection') > -1)) {\n                    return;\n                }\n                this.calculateSelectedElements(target, eventType);\n                if (this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 &&\n                    target.id.indexOf('_chart_legend_g_') === -1 && target.id.indexOf('chart_legend_shape') === -1 && target.id.indexOf('_Series_') === -1) {\n                    this.removeLegendHighlightStyles();\n                }\n                else if (this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 &&\n                    target.id.indexOf('_chart_legend_') === -1 && target.id.indexOf('_Series_') > -1 && this.chart.tooltip && this.chart.tooltip.enableHighlight && this.chart.highlightMode === 'None') {\n                    this.removeLegendHighlightStyles(true);\n                }\n            }\n            return;\n        }\n    };\n    /**\n     * Handles the selection and dragging functionality for the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {Element} target - The target element involved in the selection or dragging action.\n     * @param {string} eventType - The type of event triggering the selection or dragging action.\n     * @returns {void}\n     */\n    Selection.prototype.selectionAndDrag = function (chart, target, eventType) {\n        var insideMoving = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect);\n        if (insideMoving && !this.chart.enableCanvas) {\n            if (this.rectGrabbing && !this.resizing) {\n                this.draggedRectMoved(chart, this.dragRect, true);\n            }\n            else if (this.dragging && !this.resizing) {\n                if (chart.selectionMode === 'Lasso') {\n                    this.getPath(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY);\n                    this.drawDraggingRect(chart, this.dragRect);\n                }\n                else {\n                    this.dragRect = this.getDragRect(chart, chart.chartAxisLayoutPanel.seriesClipRect);\n                    this.drawDraggingRect(chart, this.dragRect);\n                }\n            }\n            if (this.rectPoints && !(chart.allowMultiSelection)) {\n                this.resizingSelectionRect(chart, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(chart.mouseX, chart.mouseY), null, target);\n            }\n            else if (((chart.allowMultiSelection) && !this.dragging) || this.resizing) {\n                this.resizingSelectionRect(chart, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(chart.mouseX, chart.mouseY), null, target);\n            }\n        }\n        else {\n            this.completeSelection(target, eventType);\n        }\n    };\n    /**\n     * Remove highlighted legend when not focused.\n     * @param {boolean} tooltipHighlight - Specifies whether the tooltip highlighting is enabled.\n     * @private\n     * @returns {void}\n     */\n    Selection.prototype.removeLegendHighlightStyles = function (tooltipHighlight) {\n        this.chart.highlightModule.highlightDataIndexes = [];\n        var elementCollection;\n        for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n            elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));\n            if (this.selectedDataIndexes.length === 0) {\n                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));\n                while (elementCollection.length > 0) {\n                    var element = elementCollection[0];\n                    if (element) {\n                        this.removeSvgClass(element, element.getAttribute('class'));\n                        if (element.id.indexOf('Group') > 0 && !this.chart.visibleSeries[i].isRectSeries) {\n                            var seriesIndex = this.indexFinder(element.id);\n                            for (var j = 0; j < element.children.length; j++) {\n                                if (element.children[j].nodeName !== 'defs') {\n                                    this.highlightAnimation(element.children[j], seriesIndex.series, tooltipHighlight ? 0 : 700, 0.3, !tooltipHighlight);\n                                }\n                            }\n                        }\n                    }\n                }\n                elementCollection = document.getElementsByClassName(this.unselected);\n                while (elementCollection.length > 0) {\n                    var element = elementCollection[0];\n                    if (element) {\n                        this.removeSvgClass(element, element.getAttribute('class'));\n                        if (element.id !== '') {\n                            this.highlightAnimation(element, this.chart.series.length === 1 ? 0 : this.indexFinder(element.id).series, tooltipHighlight ? 0 : 700, 0.3);\n                        }\n                    }\n                }\n            }\n            else {\n                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));\n                while (elementCollection.length > 0) {\n                    var element = elementCollection[0];\n                    if (element) {\n                        this.removeSvgClass(element, element.getAttribute('class'));\n                        this.addSvgClass(element, this.unselected);\n                    }\n                }\n            }\n        }\n    };\n    Selection.prototype.getPath = function (startX, startY, endX, endY) {\n        if (this.dragging) {\n            if (this.path) {\n                this.path = this.path + ' L' + endX + ' ' + endY;\n            }\n            else {\n                this.path = 'M ' + startX + ' ' + startY;\n            }\n        }\n    };\n    /**\n     * Performs a highlight animation on the specified HTML element.\n     *\n     * @param {HTMLElement} element - The HTML element to animate.\n     * @param {number} index - The index to find the opacity value of the series.\n     * @param {number} duration - The duration of the animation in milliseconds.\n     * @param {number} startOpacity - The starting opacity value for the animation.\n     * @param {boolean} strokeWidth - The starting opacity value for the animation.\n     * @returns {void}\n     */\n    Selection.prototype.highlightAnimation = function (element, index, duration, startOpacity, strokeWidth) {\n        var _this = this;\n        var endOpacity;\n        var endWidth;\n        var startWidth = parseFloat(this.chart.visibleSeries[index].width.toString()) + 1;\n        if (strokeWidth) {\n            if (element.id.indexOf('border') !== -1 && this.chart.visibleSeries[index].border.width) {\n                endWidth = parseFloat(this.chart.visibleSeries[index].border.width.toString());\n            }\n            else if (element.id.indexOf('Symbol') !== -1 && this.chart.visibleSeries[index].marker.border.width) {\n                endWidth = parseFloat(this.chart.visibleSeries[index].marker.border.width.toString());\n            }\n            else {\n                endWidth = parseFloat(this.chart.visibleSeries[index].width.toString());\n            }\n        }\n        else {\n            if (element.id.indexOf('border') !== -1) {\n                endOpacity = 1;\n            }\n            else if (element.id.indexOf('Symbol') !== -1) {\n                endOpacity = parseFloat(this.chart.visibleSeries[index].marker.opacity.toString());\n            }\n            else if (element.id.indexOf('legend_shape') !== -1) {\n                endOpacity = parseFloat(this.chart.legendSettings.opacity.toString());\n            }\n            else {\n                endOpacity = parseFloat(this.chart.visibleSeries[index].opacity.toString());\n            }\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.selectionModule) && this.chart.selectionMode === 'None' && this.chart.highlightColor !== '') {\n                startOpacity = 1;\n            }\n        }\n        if (endOpacity || (strokeWidth && endWidth && startWidth)) {\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n                duration: duration,\n                progress: function (args) {\n                    element.style.animation = '';\n                    if (_this.chart.tooltip.enableHighlight && _this.chart.tooltipModule.svgTooltip) {\n                        return;\n                    }\n                    var progress = args.timeStamp / args.duration;\n                    if (strokeWidth) {\n                        var currentWidth = startWidth + (endWidth - startWidth) * progress;\n                        element.setAttribute('stroke-width', currentWidth.toString());\n                    }\n                    else {\n                        var currentOpacity = startOpacity + (endOpacity - startOpacity) * progress;\n                        element.setAttribute('opacity', currentOpacity.toString());\n                    }\n                },\n                end: function () {\n                    if (_this.chart.tooltip.enableHighlight && _this.chart.tooltipModule.svgTooltip) {\n                        return;\n                    }\n                    if (strokeWidth) {\n                        element.setAttribute('stroke-width', endWidth.toString());\n                    }\n                    else {\n                        element.setAttribute('opacity', endOpacity.toString());\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * Stops the animation and sets opacity of the specified HTML element.\n     *\n     * @param {HTMLElement} element - The HTML element to stop the animation.\n     * @param {number} index - The index to find the opacity value of the series.\n     * @returns {void}\n     */\n    Selection.prototype.stopElementAnimation = function (element, index) {\n        var endOpacity;\n        if (element.id.indexOf('border') !== -1) {\n            endOpacity = 1;\n        }\n        else if (element.id.indexOf('Symbol') !== -1) {\n            endOpacity = parseFloat(this.chart.visibleSeries[index].marker.opacity.toString());\n        }\n        else {\n            endOpacity = parseFloat(this.chart.visibleSeries[index].opacity.toString());\n        }\n        if (element.getAttribute('e-animate')) {\n            _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation.stop(element);\n        }\n        element.setAttribute('opacity', endOpacity.toString());\n    };\n    Selection.prototype.pointChecking = function (path) {\n        var _this = this;\n        var chart = this.chart;\n        var element;\n        var svgRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.svgId).getBoundingClientRect();\n        var offsetX = chart.chartAxisLayoutPanel.seriesClipRect.x + Math.max(svgRect.left, 0);\n        var offsetY = chart.chartAxisLayoutPanel.seriesClipRect.y + Math.max(svgRect.top, 0);\n        this.multiDataIndexes[this.count] = [];\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n            var series = _a[_i];\n            series.points.filter(function (point) {\n                // To check whether the point have symbol location value or not.\n                if (point.symbolLocations && point.symbolLocations.length) {\n                    element = document.elementFromPoint(point.symbolLocations[0].x + offsetX, point.symbolLocations[0].y + offsetY);\n                }\n                if (element === path) {\n                    point.isSelect = true;\n                    if ((_this.chart.allowMultiSelection) && _this.currentMode === 'Lasso') {\n                        _this.multiDataIndexes[_this.count][_this.seriesIndex] = point;\n                        _this.seriesIndex++;\n                    }\n                }\n                else if (!(chart.allowMultiSelection)) {\n                    point.isSelect = false;\n                }\n            });\n        }\n        this.seriesIndex = 0;\n    };\n    /**\n     * Get module name.\n     *\n     * @private\n     * @returns {string} - Returns the module name.\n     */\n    Selection.prototype.getModuleName = function () {\n        return 'Selection';\n    };\n    /**\n     * To destroy the selection.\n     *\n     * @returns {void}\n     * @private\n     */\n    Selection.prototype.destroy = function () {\n        this.removeEventListener();\n        // Destroy method performed here\n    };\n    return Selection;\n}(_common_user_interaction_selection__WEBPACK_IMPORTED_MODULE_5__.BaseSelection));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/selection.js?");

/***/ })

}]);