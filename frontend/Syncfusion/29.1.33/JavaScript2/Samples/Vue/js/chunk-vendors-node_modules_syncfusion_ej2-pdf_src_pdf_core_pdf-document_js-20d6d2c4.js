"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_pdf-document_js-20d6d2c4"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-document.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-document.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PdfAnnotationExportSettings: () => (/* binding */ PdfAnnotationExportSettings),\n/* harmony export */   PdfDocument: () => (/* binding */ PdfDocument),\n/* harmony export */   PdfDocumentSplitEventArgs: () => (/* binding */ PdfDocumentSplitEventArgs),\n/* harmony export */   PdfFormFieldExportSettings: () => (/* binding */ PdfFormFieldExportSettings),\n/* harmony export */   PdfMargins: () => (/* binding */ PdfMargins),\n/* harmony export */   PdfPageSettings: () => (/* binding */ PdfPageSettings)\n/* harmony export */ });\n/* harmony import */ var _base_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/base-stream.js\");\n/* harmony import */ var _pdf_cross_reference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pdf-cross-reference */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-cross-reference.js\");\n/* harmony import */ var _pdf_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pdf-parser */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-parser.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/utils.js\");\n/* harmony import */ var _pdf_catalog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pdf-catalog */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-catalog.js\");\n/* harmony import */ var _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pdf-primitives */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-primitives.js\");\n/* harmony import */ var _pdf_page__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pdf-page */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page.js\");\n/* harmony import */ var _syncfusion_ej2_file_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @syncfusion/ej2-file-utils */ \"./node_modules/@syncfusion/ej2-file-utils/index.js\");\n/* harmony import */ var _enumerator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./enumerator */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js\");\n/* harmony import */ var _form_form__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./form/form */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/form/form.js\");\n/* harmony import */ var _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./graphics/pdf-graphics */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-graphics.js\");\n/* harmony import */ var _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fonts/pdf-standard-font */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/pdf-standard-font.js\");\n/* harmony import */ var _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fonts/pdf-string-format */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/pdf-string-format.js\");\n/* harmony import */ var _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./import-export/xfdf-document */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/import-export/xfdf-document.js\");\n/* harmony import */ var _import_export_json_document__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./import-export/json-document */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/import-export/json-document.js\");\n/* harmony import */ var _import_export_fdf_document__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./import-export/fdf-document */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/import-export/fdf-document.js\");\n/* harmony import */ var _pdf_outline__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pdf-outline */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-outline.js\");\n/* harmony import */ var _import_export_xml_document__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./import-export/xml-document */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/import-export/xml-document.js\");\n/* harmony import */ var _pdf_file_structure__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./pdf-file-structure */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-file-structure.js\");\n/* harmony import */ var _pdf_merge__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./pdf-merge */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-merge.js\");\n/* harmony import */ var _pdf_page_import_options__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./pdf-page-import-options */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page-import-options.js\");\n/* harmony import */ var _layers_layer_collection__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./layers/layer-collection */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/layers/layer-collection.js\");\n/* harmony import */ var _pdf_section__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./pdf-section */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-section.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Represents a PDF document and can be used to parse an existing PDF document.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Flatten annotations and form fields\n * document.flatten = true;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfDocument = /** @class */ (function () {\n    function PdfDocument(data, password) {\n        this._headerSignature = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);\n        this._startXrefSignature = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);\n        this._endObjSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);\n        this._version = '';\n        this._permissions = _enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfPermissionFlag.default;\n        this._isEncrypted = false;\n        this._isUserPassword = false;\n        this._hasUserPasswordOnly = false;\n        this._encryptOnlyAttachment = false;\n        this._encryptMetaData = false;\n        this._isExport = false;\n        this._allowCustomData = false;\n        this._isDuplicatePage = false;\n        this._isSplitDocument = false;\n        this._optionalContentDictionaries = [];\n        this._order = [];\n        this._on = [];\n        this._off = [];\n        this._as = [];\n        this._printLayer = [];\n        this._isLoaded = true;\n        if (data) {\n            this._stream = new _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfStream(typeof data === 'string' ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n            this._fileStructure = new _pdf_file_structure__WEBPACK_IMPORTED_MODULE_18__.PdfFileStructure();\n            this._crossReference = new _pdf_cross_reference__WEBPACK_IMPORTED_MODULE_1__._PdfCrossReference(this, password);\n            this._pages = new Map();\n            this._checkHeader();\n            this._crossReference._setStartXRef(this._startXRef);\n            try {\n                this._parse(false);\n            }\n            catch (e) {\n                if (e.name === 'XRefParseException') {\n                    this._parse(true);\n                }\n                else {\n                    throw e;\n                }\n            }\n            this._crossReference._version = this._version;\n        }\n        else {\n            this._isLoaded = false;\n            this._stream = new _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfStream([]);\n            this._version = '1.4';\n            this._fileStructure = new _pdf_file_structure__WEBPACK_IMPORTED_MODULE_18__.PdfFileStructure();\n            this._fileStructure.isIncrementalUpdate = false;\n            this._crossReference = new _pdf_cross_reference__WEBPACK_IMPORTED_MODULE_1__._PdfCrossReference(this);\n            this._crossReference._version = this._version;\n            this._crossReference._nextReferenceNumber = 1;\n            var catalogDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n            catalogDictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfName.get('Catalog'));\n            var catalogReference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(catalogReference, catalogDictionary);\n            var trailerDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary();\n            trailerDictionary.update('Root', catalogReference);\n            this._crossReference._trailer = trailerDictionary;\n            this._crossReference._root = catalogDictionary;\n            var topPagesDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n            topPagesDictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfName.get('Pages'));\n            topPagesDictionary.update('Kids', []);\n            topPagesDictionary.update('Count', 0);\n            var topPagesReference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(topPagesReference, topPagesDictionary);\n            catalogDictionary.update('Pages', topPagesReference);\n            this._catalog = new _pdf_catalog__WEBPACK_IMPORTED_MODULE_4__._PdfCatalog(this._crossReference);\n            this._pages = new Map();\n        }\n    }\n    Object.defineProperty(PdfDocument.prototype, \"_allowImportCustomData\", {\n        get: function () {\n            return this._allowCustomData;\n        },\n        set: function (value) {\n            this._allowCustomData = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"_linearization\", {\n        get: function () {\n            if (!this._linear) {\n                var value = void 0;\n                try {\n                    value = new _pdf_parser__WEBPACK_IMPORTED_MODULE_2__._Linearization(this._stream);\n                }\n                catch (err) { } // eslint-disable-line\n                this._linear = value;\n            }\n            return this._linear;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"_startXRef\", {\n        get: function () {\n            var stream = this._stream;\n            var startXRef = 0;\n            if (this._linearization && this._linearization.isValid) {\n                stream.reset();\n                if (this._find(stream, this._endObjSignature)) {\n                    startXRef = stream.position + 6 - stream.start;\n                }\n            }\n            else {\n                var step = 1024;\n                var startXRefLength = this._startXrefSignature.length;\n                var found = false;\n                var position = stream.end;\n                while (!found && position > 0) {\n                    position -= step - startXRefLength;\n                    if (position < 0) {\n                        position = 0;\n                    }\n                    stream.position = position;\n                    found = this._find(stream, this._startXrefSignature, step, true);\n                }\n                if (found) {\n                    stream.skip(9);\n                    var ch = void 0;\n                    do {\n                        ch = stream.getByte();\n                    } while ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isWhiteSpace)(ch));\n                    var str = '';\n                    while (ch >= 0x20 && ch <= 0x39) {\n                        str += String.fromCharCode(ch);\n                        ch = stream.getByte();\n                    }\n                    startXRef = parseInt(str, 10);\n                    if (isNaN(startXRef)) {\n                        startXRef = 0;\n                    }\n                }\n            }\n            return startXRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"isEncrypted\", {\n        /**\n         * Gets a value indicating whether the document is encrypted. (Read Only).\n         *\n         * @returns {boolean} A boolean value indicates whether the document is encrypted.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Gets a value indicating whether the document is encrypted.\n         * let isEncrypted: boolean = document.isEncrypted;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._isEncrypted;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"isUserPassword\", {\n        /**\n         * Gets a value indicating whether the document is decrypted using the user password. (Read only).\n         *\n         * @returns {boolean} A boolean value indicates whether the document is decrypted using the user password.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Gets a value indicating whether the document is decrypted using the user password\n         * let isUserPassword: boolean = document.isUserPassword;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._isUserPassword;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"pageCount\", {\n        /**\n         * Gets the page count (Read only).\n         *\n         * @returns {number} Number of pages\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Gets the page count\n         * let count: number = document.pageCount;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._pageCount === 'undefined') {\n                this._pageCount = 0;\n                if (this._linearization && this._linearization.isValid) {\n                    this._pageCount = this._linearization.pageCount;\n                }\n                else {\n                    this._pageCount = this._catalog.pageCount;\n                }\n            }\n            return this._pageCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"form\", {\n        /**\n         * Gets the PDF form fields included in the document (Read only).\n         *\n         * @returns {PdfForm} Form object\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access loaded form\n         * let form: PdfForm = document.form;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._form === 'undefined') {\n                this._form = new _form_form__WEBPACK_IMPORTED_MODULE_9__.PdfForm(this._catalog.acroForm, this._crossReference);\n            }\n            return this._form;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"flatten\", {\n        /**\n         * Gets the boolean flag to flatten the annotations and form fields.\n         *\n         * @returns {boolean} Flag to flatten\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Gets the flatten value applied\n         * let flatten: boolean = document.flatten;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._flatten;\n        },\n        /**\n         * Sets the boolean flag to flatten the annotations and form fields.\n         *\n         * @param {boolean} value to flatten\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Flatten PDF annotations and form fields\n         * document.flatten = true;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._flatten = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"permissions\", {\n        /**\n         * Gets the permission flag of the PDF document (Read only).\n         *\n         * @returns {PdfPermissionFlag} permission flag. Default value is PdfPermissionFlag.default.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Gets the permission flag\n         * let permission: PdfPermissionFlag = document.permissions;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._crossReference) {\n                var flag = this._crossReference._permissionFlags;\n                if (typeof flag !== 'undefined') {\n                    this._permissions = (flag & ~-3904);\n                }\n            }\n            return this._permissions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"bookmarks\", {\n        /**\n         * Gets the bookmarks (Read only).\n         *\n         * @returns {PdfBookmarkBase} Bookmarks.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get bookmarks\n         * let bookmarks: PdfBookmarkBase = document.bookmarks;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            var catalog = this._catalog;\n            if (catalog) {\n                if (catalog._catalogDictionary.has('Outlines')) {\n                    var reference = catalog._catalogDictionary._get('Outlines');\n                    var outlines = catalog._catalogDictionary.get('Outlines');\n                    if (outlines) {\n                        this._bookmarkBase = new _pdf_outline__WEBPACK_IMPORTED_MODULE_16__.PdfBookmarkBase(outlines, this._crossReference);\n                        this._bookmarkBase._reference = reference;\n                        if (outlines.has('First')) {\n                            this._bookmarkBase._reproduceTree();\n                        }\n                    }\n                }\n                else {\n                    var outlines = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n                    var reference = this._crossReference._getNextReference();\n                    this._crossReference._cacheMap.set(reference, outlines);\n                    catalog._catalogDictionary.update('Outlines', reference);\n                    this._crossReference._allowCatalog = true;\n                    this._bookmarkBase = new _pdf_outline__WEBPACK_IMPORTED_MODULE_16__.PdfBookmarkBase(outlines, this._crossReference);\n                    this._bookmarkBase._reference = reference;\n                }\n            }\n            return this._bookmarkBase;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"fileStructure\", {\n        /**\n         * Gets the internal structure of the PDF document.\n         *\n         * @returns {PdfFileStructure} The internal structure of the PDF document.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the internal file structure of the PDF document\n         * let fileStructure: PdfFileStructure = document.fileStructure;\n         * // Get the cross reference type\n         * let type: PdfCrossReferenceType = fileStructure.crossReferenceType;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._fileStructure;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocument.prototype, \"layers\", {\n        /**\n         * Gets the collection of `PdfLayer` from the document.\n         *\n         * @returns {PdfLayerCollection} Layer collection.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Access the collection of layers in the document\n         * let layers: PdfLayerCollection = document.layers;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (!this._layers) {\n                this._layers = new _layers_layer_collection__WEBPACK_IMPORTED_MODULE_21__.PdfLayerCollection(this);\n            }\n            return this._layers;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Gets the `PdfPage` at the specified index.\n     *\n     * @param {number} pageIndex Page index.\n     * @returns {PdfPage} PDF page at the specified index.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access first page\n     * let page: PdfPage = document.getPage(0);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfDocument.prototype.getPage = function (pageIndex) {\n        if (pageIndex < 0 || pageIndex >= this.pageCount) {\n            throw new Error('Invalid page index');\n        }\n        var cachedPage = this._pages.get(pageIndex);\n        if (cachedPage) {\n            return cachedPage;\n        }\n        var _a = this, _catalog = _a._catalog, _linearization = _a._linearization;\n        var promise;\n        if (_linearization && _linearization.isValid && _linearization.pageFirst === pageIndex) {\n            promise = this._getLinearizationPage(pageIndex);\n        }\n        else {\n            promise = _catalog.getPageDictionary(pageIndex);\n        }\n        var page = new _pdf_page__WEBPACK_IMPORTED_MODULE_6__.PdfPage(this._crossReference, pageIndex, promise.dictionary, promise.reference);\n        this._pages.set(pageIndex, page);\n        return page;\n    };\n    PdfDocument.prototype.addPage = function (arg1, arg2) {\n        var settings;\n        var pageIndex;\n        if (typeof arg2 !== 'undefined') {\n            settings = arg2;\n            pageIndex = arg1;\n            this._checkPageNumber(pageIndex);\n        }\n        else if (typeof arg1 === 'undefined') {\n            settings = new PdfPageSettings();\n            pageIndex = this.pageCount;\n        }\n        else if (arg1 instanceof PdfPageSettings) {\n            settings = arg1;\n            pageIndex = this.pageCount;\n        }\n        else {\n            settings = new PdfPageSettings();\n            pageIndex = arg1;\n            this._checkPageNumber(pageIndex);\n        }\n        var sectionDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n        sectionDictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfName.get('Pages'));\n        sectionDictionary.update('Count', 1);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updatePageSettings)(sectionDictionary, settings);\n        var sectionReference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(sectionReference, sectionDictionary);\n        sectionDictionary.objId = sectionReference.toString();\n        var pageDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n        pageDictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfName.get('Page'));\n        var pageReference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(pageReference, pageDictionary);\n        pageDictionary.objId = pageReference.toString();\n        pageDictionary.update('Parent', sectionReference);\n        sectionDictionary.update('Kids', [pageReference]);\n        if (this.pageCount === 0) {\n            var parentReference = this._catalog._catalogDictionary._get('Pages');\n            if (parentReference && this._catalog._topPagesDictionary) {\n                var isUpdated = false;\n                if (this._catalog._topPagesDictionary.has('Kids')) {\n                    var kids = this._catalog._topPagesDictionary.get('Kids');\n                    if (kids) {\n                        kids.push(sectionReference);\n                        this._catalog._topPagesDictionary.update('Kids', kids);\n                        isUpdated = true;\n                    }\n                }\n                if (!isUpdated) {\n                    this._catalog._topPagesDictionary.update('Kids', [sectionReference]);\n                }\n                this._catalog._topPagesDictionary.update('Count', 1);\n                sectionDictionary.update('Parent', parentReference);\n            }\n            else {\n                this._catalog._catalogDictionary.update('Pages', sectionReference);\n            }\n            this._pages = new Map();\n            this._pageCount = 1;\n        }\n        else {\n            var lastPage_1 = this.getPage(pageIndex === this.pageCount ? (pageIndex - 1) : pageIndex);\n            if (lastPage_1 && lastPage_1._pageDictionary) {\n                var parentReference = lastPage_1._pageDictionary._get('Parent');\n                var parentDictionary = this._crossReference._fetch(parentReference);\n                if (parentDictionary && parentDictionary.has('Kids')) {\n                    var kids = parentDictionary.get('Kids');\n                    if (kids) {\n                        if (pageIndex === this.pageCount) {\n                            kids.push(sectionReference);\n                        }\n                        else {\n                            var newKids_1 = [];\n                            kids.forEach(function (entry) {\n                                if (entry === lastPage_1._ref) {\n                                    newKids_1.push(sectionReference);\n                                }\n                                newKids_1.push(entry);\n                            });\n                            kids = newKids_1;\n                            this._updatePageCache(pageIndex);\n                        }\n                        parentDictionary.update('Kids', kids);\n                        sectionDictionary.update('Parent', parentReference);\n                        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updatePageCount)(parentDictionary, 1);\n                        this._pageCount = this.pageCount + 1;\n                    }\n                }\n            }\n        }\n        var result = new _pdf_page__WEBPACK_IMPORTED_MODULE_6__.PdfPage(this._crossReference, pageIndex, pageDictionary, pageReference);\n        result._pageSettings = settings;\n        result._isNew = true;\n        this._pages.set(pageIndex, result);\n        return result;\n    };\n    PdfDocument.prototype.addSection = function (settings) {\n        var result;\n        if (!this._isLoaded) {\n            var pageSettings = settings ? settings : new PdfPageSettings();\n            result = new _pdf_section__WEBPACK_IMPORTED_MODULE_22__.PdfSection(this, pageSettings);\n        }\n        return result;\n    };\n    PdfDocument.prototype.removePage = function (argument) {\n        var targetPage = (argument instanceof _pdf_page__WEBPACK_IMPORTED_MODULE_6__.PdfPage) ? argument : this.getPage(argument);\n        this._removePage(targetPage);\n    };\n    PdfDocument.prototype._checkPageNumber = function (index) {\n        if (index < 0 || index > this.pageCount) {\n            throw new Error('Index out of range');\n        }\n    };\n    PdfDocument.prototype._updatePageCache = function (index, isIncrement) {\n        if (isIncrement === void 0) { isIncrement = true; }\n        var updatedData = new Map();\n        for (var i = this.pageCount - 1; i >= 0; i--) {\n            var page = this.getPage(i);\n            if (isIncrement) {\n                if (i >= index) {\n                    updatedData.set(i + 1, page);\n                    page._pageIndex = i + 1;\n                }\n                else {\n                    updatedData.set(i, page);\n                }\n            }\n            else {\n                if (i > index) {\n                    updatedData.set(i - 1, page);\n                    page._pageIndex = i - 1;\n                }\n                else if (i !== index) {\n                    updatedData.set(i, page);\n                }\n            }\n        }\n        this._pages = updatedData;\n        if (!isIncrement) {\n            this._pageCount = this._pages.size;\n        }\n    };\n    PdfDocument.prototype._removePage = function (pageToRemove) {\n        var bookMarkMap = this._parseBookmarkDestination();\n        if (bookMarkMap && bookMarkMap.has(pageToRemove)) {\n            var bookmarks = bookMarkMap.get(pageToRemove);\n            if (bookmarks) {\n                for (var i = 0; i < bookmarks.length; i++) {\n                    var bookmark = bookmarks[Number.parseInt(i.toString(), 10)];\n                    if (bookmark) {\n                        var bookmarkDictionary = bookmark._dictionary;\n                        if (bookmarkDictionary) {\n                            if (bookmarkDictionary.has('A')) {\n                                bookmarkDictionary.update('A', null);\n                            }\n                            bookmarkDictionary.update('Dest', null);\n                        }\n                    }\n                }\n            }\n        }\n        this._removePageTemplates(pageToRemove);\n        for (var i = this.form.count - 1; i >= 0; --i) {\n            var field = this.form.fieldAt(i);\n            if (field && field.page === pageToRemove) {\n                this.form.removeFieldAt(i);\n            }\n        }\n        this._updatePageCache(pageToRemove._pageIndex, false);\n        this._removeParent(pageToRemove._ref, pageToRemove._pageDictionary);\n        if (this._crossReference._cacheMap.has(pageToRemove._ref)) {\n            pageToRemove._pageDictionary._updated = false;\n        }\n        if (this.pageCount === 0) {\n            this._catalog._topPagesDictionary.update('Kids', []);\n        }\n    };\n    PdfDocument.prototype._removeParent = function (referenceToRemove, dictionary) {\n        if (dictionary.has('Parent')) {\n            var parentReference = dictionary._get('Parent');\n            var parentDictionary = this._crossReference._fetch(parentReference);\n            if (parentDictionary && parentDictionary.has('Kids')) {\n                var kids = parentDictionary.get('Kids');\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(kids) && kids.length === 1 && parentDictionary && parentDictionary.get('Type').name === 'Pages') {\n                    this._removeParent(parentReference, parentDictionary);\n                }\n                else {\n                    kids = kids.filter(function (item) { return item !== referenceToRemove; });\n                    parentDictionary.update('Kids', kids);\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updatePageCount)(parentDictionary, -1);\n                }\n            }\n        }\n    };\n    PdfDocument.prototype._parseBookmarkDestination = function () {\n        var current = this.bookmarks;\n        if (typeof this._bookmarkHashTable === 'undefined' && current) {\n            this._bookmarkHashTable = new Map();\n            var stack = [];\n            var nodeInformation = { index: 0, kids: current._bookMarkList };\n            do {\n                for (; nodeInformation.index < nodeInformation.kids.length;) {\n                    current = nodeInformation.kids[nodeInformation.index];\n                    var namedDestination = current.namedDestination;\n                    if (namedDestination) {\n                        if (namedDestination.destination) {\n                            var page = namedDestination.destination.page;\n                            var list = this._bookmarkHashTable.get(page);\n                            if (!list) {\n                                list = [];\n                            }\n                            list.push(current);\n                            this._bookmarkHashTable.set(page, list);\n                        }\n                    }\n                    else {\n                        var destination = current.destination;\n                        if (destination) {\n                            var page = destination.page;\n                            var list = this._bookmarkHashTable.get(page);\n                            if (!list) {\n                                list = [];\n                            }\n                            list.push(current);\n                            this._bookmarkHashTable.set(page, list);\n                        }\n                    }\n                    nodeInformation.index += 1;\n                    if (current.count > 0) {\n                        stack.push(nodeInformation);\n                        nodeInformation = { index: 0, kids: current._bookMarkList };\n                        continue;\n                    }\n                }\n                if (stack.length > 0) {\n                    nodeInformation = stack.pop();\n                    while (nodeInformation.index === nodeInformation.kids.length && stack.length > 0) {\n                        nodeInformation = stack.pop();\n                    }\n                }\n            } while (nodeInformation.index < nodeInformation.kids.length);\n        }\n        return this._bookmarkHashTable;\n    };\n    PdfDocument.prototype._removePageTemplates = function (page) {\n        var dictionary;\n        if (this._catalog._catalogDictionary.has('Names')) {\n            dictionary = this._catalog._catalogDictionary.get('Names');\n            if (dictionary) {\n                this._removeInternalTemplates(dictionary, 'Pages', page);\n                this._removeInternalTemplates(dictionary, 'Templates', page);\n            }\n        }\n    };\n    PdfDocument.prototype._removeInternalTemplates = function (dictionary, key, page) {\n        if (dictionary.has(key)) {\n            var namedObject = dictionary.get(key);\n            if (namedObject && namedObject.has('Names')) {\n                var nameCollection = namedObject.getArray('Names');\n                if (nameCollection && nameCollection.length > 0) {\n                    var namedPageCollection = this._getUpdatedPageTemplates(nameCollection, page);\n                    var namedPageDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n                    namedPageDictionary.update('Names', namedPageCollection);\n                    var reference = this._crossReference._getNextReference();\n                    this._crossReference._cacheMap.set(reference, namedPageDictionary);\n                    namedPageDictionary.objId = reference.toString();\n                    dictionary.update(key, reference);\n                }\n            }\n        }\n    };\n    PdfDocument.prototype._getUpdatedPageTemplates = function (namedPages, page) {\n        if (namedPages.length > 0) {\n            for (var i = 1; i <= namedPages.length; i = i + 2) {\n                var pageDictionary = namedPages[Number.parseInt(i.toString(), 10)];\n                if (pageDictionary && page._pageDictionary === pageDictionary) {\n                    namedPages.pop();\n                    namedPages.pop();\n                    return namedPages;\n                }\n            }\n        }\n        return namedPages;\n    };\n    /**\n     * Reorders the pages in the PDF document.\n     *\n     * @param {number[]} orderArray The page sequence to arrange the pages.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Reorders the pages in the PDF document\n     * document.reorderPages([3, 2, 1]);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfDocument.prototype.reorderPages = function (orderArray) {\n        var _this = this;\n        orderArray.forEach(function (pageNumber) {\n            _this._checkPageNumber(pageNumber);\n        });\n        var sortedArray = this._sortedArray(orderArray);\n        var ascendingOrder = orderArray.slice().sort(function (a, b) { return a - b; });\n        var inputArray = Array.from({ length: this.pageCount }, function (_, i) { return i; });\n        var pagesToRemove = inputArray.filter(function (element) { return sortedArray.indexOf(element) === -1; });\n        for (var i = pagesToRemove.length - 1; i >= 0; i--) {\n            this.removePage(pagesToRemove[Number.parseInt(i.toString(), 10)]);\n        }\n        var newkids = [];\n        var newPages = new Map();\n        var parentReference = this._catalog._catalogDictionary._get('Pages');\n        var _loop_1 = function (i) {\n            var indexPage = this_1.getPage(ascendingOrder.indexOf(sortedArray[Number.parseInt(i.toString(), 10)]));\n            indexPage._pageIndex = i;\n            newPages.set(i, indexPage);\n            var sectionDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this_1._crossReference);\n            sectionDictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfName.get('Pages'));\n            sectionDictionary.update('Count', 1);\n            sectionDictionary.update('Parent', parentReference);\n            var sectionReference = this_1._crossReference._getNextReference();\n            sectionDictionary.objId = sectionReference.toString();\n            sectionDictionary.update('Kids', [indexPage._ref]);\n            newkids.push(sectionReference);\n            var parentDictionary = indexPage._pageDictionary.get('Parent');\n            while (parentDictionary && parentDictionary.get('Type').name === 'Pages') {\n                parentDictionary.forEach(function (key, value) {\n                    switch (key) {\n                        case 'Parent':\n                        case 'Kids':\n                        case 'Type':\n                        case 'Count':\n                            break;\n                        case 'Resources':\n                            _this._cloneResources(parentDictionary.get('Resources'), sectionDictionary);\n                            break;\n                        default:\n                            if (!sectionDictionary.has(key)) {\n                                sectionDictionary.update(key, value);\n                            }\n                            break;\n                    }\n                });\n                if (parentDictionary.has('Parent')) {\n                    parentDictionary = parentDictionary.get('Parent');\n                }\n                else {\n                    break;\n                }\n            }\n            this_1._crossReference._cacheMap.set(sectionReference, sectionDictionary);\n            var pageSection = this_1._crossReference._fetch(indexPage._ref);\n            pageSection.update('Parent', sectionReference);\n        };\n        var this_1 = this;\n        for (var i = 0; i < sortedArray.length; i++) {\n            _loop_1(i);\n        }\n        this._pages = newPages;\n        if (this._catalog) {\n            var parentDictionary = this._catalog._topPagesDictionary;\n            if (parentDictionary && parentDictionary.has('Kids')) {\n                var kids = parentDictionary.get('Kids');\n                kids = newkids;\n                parentDictionary.update('Kids', kids);\n            }\n        }\n    };\n    PdfDocument.prototype._sortedArray = function (order) {\n        var sortedArray = [];\n        order.forEach(function (num) {\n            if (sortedArray.indexOf(num) === -1) {\n                sortedArray.push(num);\n            }\n        });\n        return sortedArray;\n    };\n    PdfDocument.prototype._cloneResources = function (source, target) {\n        var _this = this;\n        if (!target.has('Resources')) {\n            target.update('Resources', source);\n        }\n        else {\n            var resourceDictionary_1 = target.get('Resources');\n            source.forEach(function (key, value) {\n                if (resourceDictionary_1.has(key)) {\n                    _this._cloneInnerResources(key, value, resourceDictionary_1);\n                }\n                else {\n                    resourceDictionary_1.update(key, value);\n                }\n            });\n        }\n    };\n    PdfDocument.prototype._cloneInnerResources = function (key, value, resourceDictionary) {\n        if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary) {\n            var oldObject_1 = resourceDictionary.get(key);\n            if (oldObject_1) {\n                var hasNew_1 = false;\n                oldObject_1.forEach(function (innerKey, innerValue) {\n                    if (!oldObject_1.has(innerKey)) {\n                        oldObject_1.update(innerKey, innerValue);\n                        hasNew_1 = true;\n                    }\n                });\n                if (hasNew_1) {\n                    resourceDictionary._updated = true;\n                }\n            }\n            else {\n                resourceDictionary.update(key, value);\n            }\n        }\n        else if (Array.isArray(value)) {\n            var oldArray_1 = resourceDictionary.get(key); // eslint-disable-line\n            if (oldArray_1) {\n                var hasNew_2 = false;\n                value.forEach(function (entry) {\n                    if (oldArray_1.indexOf(entry) === -1) {\n                        oldArray_1.push(entry);\n                        hasNew_2 = true;\n                    }\n                });\n                if (hasNew_2) {\n                    resourceDictionary._updated = true;\n                }\n            }\n            else {\n                resourceDictionary.update(key, value);\n            }\n        }\n    };\n    PdfDocument.prototype.save = function (filename) {\n        if (!this._isLoaded && this.pageCount === 0) {\n            this.addSection().addPage();\n        }\n        this._doPostProcess(this._flatten);\n        if (typeof filename === 'string') {\n            _syncfusion_ej2_file_utils__WEBPACK_IMPORTED_MODULE_7__.Save.save(filename, new Blob([this._crossReference._save()], { type: 'application/pdf' }));\n        }\n        else {\n            return this._crossReference._save();\n        }\n    };\n    /**\n     * Saves the document to the specified output stream and return the stream as Blob.\n     *\n     * @returns {Promise<{ blobData: Blob }>} Saved PDF data as `Blob`.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * // Save the document\n     * let data: Promise<{ blobData: Blob }> = document.saveAsBlob();\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfDocument.prototype.saveAsBlob = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            var obj = { blobData: new Blob([_this._crossReference._save()], { type: 'application/pdf' }) };\n            resolve(obj);\n        });\n    };\n    PdfDocument.prototype.exportAnnotations = function (arg1, arg2) {\n        this._isExport = true;\n        this._doPostProcessOnAnnotations();\n        var helper;\n        var settings;\n        if (arg1 && arg1 instanceof PdfAnnotationExportSettings) {\n            settings = arg1;\n        }\n        else if (arg2 && arg2 instanceof PdfAnnotationExportSettings) {\n            settings = arg2;\n        }\n        if (settings) {\n            if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xfdf) {\n                helper = new _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__._XfdfDocument();\n            }\n            else if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.json) {\n                helper = new _import_export_json_document__WEBPACK_IMPORTED_MODULE_14__._JsonDocument();\n            }\n            else if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.fdf) {\n                helper = new _import_export_fdf_document__WEBPACK_IMPORTED_MODULE_15__._FdfDocument();\n            }\n            else {\n                return undefined;\n            }\n            helper.exportAppearance = settings.exportAppearance;\n        }\n        else {\n            helper = new _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__._XfdfDocument();\n        }\n        var result = helper._exportAnnotations(this);\n        if (arg1 && typeof arg1 === 'string') {\n            _syncfusion_ej2_file_utils__WEBPACK_IMPORTED_MODULE_7__.Save.save(arg1, new Blob([result], { type: 'text/plain' }));\n        }\n        else {\n            return result;\n        }\n    };\n    PdfDocument.prototype.exportFormData = function (arg1, arg2) {\n        this._doPostProcessOnFormFields();\n        var helper;\n        var settings;\n        if (arg1 && arg1 instanceof PdfFormFieldExportSettings) {\n            settings = arg1;\n        }\n        else if (arg2 && arg2 instanceof PdfFormFieldExportSettings) {\n            settings = arg2;\n        }\n        if (settings) {\n            if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xfdf) {\n                helper = new _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__._XfdfDocument(settings.exportName);\n            }\n            else if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.json) {\n                helper = new _import_export_json_document__WEBPACK_IMPORTED_MODULE_14__._JsonDocument(settings.exportName);\n            }\n            else if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.fdf) {\n                helper = new _import_export_fdf_document__WEBPACK_IMPORTED_MODULE_15__._FdfDocument(settings.exportName);\n            }\n            else if (settings.dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xml) {\n                helper = new _import_export_xml_document__WEBPACK_IMPORTED_MODULE_17__._XmlDocument(settings.exportName);\n            }\n            else {\n                return undefined;\n            }\n            helper._asPerSpecification = settings.asPerSpecification;\n        }\n        else {\n            helper = new _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__._XfdfDocument();\n            helper._asPerSpecification = false;\n        }\n        if (arg1 && typeof arg1 === 'string') {\n            _syncfusion_ej2_file_utils__WEBPACK_IMPORTED_MODULE_7__.Save.save(arg1, new Blob([helper._exportFormFields(this)], { type: 'text/plain' }));\n        }\n        else {\n            return helper._exportFormFields(this);\n        }\n    };\n    PdfDocument.prototype.importAnnotations = function (data, dataFormat) {\n        if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xfdf) {\n            var xfdf = new _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__._XfdfDocument();\n            xfdf._importAnnotations(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n        }\n        else if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.json) {\n            var json = new _import_export_json_document__WEBPACK_IMPORTED_MODULE_14__._JsonDocument();\n            json._importAnnotations(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n        }\n        else if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.fdf) {\n            var fdf = new _import_export_fdf_document__WEBPACK_IMPORTED_MODULE_15__._FdfDocument();\n            fdf._importAnnotations(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n        }\n    };\n    PdfDocument.prototype.importFormData = function (data, dataFormat) {\n        if (this.form.count > 0) {\n            if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xfdf) {\n                var xfdf = new _import_export_xfdf_document__WEBPACK_IMPORTED_MODULE_13__._XfdfDocument();\n                xfdf._importFormData(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n            }\n            else if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.json) {\n                var json = new _import_export_json_document__WEBPACK_IMPORTED_MODULE_14__._JsonDocument();\n                json._importFormData(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n            }\n            else if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.fdf) {\n                var fdf = new _import_export_fdf_document__WEBPACK_IMPORTED_MODULE_15__._FdfDocument();\n                fdf._importFormData(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n            }\n            else if (dataFormat === _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xml) {\n                var xml = new _import_export_xml_document__WEBPACK_IMPORTED_MODULE_17__._XmlDocument();\n                xml._importFormData(this, (typeof data === 'string') ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n            }\n        }\n    };\n    /**\n     * Disposes the current instance of `PdfDocument` class.\n     *\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfDocument.prototype.destroy = function () {\n        if (this._crossReference) {\n            this._crossReference._destroy();\n            this._crossReference = undefined;\n        }\n        if (this._catalog) {\n            this._catalog._destroy();\n            this._catalog = undefined;\n        }\n        this._endObjSignature = undefined;\n        this._headerSignature = undefined;\n        if (this._pages && this._pages.size > 0) {\n            this._pages.forEach(function (value) {\n                value._destroy();\n            });\n        }\n        if (this._pages) {\n            this._pages.clear();\n            this._pages = undefined;\n        }\n        this._startXrefSignature = undefined;\n        this._stream = undefined;\n        this._form = undefined;\n        (0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._clearPrimitiveCaches)();\n        if (this._mergeHelperCache) {\n            if (this._mergeHelperCache.size > 0) {\n                this._mergeHelperCache.forEach(function (value) {\n                    if (value) {\n                        value._objectDispose();\n                    }\n                });\n            }\n            this._mergeHelperCache.clear();\n            this._mergeHelperCache = undefined;\n        }\n    };\n    Object.defineProperty(PdfDocument.prototype, \"_destinationCollection\", {\n        get: function () {\n            if (this._namedDestinationCollection === null || typeof this._namedDestinationCollection === 'undefined') {\n                if (this._catalog._catalogDictionary.has('Names')) {\n                    var names = this._catalog._catalogDictionary.get('Names');\n                    this._namedDestinationCollection = new _pdf_outline__WEBPACK_IMPORTED_MODULE_16__._PdfNamedDestinationCollection(names, this._crossReference);\n                }\n                else {\n                    this._namedDestinationCollection = new _pdf_outline__WEBPACK_IMPORTED_MODULE_16__._PdfNamedDestinationCollection();\n                }\n            }\n            return this._namedDestinationCollection;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfDocument.prototype._getLinearizationPage = function (pageIndex) {\n        var _a = this, _catalog = _a._catalog, _linearization = _a._linearization, _crossReference = _a._crossReference;\n        var ref = _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfReference.get(_linearization.objectNumberFirst, 0);\n        try {\n            var obj = _crossReference._fetch(ref); // eslint-disable-line\n            if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary) {\n                var type = obj.get('Type');\n                if ((0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._isName)(type, 'Page') || (!obj.has('Type') && !obj.has('Kids'))) {\n                    if (!_catalog.pageKidsCountCache.has(ref)) {\n                        _catalog.pageKidsCountCache.put(ref, 1);\n                    }\n                    if (!_catalog.pageIndexCache.has(ref)) {\n                        _catalog.pageIndexCache.put(ref, 0);\n                    }\n                    return { dictionary: obj, reference: ref };\n                }\n            }\n            throw new _utils__WEBPACK_IMPORTED_MODULE_3__.FormatError('The Linearization dictionary does not point to a valid Page dictionary.');\n        }\n        catch (reason) {\n            return _catalog.getPageDictionary(pageIndex);\n        }\n    };\n    PdfDocument.prototype._checkHeader = function () {\n        var stream = this._stream;\n        stream.reset();\n        if (!this._find(stream, this._headerSignature)) {\n            return;\n        }\n        stream.moveStart();\n        var version = '';\n        var ch = stream.getByte();\n        while (ch > 0x20) {\n            if (version.length >= 12) {\n                break;\n            }\n            version += String.fromCharCode(ch);\n            ch = stream.getByte();\n        }\n        if (!this._version) {\n            this._version = version.substring(5);\n        }\n    };\n    PdfDocument.prototype._parse = function (recoveryMode) {\n        this._crossReference._parse(recoveryMode);\n        this._catalog = new _pdf_catalog__WEBPACK_IMPORTED_MODULE_4__._PdfCatalog(this._crossReference);\n        if (this._catalog.version) {\n            this._version = this._catalog.version;\n        }\n    };\n    PdfDocument.prototype._find = function (stream, signature, limit, backwards) {\n        if (limit === void 0) { limit = 1024; }\n        if (backwards === void 0) { backwards = false; }\n        var signatureLength = signature.length;\n        var scanBytes = stream.peekBytes(limit);\n        var scanLength = scanBytes.length - signatureLength;\n        if (scanLength <= 0) {\n            return false;\n        }\n        if (backwards) {\n            var signatureEnd = signatureLength - 1;\n            var position = scanBytes.length - 1;\n            while (position >= signatureEnd) {\n                var j = 0;\n                while (j < signatureLength && scanBytes[position - j] === signature[signatureEnd - j]) {\n                    j++;\n                }\n                if (j >= signatureLength) {\n                    stream.position += position - signatureEnd;\n                    return true;\n                }\n                position--;\n            }\n        }\n        else {\n            var position = 0;\n            while (position <= scanLength) {\n                var j = 0;\n                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line\n                    j++;\n                }\n                if (j >= signatureLength) {\n                    stream.position += position;\n                    return true;\n                }\n                position++;\n            }\n        }\n        return false;\n    };\n    PdfDocument.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        this._doPostProcessOnFormFields(isFlatten);\n        this._doPostProcessOnAnnotations(isFlatten);\n    };\n    PdfDocument.prototype._doPostProcessOnFormFields = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._catalog._catalogDictionary.has('AcroForm')) {\n            this.form._doPostProcess(isFlatten);\n            if (isFlatten) {\n                var formObject = this._catalog._catalogDictionary.getRaw('AcroForm');\n                var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n                dictionary._updated = true;\n                if (formObject instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfReference) {\n                    this._crossReference._cacheMap.set(formObject, dictionary);\n                }\n                else {\n                    this.form._dictionary = dictionary;\n                    this._crossReference._allowCatalog = true;\n                }\n                this.form._clear();\n            }\n            if (this.form._isDefaultAppearance) {\n                this.form._dictionary.update('NeedAppearances', this.form._isDefaultAppearance);\n            }\n            else if (!this.form._isDefaultAppearance && this.form._dictionary.has('NeedAppearances') && this.form._isNeedAppearances) {\n                this.form._dictionary.update('NeedAppearances', false);\n            }\n            else if (!this.form._isDefaultAppearance && this.form._dictionary.has('NeedAppearances')) {\n                this.form._dictionary.update('NeedAppearances', this.form.needAppearances);\n            }\n        }\n    };\n    PdfDocument.prototype._doPostProcessOnAnnotations = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        for (var i = 0; i < this.pageCount; i++) {\n            var page = this.getPage(i);\n            page.annotations._isExport = this._isExport;\n            page.annotations._doPostProcess(isFlatten);\n            if (isFlatten) {\n                if (page._pageDictionary.has('Annots')) {\n                    delete page._pageDictionary._map.Annots;\n                    page._pageDictionary._updated = true;\n                }\n                page.annotations._clear();\n            }\n        }\n    };\n    PdfDocument.prototype._addWatermarkText = function () {\n        if (this.pageCount > 0) {\n            for (var index = 0; index < this._pageCount; index++) {\n                var page = this.getPage(index);\n                if (page) {\n                    try {\n                        var graphics = page.graphics;\n                        graphics.save();\n                        graphics.setTransparency(0.20);\n                        graphics.drawRectangle(0, 0, page.size[0], 33.75, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_10__.PdfBrush([255, 255, 255]));\n                        graphics.restore();\n                        graphics.save();\n                        graphics.setTransparency(0.50);\n                        var font = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_11__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_11__.PdfFontFamily.helvetica, 12, _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_11__.PdfFontStyle.regular);\n                        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_12__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_12__.PdfVerticalAlignment.middle);\n                        graphics.drawString('Created with a trial version of Syncfusion Essential PDF', font, [0, 0, page.size[0], 33.75], null, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_10__.PdfBrush([0, 0, 0]), format);\n                        graphics.restore();\n                    }\n                    catch (e) { } // eslint-disable-line\n                }\n            }\n        }\n    };\n    PdfDocument.prototype.importPageRange = function (sourceDocument, startIndex, endIndex, options) {\n        if (startIndex > endIndex || startIndex >= sourceDocument.pageCount) {\n            throw new Error('The start index is greater then the end index, which might indicate the error in the program.');\n        }\n        this._importPages(sourceDocument, startIndex, endIndex, options);\n    };\n    PdfDocument.prototype._importPages = function (sourceDocument, startIndex, endIndex, options) {\n        var sourceOCProperties;\n        var correspondancePagecount = 0;\n        var ocProperties;\n        if (typeof options !== 'undefined' && typeof options.targetIndex === 'number') {\n            if (options.targetIndex > this.pageCount) {\n                throw new Error('The target index is out of range.');\n            }\n            this._targetIndex = options.targetIndex;\n        }\n        var pageReference = new Map();\n        if (!this._isDuplicatePage) {\n            for (var index = 0; index < sourceDocument.pageCount; index++) {\n                var sourcepage = sourceDocument.getPage(index);\n                pageReference.set(sourcepage._pageDictionary, null);\n            }\n        }\n        var helper;\n        if (!this._mergeHelperCache) {\n            this._mergeHelperCache = new Map();\n        }\n        if (!sourceDocument._uniqueID) {\n            sourceDocument._uniqueID = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getNewGuidString)();\n        }\n        if (this._mergeHelperCache.has(sourceDocument._uniqueID)) {\n            helper = this._mergeHelperCache.get(sourceDocument._uniqueID);\n        }\n        else {\n            helper = new _pdf_merge__WEBPACK_IMPORTED_MODULE_19__._PdfMergeHelper(this._crossReference, this, sourceDocument, pageReference, options);\n            this._mergeHelperCache.set(sourceDocument._uniqueID, helper);\n        }\n        var isLayersPresent = false;\n        if ((!this._isDuplicatePage && sourceDocument._catalog._catalogDictionary.has('OCProperties')) || (typeof options !== 'undefined' && !options.optimizeResources)) {\n            isLayersPresent = true;\n            sourceOCProperties = sourceDocument._catalog._catalogDictionary.get('OCProperties');\n            ocProperties = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_5__._PdfDictionary(this._crossReference);\n            helper._writeObject(sourceDocument, ocProperties, sourceOCProperties, sourceOCProperties, 'OCProperties', null, null);\n            ocProperties._updated = true;\n        }\n        for (var i = startIndex; i <= endIndex; i++) {\n            var page = sourceDocument.getPage(i);\n            sourceDocument.form._doPostProcess(sourceDocument.flatten, page);\n            if (page.annotations.count > 0) {\n                page.annotations._doPostProcess(sourceDocument.flatten);\n                if (sourceDocument.flatten) {\n                    if (page._pageDictionary.has('Annots')) {\n                        delete page._pageDictionary._map.Annots;\n                        page._pageDictionary._updated = true;\n                    }\n                    page.annotations._clear();\n                }\n            }\n            if (sourceDocument._isSplitDocument) {\n                helper._importPages(page, this._targetIndex, isLayersPresent, this._isDuplicatePage, options, sourceDocument._isSplitDocument);\n            }\n            else {\n                helper._importPages(page, this._targetIndex, isLayersPresent, this._isDuplicatePage, options);\n            }\n            correspondancePagecount++;\n            if (typeof this._targetIndex === 'number') {\n                ++this._targetIndex;\n            }\n        }\n        if (!this._isDuplicatePage) {\n            helper._fixDestinations(sourceDocument);\n        }\n        helper._exportBookmarks(sourceDocument, correspondancePagecount);\n        helper._mergeFormFieldsWithDocument();\n        if ((isLayersPresent && !this._isDuplicatePage) || (typeof options !== 'undefined' && !options.optimizeResources)) {\n            helper._importLayers(ocProperties, true);\n        }\n        helper._objectDispose();\n        this._isDuplicatePage = false;\n    };\n    PdfDocument.prototype.importPage = function (arg1, arg2, options) {\n        if (typeof arg1 === 'number') {\n            this._isDuplicatePage = true;\n            if (arg2 instanceof _pdf_page_import_options__WEBPACK_IMPORTED_MODULE_20__.PdfPageImportOptions) {\n                this._importPages(this, arg1, arg1, arg2);\n            }\n            else {\n                this._importPages(this, arg1, arg1);\n            }\n        }\n        else if (arg1 instanceof _pdf_page__WEBPACK_IMPORTED_MODULE_6__.PdfPage && arg2 instanceof PdfDocument) {\n            var index = arg1._pageIndex;\n            this.importPageRange(arg2, index, index, options);\n        }\n    };\n    /**\n     * Splitting a PDF file into individual pages.\n     *\n     * @returns {void} Nothing\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * document.splitEvent = documentSplitEvent;\n     * // Split PDF document into individual pages\n     * document.split();\n     * // Event to invoke while splitting PDF document data\n     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n     * }\n     * // Destroy the document\n     * document.destroy();\n     */\n    PdfDocument.prototype.split = function () {\n        this.splitByFixedNumber(1);\n    };\n    /**\n     * Splits the PDF document into parts, each containing a maximum number of pages specified.\n     *\n     * @param {number} fixedNumber specifies the maximum number of pages in each split PDF. The default value is 1.\n     * @returns {void} Nothing\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * document.splitEvent = documentSplitEvent;\n     * // Split PDF document by fixed number of pages\n     * document.splitByFixedNumber(1);\n     * // Event to invoke while splitting PDF document data\n     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n     * }\n     * // Destroy the document\n     * document.destroy();\n     */\n    PdfDocument.prototype.splitByFixedNumber = function (fixedNumber) {\n        var pageCount = this.pageCount;\n        if (this.splitEvent && pageCount >= fixedNumber && fixedNumber > 0) {\n            var splitIndex = 0;\n            for (var tempValue = 0; tempValue < pageCount; tempValue += fixedNumber) {\n                var endIndex = Math.min(tempValue + fixedNumber - 1, pageCount - 1);\n                var pdfData = this._importDocumentPages(tempValue, endIndex);\n                this._invokeSplitEvent(splitIndex, pdfData);\n                splitIndex++;\n            }\n        }\n        else {\n            throw new Error('Invalid split number. Split number should be greater than zero and less than or equal to page count.');\n        }\n    };\n    /**\n     * Splits the PDF document into multiple parts based on the specified page ranges.\n     *\n     * @param {Array<number[]>} ranges The two dimensional number array specified for start and end page indexes to split PDF documents.\n     * @returns {void} Nothing\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * document.splitEvent = documentSplitEvent;\n     * // Split PDF document by page ranges specified\n     * document.splitByPageRanges([[0, 4], [5, 9]]);\n     * // Event to invoke while splitting PDF document data\n     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n     * }\n     * // Destroy the document\n     * document.destroy();\n     */\n    PdfDocument.prototype.splitByPageRanges = function (ranges) {\n        var pageCount = this.pageCount;\n        if (this.splitEvent) {\n            var splitIndex = 0;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[Number.parseInt(i.toString(), 10)];\n                if (Array.isArray(range) && range.length < 2) {\n                    throw new Error('Invalid page range. Start and end page indexes should be specified.');\n                }\n                var start = range[0];\n                var end = range[1];\n                if (start < 0 || end < 0 || start >= pageCount || end >= pageCount || start > end) {\n                    throw new Error('Invalid page range: start (${start}) and end (${end}).');\n                }\n                var pdfData = this._importDocumentPages(start, end);\n                this._invokeSplitEvent(splitIndex, pdfData);\n                splitIndex++;\n            }\n        }\n    };\n    PdfDocument.prototype._importDocumentPages = function (startIndex, endIndex) {\n        this._isSplitDocument = true;\n        var document = new PdfDocument();\n        for (var i = startIndex; i <= endIndex; i++) {\n            var page = this.getPage(i);\n            document.importPage(page, this);\n        }\n        var result = document.save();\n        document.destroy();\n        return result;\n    };\n    PdfDocument.prototype._invokeSplitEvent = function (splitIndex, pdfData) {\n        var args = new PdfDocumentSplitEventArgs(splitIndex, pdfData);\n        this.splitEvent(this, args);\n    };\n    return PdfDocument;\n}());\n\n/**\n * Represents annotation export settings.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Sets export data format as JSON type to annotation export settings\n * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();\n * // Set the data format defined in annotation export settings\n * settings.dataFormat = DataFormat.json;\n * // Export annotations to JSON format\n * let json: Uint8Array = document.exportAnnotations(settings);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationExportSettings = /** @class */ (function () {\n    function PdfAnnotationExportSettings() {\n        this._format = _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xfdf;\n        this._exportAppearance = false;\n    }\n    Object.defineProperty(PdfAnnotationExportSettings.prototype, \"dataFormat\", {\n        /**\n         * Gets the data format defined in annotation export settings.\n         *\n         * @returns {DataFormat} - Returns the data format.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Sets export data format as JSON type to annotation export settings\n         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();\n         * // Export annotations to JSON format\n         * let json: Uint8Array = document.exportAnnotations(settings);\n         * // Get the data format defined in annotation export settings\n         * let dataFormat: DataFormat = settings.dataFormat;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._format;\n        },\n        /**\n         * Sets the data format defined in annotation export settings.\n         *\n         * @param {DataFormat} format - Specifies the data format.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Sets export data format as JSON type to annotation export settings\n         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();\n         * // Set the data format defined in annotation export settings\n         * settings.dataFormat = DataFormat.json;\n         * // Export annotations to JSON format\n         * let json: Uint8Array = document.exportAnnotations(settings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (format) {\n            this._format = format;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotationExportSettings.prototype, \"exportAppearance\", {\n        /**\n         * Gets the boolean value indicating whether the appearance of a particular object can be exported or not.\n         *\n         * @returns {boolean} - Returns the boolean value.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Sets the annotation export settings with enabled export appearance.\n         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();\n         * // Export annotations to XFDF format\n         * let xfdf: Uint8Array = document.exportAnnotations(settings);\n         * // Get the boolean value indicating whether the appearance of a particular object can be exported or not\n         * let appearance: boolean = settings.exportAppearance;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._exportAppearance;\n        },\n        /**\n         * Sets the boolean value indicating whether the appearance of a particular object can be exported or not.\n         *\n         * @param {boolean} value - The boolean value.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Sets the annotation export settings with enabled export appearance.\n         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();\n         * // Set the boolean value indicating whether the appearance of a particular object can be exported or not\n         * settings.exportAppearance = true;\n         * // Export annotations to XFDF format\n         * let xfdf: Uint8Array = document.exportAnnotations(settings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._exportAppearance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfAnnotationExportSettings;\n}());\n\n/**\n * Represents form fields export settings.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Sets the form field data export settings with output data format.\n * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n * // Set the data format defined in form field export settings.\n * settings.dataFormat = DataFormat.json;\n * // Export form field to JSON format\n * let json: Uint8Array = document.exportFormData(settings);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFormFieldExportSettings = /** @class */ (function () {\n    function PdfFormFieldExportSettings() {\n        this._format = _enumerator__WEBPACK_IMPORTED_MODULE_8__.DataFormat.xfdf;\n        this._exportName = '';\n        this._asPerSpecification = true;\n    }\n    Object.defineProperty(PdfFormFieldExportSettings.prototype, \"dataFormat\", {\n        /**\n         * Gets the data format defined in form field export settings.\n         *\n         * @returns {DataFormat} - Returns the data format.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Sets the form field data export settings with output data format.\n         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n         * // Export form field to JSON format\n         * let json: Uint8Array = document.exportFormData(settings);\n         * // Get the data format defined in form field export settings\n         * let dataFormat: DataFormat = settings.dataFormat;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._format;\n        },\n        /**\n         * Sets the data format defined in form field export settings.\n         *\n         * @param {DataFormat} format - Specifies the data format.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Sets the form field data export settings with output data format.\n         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n         * // Set the data format defined in form field export settings.\n         * settings.dataFormat = DataFormat.json;\n         * // Export form field to JSON format\n         * let json: Uint8Array = document.exportFormData(settings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (format) {\n            this._format = format;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFormFieldExportSettings.prototype, \"exportName\", {\n        /**\n         * Gets the export name defined in form field export settings.\n         *\n         * @returns {string} - Returns the string value.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Sets the form field data export settings with export name.\n         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n         * // Export form field to JSON format\n         * let json: Uint8Array = document.exportFormData(settings);\n         * // Get the export name defined in form field export settings\n         * let name: boolean = settings.exportName;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._exportName;\n        },\n        /**\n         * Sets the export name defined in form field export settings.\n         *\n         * @param {string} name - Specifies the export name of the form.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Sets the form field data export settings with export name.\n         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n         * // Set the export name defined in form field export settings.\n         * settings.exportName = ‘JobApplication’.\n         * // Export form field to JSON format\n         * let json: Uint8Array = document.exportFormData(settings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (name) {\n            this._exportName = name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFormFieldExportSettings.prototype, \"asPerSpecification\", {\n        /**\n         * Gets the boolean value indicating whether the data in a form field can be exported based on a certain specification.\n         *\n         * @returns {boolean} - Returns the boolean value.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.\n         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n         * // Export form field to JSON format\n         * let json: Uint8Array = document.exportFormData(settings);\n         * // Get the boolean value indicating whether the data in a form field can be exported based on a certain specification.\n         * let asPerSpecification: boolean = settings.asPerSpecification;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._asPerSpecification;\n        },\n        /**\n         * Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.\n         *\n         * @param {boolean} value - The boolean value.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.\n         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();\n         * // Set the boolean value indicating whether the data in a form field can be exported based on a certain specification.\n         * settings.asPerSpecification = true;\n         * // Export form field to JSON format\n         * let json: Uint8Array = document.exportFormData(settings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._asPerSpecification = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfFormFieldExportSettings;\n}());\n\n/**\n * The class provides various settings related to PDF pages.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Create a new PDF page settings instance\n * let pageSettings: PdfPageSettings = new PdfPageSettings();\n * // Sets the margins\n * pageSettings.margins = new PdfMargins(40);\n * // Sets the page size\n * pageSettings.size = [595, 842];\n * // Sets the page orientation\n * pageSettings.orientation = PdfPageOrientation.landscape;\n * // Add a new PDF page with page settings\n * page = document.addPage(pageSettings);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPageSettings = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `PdfPageSettings` class\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Create a new PDF page settings instance\n     * let pageSettings: PdfPageSettings = new PdfPageSettings();\n     * // Sets the margins\n     * pageSettings.margins = new PdfMargins(40);\n     * // Sets the page size\n     * pageSettings.size = [595, 842];\n     * // Sets the page orientation\n     * pageSettings.orientation = PdfPageOrientation.landscape;\n     * // Add a new PDF page with page settings\n     * page = document.addPage(pageSettings);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    function PdfPageSettings() {\n        this._size = [595, 842];\n        this._isOrientation = false;\n        this._orientation = _enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfPageOrientation.portrait;\n        this._size = [595, 842];\n        this._margins = new PdfMargins();\n        this._rotation = _enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfRotationAngle.angle0;\n    }\n    Object.defineProperty(PdfPageSettings.prototype, \"orientation\", {\n        /**\n         * Gets the orientation of the page.\n         *\n         * @returns {PdfPageOrientation} The orientation.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the page size\n         * pageSettings.size = [842, 595];\n         * // Gets the page orientation\n         * let orientation: PdfPageOrientation = pageSettings.orientation;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._orientation;\n        },\n        /**\n         * Sets the orientation of the page.\n         *\n         * @param {PdfPageOrientation} value The orientation.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the page orientation\n         * pageSettings.orientation = PdfPageOrientation.landscape;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._isOrientation = true;\n            if (this._orientation !== value) {\n                this._orientation = value;\n                this._updateSize(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPageSettings.prototype, \"size\", {\n        /**\n         * Gets the size of the page.\n         *\n         * @returns {number[]} The width and height of the page as number array.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the first page\n         * let page: PdfPage = document.getPage(0);\n         * // Gets the width and height of the PDF page as number array\n         * let size: number[] = page.size;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._size;\n        },\n        /**\n         * Sets the width and height of the page.\n         *\n         * @param {number[]} value The width and height of the page as number array.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the page size\n         * pageSettings.size = [595, 842];\n         * // Sets the page orientation\n         * pageSettings.orientation = PdfPageOrientation.landscape;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._isOrientation) {\n                this._updateSize(value);\n            }\n            else {\n                this._size = value;\n                this._updateOrientation();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPageSettings.prototype, \"margins\", {\n        /**\n         * Gets the margin value of the page.\n         *\n         * @returns {PdfMargins} PDF margins\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Gets the margins\n         * let margins: PdfMargins = pageSettings.margins;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._margins;\n        },\n        /**\n         * Sets the margin value of the page.\n         *\n         * @param {PdfMargins} value PDF margins\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the margins\n         * pageSettings.margins = new PdfMargins(40);\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._margins = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPageSettings.prototype, \"rotation\", {\n        /**\n         * Gets the rotation angle of the PDF page.\n         *\n         * @returns {PdfRotationAngle} PDF rotation angle\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Gets the rotation angle\n         * let rotation: PdfRotationAngle = pageSettings.rotation;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._rotation;\n        },\n        /**\n         * Sets the rotation angle of the PDF page.\n         *\n         * @param {PdfRotationAngle} value PDF rotation angle\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the rotation angle\n         * pageSettings.rotation = PdfRotationAngle.angle90;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._rotation = value;\n            if (value >= 4) {\n                this._rotation = (value % 4);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfPageSettings.prototype._updateSize = function (value) {\n        var pageOrientation;\n        var pageSize;\n        if (Array.isArray(value)) {\n            pageOrientation = this.orientation;\n            pageSize = value;\n        }\n        else {\n            pageOrientation = value;\n            pageSize = this._size;\n        }\n        if (pageOrientation === _enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfPageOrientation.portrait) {\n            this._size = [Math.min(pageSize[0], pageSize[1]), Math.max(pageSize[0], pageSize[1])];\n        }\n        else {\n            this._size = [Math.max(pageSize[0], pageSize[1]), Math.min(pageSize[0], pageSize[1])];\n        }\n    };\n    PdfPageSettings.prototype._updateOrientation = function () {\n        this._orientation = (this._size[1] >= this._size[0]) ? _enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfPageOrientation.portrait : _enumerator__WEBPACK_IMPORTED_MODULE_8__.PdfPageOrientation.landscape;\n    };\n    PdfPageSettings.prototype._getActualSize = function () {\n        var width = this._size[0] - (this._margins._left + this._margins._right);\n        var height = this._size[1] - (this._margins._top + this._margins._bottom);\n        return [width, height];\n    };\n    return PdfPageSettings;\n}());\n\n/**\n * A class representing PDF page margins.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Create a new PDF page settings instance\n * let pageSettings: PdfPageSettings = new PdfPageSettings();\n * // Sets the margins\n * pageSettings.margins = new PdfMargins(40);\n * // Sets the page size\n * pageSettings.size = [595, 842];\n * // Sets the page orientation\n * pageSettings.orientation = PdfPageOrientation.landscape;\n * // Add a new PDF page with page settings\n * page = document.addPage(pageSettings);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfMargins = /** @class */ (function () {\n    function PdfMargins(all) {\n        if (typeof all === 'undefined') {\n            this._left = this._right = this._top = this._bottom = 40;\n        }\n        else {\n            this._left = this._right = this._top = this._bottom = all;\n        }\n    }\n    Object.defineProperty(PdfMargins.prototype, \"left\", {\n        /**\n         * Gets the left margin value of the page.\n         *\n         * @returns {number} Left margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Gets the left margin\n         * let left: number = pageSettings.margins.left;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._left;\n        },\n        /**\n         * Sets the left margin value of the page.\n         *\n         * @param {number} value Left margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the margins\n         * let margins: PdfMargins = new PdfMargins();\n         * margins.left = 40;\n         * margins.right = 40;\n         * margins.top = 20;\n         * margins.bottom = 20;\n         * pageSettings.margins = margins;\n         * // Sets the page size\n         * pageSettings.size = [595, 842];\n         * // Sets the page orientation\n         * pageSettings.orientation = PdfPageOrientation.landscape;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._left = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfMargins.prototype, \"right\", {\n        /**\n         * Gets the right margin value of the page.\n         *\n         * @returns {number} Right margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Gets the right margin\n         * let right: number = pageSettings.margins.right;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._right;\n        },\n        /**\n         * Sets the right margin value of the page.\n         *\n         * @param {number} value - Right margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the margins\n         * let margins: PdfMargins = new PdfMargins();\n         * margins.left = 40;\n         * margins.right = 40;\n         * margins.top = 20;\n         * margins.bottom = 20;\n         * pageSettings.margins = margins;\n         * // Sets the page size\n         * pageSettings.size = [595, 842];\n         * // Sets the page orientation\n         * pageSettings.orientation = PdfPageOrientation.landscape;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._right = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfMargins.prototype, \"top\", {\n        /**\n         * Gets the top margin value of the page.\n         *\n         * @returns {number} Top margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Gets the top margin\n         * let top: number = pageSettings.margins.top;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._top;\n        },\n        /**\n         *Sets the top margin value of the page.\n         *\n         * @param {number} value Top margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the margins\n         * let margins: PdfMargins = new PdfMargins();\n         * margins.left = 40;\n         * margins.right = 40;\n         * margins.top = 20;\n         * margins.bottom = 20;\n         * pageSettings.margins = margins;\n         * // Sets the page size\n         * pageSettings.size = [595, 842];\n         * // Sets the page orientation\n         * pageSettings.orientation = PdfPageOrientation.landscape;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._top = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfMargins.prototype, \"bottom\", {\n        /**\n         * Get the bottom margin value of the page.\n         *\n         * @returns {number} Bottom margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Gets the bottom margin\n         * let bottom: number = pageSettings.margins.bottom;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._bottom;\n        },\n        /**\n         * Sets the bottom margin value of the page.\n         *\n         * @param {number} value Bottom margin.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Create a new PDF page settings instance\n         * let pageSettings: PdfPageSettings = new PdfPageSettings();\n         * // Sets the margins\n         * let margins: PdfMargins = new PdfMargins();\n         * margins.left = 40;\n         * margins.right = 40;\n         * margins.top = 20;\n         * margins.bottom = 20;\n         * pageSettings.margins = margins;\n         * // Sets the page size\n         * pageSettings.size = [595, 842];\n         * // Sets the page orientation\n         * pageSettings.orientation = PdfPageOrientation.landscape;\n         * // Add a new PDF page with page settings\n         * page = document.addPage(pageSettings);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._bottom = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfMargins;\n}());\n\n/**\n * Public class to provide data for the document split event, including the split index and PDF data.\n *\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * document.splitEvent = documentSplitEvent;\n * // Split PDF document by fixed number of pages\n * document.splitByFixedNumber(1);\n * // Event to invoke while splitting PDF document data\n * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n *  Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n * }\n * // Destroy the document\n * document.destroy();\n */\nvar PdfDocumentSplitEventArgs = /** @class */ (function () {\n    /*\n     * Initializes a new instance of the `PdfDocumentSplitEventArgs` class.\n     *\n     * @param {number} splitIndex The fixed number to split PDF document pages. The default value is 1.\n     * @param {Uint8Array} pdfData The byte array of the split PDF document data.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * document.splitEvent = documentSplitEvent;\n     * // Split PDF document by fixed number of pages\n     * document.splitByFixedNumber(1);\n     * // Event to invoke while splitting PDF document data\n     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n     * }\n     * // Destroy the document\n     * document.destroy();\n     */\n    function PdfDocumentSplitEventArgs(splitIndex, pdfData) {\n        this._index = splitIndex;\n        this._pdfData = pdfData;\n    }\n    Object.defineProperty(PdfDocumentSplitEventArgs.prototype, \"pdfData\", {\n        /*\n         * Gets the byte array of the PDF document data.\n         *\n         * @returns {Uint8Array} The byte array of the PDF document data.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * document.splitEvent = documentSplitEvent;\n         * // Split PDF document by fixed number of pages\n         * document.splitByFixedNumber(1);\n         * // Event to invoke while splitting PDF document data\n         * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n         *  Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n         * }\n         * // Destroy the document\n         * document.destroy();\n         */\n        get: function () {\n            return this._pdfData;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfDocumentSplitEventArgs.prototype, \"index\", {\n        /*\n         * Gets the split index of the PDF document.\n         *\n         * @returns {Uint8Array} The index that defines the number of event calls during the PDF document split.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * document.splitEvent = documentSplitEvent;\n         * // Split PDF document by fixed number of pages\n         * document.splitByFixedNumber(1);\n         * // Event to invoke while splitting PDF document data\n         * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {\n         *  Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));\n         * }\n         * // Destroy the document\n         * document.destroy();\n         */\n        get: function () {\n            return this._index;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfDocumentSplitEventArgs;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-document.js?");

/***/ })

}]);