"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-lineargauge_src_linear-gauge_axes_axis-renderer_js-f4cd2fa-09f75975"],{

/***/ "./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/axis-renderer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/axis-renderer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisRenderer: () => (/* binding */ AxisRenderer)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animation */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/animation.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/helper */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/utils/helper.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * To render the axis elements.\n *\n * @private\n */\nvar AxisRenderer = /** @class */ (function (_super) {\n    __extends(AxisRenderer, _super);\n    function AxisRenderer(gauge) {\n        return _super.call(this, gauge) || this;\n    }\n    AxisRenderer.prototype.renderAxes = function () {\n        var _this = this;\n        var axis;\n        var major;\n        var minor;\n        this.axisElements = [];\n        var gaugeAxesG = this.gauge.svgObject.querySelector('#' + this.gauge.element.id + '_Axis_Collections');\n        if (gaugeAxesG) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(gaugeAxesG);\n        }\n        this.axisObject = this.gauge.renderer.createGroup({\n            id: this.gauge.element.id + '_Axis_Collections',\n            transform: 'translate( 0, 0 )'\n        });\n        this.gauge.splitUpCount = 0;\n        for (var i = 0; i < this.gauge.axes.length; i++) {\n            axis = this.gauge.axes[i];\n            major = axis.majorTicks;\n            minor = axis.minorTicks;\n            this.htmlObject = this.gauge.renderer.createGroup({ id: this.gauge.element.id + '_Axis_Group_' + i });\n            if (this.gauge.allowLoadingAnimation) {\n                if (this.gauge.splitUpCount === 0 && (axis.line.width > 0 || (axis.majorTicks.height > 0 && axis.majorTicks.width > 0) ||\n                    (axis.minorTicks.height > 0 && axis.minorTicks.width > 0) || this.gauge.container.width > 0 || (axis.ranges.length > 0\n                    && !(axis.ranges.length === 1 && axis.ranges[0].start === axis.ranges[0].end && axis.ranges[0].start === 0)))) {\n                    this.gauge.splitUpCount++;\n                }\n                if (this.gauge.splitUpCount === 0 || this.gauge.splitUpCount === 1) {\n                    this.gauge.splitUpCount = axis.pointers.length > 0 ? this.gauge.splitUpCount + 1 : this.gauge.splitUpCount;\n                }\n            }\n            this.drawAxisLine(axis, this.htmlObject, i);\n            this.drawRanges(axis, this.htmlObject, i);\n            this.drawTicks(axis, major, this.htmlObject, 'MajorTicks', axis.majorTickBounds, i);\n            this.drawTicks(axis, minor, this.htmlObject, 'MinorTicks', axis.minorTickBounds, i);\n            this.drawAxisLabels(axis, this.htmlObject, i);\n            this.drawPointers(axis, this.htmlObject, i);\n            this.axisElements.push(this.htmlObject);\n        }\n        this.axisElements.forEach(function (axisElement) {\n            _this.axisObject.appendChild(axisElement);\n        });\n        this.gauge.svgObject.appendChild(this.axisObject);\n        if (this.gauge.nearSizes.length !== this.gauge.farSizes.length && this.gauge.axes.length > 1) {\n            this.axisAlign(this.gauge.axes);\n        }\n    };\n    AxisRenderer.prototype.axisAlign = function (axes) {\n        var nearAxisWidth = 0;\n        var farAxisWidth = 0;\n        var tranX;\n        var transY;\n        if (this.gauge.orientation === 'Vertical') {\n            axes.forEach(function (axis) {\n                if (!axis.opposedPosition) {\n                    nearAxisWidth += axis.bounds.width;\n                }\n                else {\n                    farAxisWidth += axis.bounds.width;\n                }\n            });\n            nearAxisWidth += this.gauge.containerBounds.width / 2;\n            farAxisWidth += this.gauge.containerBounds.width / 2;\n            tranX = (nearAxisWidth / 2) - (farAxisWidth / 2);\n            this.axisObject.setAttribute('transform', 'translate(' + tranX + ',0)');\n            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.gauge.containerObject))) {\n                this.gauge.containerObject.setAttribute('transform', 'translate(' + tranX + ',0)');\n            }\n        }\n        else {\n            axes.forEach(function (axis) {\n                if (!axis.opposedPosition) {\n                    nearAxisWidth += axis.bounds.height;\n                }\n                else {\n                    farAxisWidth += axis.bounds.height;\n                }\n            });\n            nearAxisWidth += (this.gauge.containerBounds.height / 2);\n            farAxisWidth += (this.gauge.containerBounds.height / 2);\n            transY = (nearAxisWidth / 2) - (farAxisWidth / 2);\n            this.axisObject.setAttribute('transform', 'translate(0,' + transY + ')');\n            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.gauge.containerObject))) {\n                this.gauge.containerObject.setAttribute('transform', 'translate(0,' + transY + ')');\n            }\n        }\n    };\n    AxisRenderer.prototype.drawAxisLine = function (axis, axisObject, axisIndex) {\n        var options;\n        var rect = axis.lineBounds;\n        var path = '';\n        var color = axis.line.color || this.gauge.themeStyle.lineColor;\n        if (axis.line.width > 0) {\n            path = 'M' + rect.x + ' ' + rect.y + ' L ' + (this.gauge.orientation === 'Vertical' ? rect.x : rect.x + rect.width) +\n                ' ' + (this.gauge.orientation === 'Vertical' ? rect.y + rect.height : rect.y) + 'z';\n            options = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.gauge.element.id + '_AxisLine_' + axisIndex, color, axis.line.width, color, 1, axis.line.dashArray, path);\n            var axisElement = this.gauge.renderer.drawPath(options);\n            if (this.gauge.allowLoadingAnimation) {\n                axisElement.classList.add(this.gauge.element.id + 'animation');\n            }\n            axisObject.appendChild(axisElement);\n        }\n    };\n    AxisRenderer.prototype.drawTicks = function (axis, ticks, axisObject, tickID, tickBounds, axisIndex) {\n        var tickPath = '';\n        var pointY;\n        var pointX;\n        var range = axis.visibleRange;\n        var line = axis.lineBounds;\n        var majorTickColor = axis.majorTicks.color || this.gauge.themeStyle.majorTickColor;\n        var minorTickColor = axis.minorTicks.color || this.gauge.themeStyle.minorTickColor;\n        var tickColor = (tickID === 'MajorTicks') ? majorTickColor : minorTickColor;\n        var interval = ((tickID === 'MajorTicks') ? axis.majorInterval : axis.minorInterval);\n        var tickHeight = (axis.minimum !== axis.maximum) ? ticks.height : 0;\n        // let position: string = (tickID === 'MajorTicks') ? axis.majorTicks.position : axis.minorTicks.position;\n        for (var i = range.min; (i <= range.max && interval > 0); i += interval) {\n            if ((tickID === 'MajorTicks') || (tickID === 'MinorTicks')) {\n                if (this.gauge.orientation === 'Vertical') {\n                    // pointX =  position === \"Inside\" ? tickBounds.x : tickBounds.x + ticks.height;\n                    pointX = tickBounds.x;\n                    pointY = ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(i, axis, this.gauge.orientation, range) * line.height) + line.y;\n                    tickPath = tickPath.concat('M' + pointX + ' ' + pointY + ' ' + 'L' + (pointX + tickHeight) + ' ' + pointY + ' ');\n                }\n                else {\n                    pointX = ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(i, axis, this.gauge.orientation, range) * line.width) + line.x;\n                    // pointY = position === \"Inside\" ? tickBounds.y : (tickBounds.y + ticks.height);\n                    pointY = tickBounds.y;\n                    tickPath = tickPath.concat('M' + pointX + ' ' + pointY + ' ' + 'L' + pointX + ' ' + (pointY + tickHeight) + ' ');\n                }\n            }\n        }\n        var options = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.gauge.element.id + '_' + tickID + 'Line_' + axisIndex, tickColor, ticks.width, tickColor, 1, null, tickPath);\n        var tickElement = this.gauge.renderer.drawPath(options);\n        if (this.gauge.allowLoadingAnimation) {\n            tickElement.classList.add(this.gauge.element.id + 'animation');\n        }\n        axisObject.appendChild(tickElement);\n    };\n    AxisRenderer.prototype.drawAxisLabels = function (axis, axisObject, axisIndex) {\n        /* eslint-disable max-len */\n        var options;\n        var pointX;\n        var pointY;\n        var rect = axis.lineBounds;\n        var bounds = axis.labelBounds;\n        var tick = axis.majorTickBounds;\n        var labelSize;\n        var range = axis.visibleRange;\n        var anchor;\n        var baseline;\n        var padding = 5;\n        var fontColor = this.gauge.themeStyle.labelColor;\n        var labelColor;\n        var offset = axis.labelStyle.offset;\n        var labelLength = axis.visibleLabels.length - 1;\n        var labelElement = this.gauge.renderer.createGroup({ id: this.gauge.element.id + '_AxisLabelsGroup_' + axisIndex });\n        for (var i = 0; i < axis.visibleLabels.length; i++) {\n            labelSize = axis.visibleLabels[i].size;\n            labelColor = axis.labelStyle.useRangeColor ? (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getRangeColor)(axis.visibleLabels[i].value, axis.ranges) : null;\n            labelColor = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(labelColor) ? (axis.labelStyle.font.color || fontColor) : labelColor;\n            if (this.gauge.orientation === 'Vertical') {\n                pointY = ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.height) + rect.y;\n                pointX = axis.labelStyle.position === 'Auto' ? (!axis.opposedPosition ? (tick.x - labelSize.width - padding) + offset : bounds.x) : bounds.x;\n                pointY += (labelSize.height / 4);\n                axis.visibleLabels[i].x = pointX;\n                axis.visibleLabels[i].y = pointY;\n            }\n            else {\n                if ((i === 0 || i === labelLength) && this.gauge.edgeLabelPlacement !== 'None') {\n                    if (this.gauge.edgeLabelPlacement === 'Shift') {\n                        pointX = i === 0 ? ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x + (!axis.isInversed ? (axis.visibleLabels[i].size.width / 2) : (-axis.visibleLabels[i].size.width / 2))\n                            : ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x - (!axis.isInversed ? (axis.visibleLabels[i].size.width / 2) : (-axis.visibleLabels[i].size.width / 2));\n                        if (this.gauge.allowMargin) {\n                            if (i === labelLength) {\n                                if (!axis.isInversed && (pointX - (axis.visibleLabels[i].size.width / 2)) < (axis.visibleLabels[i - 1].x + (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    pointX += (axis.visibleLabels[i].size.width / 2);\n                                }\n                                else if (axis.isInversed && (pointX + (axis.visibleLabels[i].size.width / 2)) > (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    pointX -= (axis.visibleLabels[i].size.width / 2);\n                                }\n                            }\n                        }\n                    }\n                    else if (this.gauge.edgeLabelPlacement === 'Trim') {\n                        pointX = ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x;\n                        if (i === labelLength) {\n                            if (!this.gauge.allowMargin) {\n                                if (!axis.isInversed && this.gauge.margin.right <= 10) {\n                                    var maxWidth = axis.visibleLabels[i].size.width * 0.75;\n                                    axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(maxWidth, axis.visibleLabels[i].text, axis.labelStyle.font);\n                                }\n                                else if (axis.isInversed && (pointX + (axis.visibleLabels[i].size.width / 2)) > (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    var maxWidth = axis.visibleLabels[i].size.width - ((pointX + (axis.visibleLabels[i].size.width / 2)) - (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2)) + 2);\n                                    axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(maxWidth, axis.visibleLabels[i].text, axis.labelStyle.font);\n                                }\n                            }\n                            else {\n                                if (axis.isInversed && (pointX + (axis.visibleLabels[i].size.width / 2)) > (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    var width = axis.visibleLabels[i].size.width - ((pointX + (axis.visibleLabels[i].size.width / 2)) - (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2)) + 2);\n                                    axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(width, axis.visibleLabels[i].text, axis.labelStyle.font);\n                                }\n                                else if (!axis.isInversed && (pointX - (axis.visibleLabels[i].size.width / 2)) < (axis.visibleLabels[i - 1].x + (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    var width = axis.visibleLabels[i].size.width - ((axis.visibleLabels[i - 1].x + (axis.visibleLabels[i - 1].size.width / 2)) - (pointX - (axis.visibleLabels[i].size.width / 2)) + 2);\n                                    axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(width, axis.visibleLabels[i].text, axis.labelStyle.font);\n                                }\n                            }\n                        }\n                    }\n                    else if (this.gauge.edgeLabelPlacement === 'Auto') {\n                        if (!this.gauge.allowMargin) {\n                            pointX = i === labelLength ? ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x - (!axis.isInversed ? (axis.visibleLabels[i].size.width / 2) : (-axis.visibleLabels[i].size.width / 2)) :\n                                ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x + (!axis.isInversed ? (axis.visibleLabels[i].size.width / 2) : (-axis.visibleLabels[i].size.width / 2));\n                            if (i === labelLength) {\n                                if (!axis.isInversed && (pointX - (axis.visibleLabels[i].size.width / 2)) < (axis.visibleLabels[i - 1].x + (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    pointX += (axis.visibleLabels[i].size.width / 2);\n                                    var maxWidth = axis.visibleLabels[i].size.width * 0.75;\n                                    axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(maxWidth, axis.visibleLabels[i].text, axis.labelStyle.font);\n                                }\n                                else if (axis.isInversed && (pointX + (axis.visibleLabels[i].size.width / 2)) > (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2))) {\n                                    pointX -= (axis.visibleLabels[i].size.width / 2);\n                                    var widthValue = axis.visibleLabels[i].size.width - ((pointX + (axis.visibleLabels[i].size.width / 2)) - (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2)) + 2);\n                                    axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(widthValue, axis.visibleLabels[i].text, axis.labelStyle.font);\n                                }\n                            }\n                        }\n                        else {\n                            pointX = ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x;\n                            if (i === labelLength && axis.isInversed && (pointX + (axis.visibleLabels[i].size.width / 2)) > (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2))) {\n                                var labelWidth = axis.visibleLabels[i].size.width - ((pointX + (axis.visibleLabels[i].size.width / 2)) - (axis.visibleLabels[i - 1].x - (axis.visibleLabels[i - 1].size.width / 2)) + 2);\n                                axis.visibleLabels[i].text = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(labelWidth, axis.visibleLabels[i].text, axis.labelStyle.font);\n                            }\n                        }\n                    }\n                    pointY = bounds.y;\n                    axis.visibleLabels[i].x = pointX;\n                    axis.visibleLabels[i].y = pointY;\n                    anchor = 'middle';\n                    baseline = '';\n                }\n                else {\n                    pointX = ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis, this.gauge.orientation, range) * rect.width) + rect.x;\n                    pointY = bounds.y;\n                    anchor = 'middle';\n                    baseline = '';\n                    axis.visibleLabels[i].x = pointX;\n                    axis.visibleLabels[i].y = pointY;\n                }\n            }\n            var style = {\n                size: axis.labelStyle.font.size,\n                color: axis.labelStyle.font.color,\n                fontFamily: axis.labelStyle.font.fontFamily,\n                fontWeight: axis.labelStyle.font.fontWeight,\n                fontStyle: axis.labelStyle.font.fontStyle,\n                opacity: axis.labelStyle.font.opacity\n            };\n            style.fontFamily = style.fontFamily || this.gauge.themeStyle.labelFontFamily;\n            style.fontStyle = style.fontStyle || this.gauge.themeStyle.labelStyle;\n            style.fontWeight = style.fontWeight || this.gauge.themeStyle.labelWeight;\n            options = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.TextOption(this.gauge.element.id + '_Axis_' + axisIndex + '_Label_' + i, pointX, pointY, anchor, axis.visibleLabels[i].text, null, baseline);\n            var axisLabelsElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(options, style, labelColor, null, labelElement);\n            axisLabelsElement.setAttribute('aria-label', axis.visibleLabels[i].text);\n            axisLabelsElement.setAttribute('role', 'region');\n        }\n        if (this.gauge.allowLoadingAnimation) {\n            labelElement.classList.add(this.gauge.element.id + 'animation');\n        }\n        axisObject.appendChild(labelElement);\n    };\n    AxisRenderer.prototype.drawPointers = function (axis, axisObject, axisIndex) {\n        var pointer;\n        var clipId;\n        var pointerClipRectGroup;\n        var pointesGroup = this.gauge.renderer.createGroup({ id: this.gauge.element.id + '_PointersGroup_' + axisIndex });\n        for (var i = 0; i < axis.pointers.length; i++) {\n            pointer = axis.pointers[i];\n            clipId = 'url(#' + this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + '_' + pointer.type + 'ClipRect_' + i + ')';\n            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointer.bounds))) {\n                pointerClipRectGroup = this.gauge.renderer.createGroup({\n                    'id': this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + pointer.type + 'PointerGroup_' + i\n                });\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointer.startValue)) {\n                    pointer.startValue = axis.visibleRange.min;\n                }\n                if ((_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable' || pointer.animationDuration > 0 || this.gauge.allowLoadingAnimation) && (!this.gauge.isPropertyChange || pointer['isPointerAnimation']) && !this.gauge.gaugeResized) {\n                    pointer.startValue = !this.gauge.isPropertyChange ? axis.minimum : pointer.startValue;\n                    if (this.gauge.container.type === 'Thermometer' && pointer.startValue === 0) {\n                        pointerClipRectGroup.setAttribute('clip-path', clipId);\n                    }\n                }\n                this['draw' + pointer.type + 'Pointer'](axis, axisIndex, pointer, i, pointerClipRectGroup);\n                pointesGroup.appendChild(pointerClipRectGroup);\n            }\n        }\n        this.gauge.gradientCount = 0;\n        axisObject.appendChild(pointesGroup);\n    };\n    AxisRenderer.prototype.drawMarkerPointer = function (axis, axisIndex, pointer, pointerIndex, parentElement) {\n        var options;\n        var textOptions;\n        var style = {};\n        var pointerID = this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + pointer.type + 'Pointer' + '_' + pointerIndex;\n        var transform = 'translate( 0, 0 )';\n        var x;\n        var y;\n        var pointerElement;\n        var gradientMarkerColor;\n        if (this.gauge.gradientModule) {\n            gradientMarkerColor = this.gauge.gradientModule.getGradientColorString(pointer);\n        }\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID) && (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID).childElementCount > 0) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID));\n        }\n        var pointerColor = pointer.color || this.gauge.themeStyle.pointerColor;\n        var shapeBasedOnPosition = pointer.markerType;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointer.position) && (pointer.markerType === 'InvertedTriangle' ||\n            pointer.markerType === 'Triangle')) {\n            shapeBasedOnPosition = (((pointer.position === 'Outside' && !axis.opposedPosition) ||\n                (pointer.position === 'Inside' && axis.opposedPosition) || pointer.position === 'Cross')\n                && pointer.markerType === 'Triangle' ? 'InvertedTriangle' :\n                (((pointer.position === 'Inside' && !axis.opposedPosition) || (pointer.position === 'Outside' && axis.opposedPosition)) &&\n                    pointer.markerType === 'InvertedTriangle' ? 'Triangle' : pointer.markerType));\n        }\n        options = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.PathOption(pointerID, (gradientMarkerColor) ? gradientMarkerColor : pointerColor, pointer.border.width, pointer.border.color, pointer.opacity, pointer.border.dashArray, null, transform);\n        options = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.calculateShapes)(pointer.bounds, shapeBasedOnPosition, new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.Size(pointer.width, pointer.height), pointer.imageUrl, options, this.gauge.orientation, axis, pointer);\n        if (pointer.markerType === 'Text') {\n            textOptions = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.TextOption(pointerID, x, y, 'start', pointer.text, null, 'auto');\n            textOptions = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.calculateTextPosition)(pointer.bounds, shapeBasedOnPosition, textOptions, this.gauge.orientation, axis, pointer);\n            style = {\n                size: pointer.textStyle.size,\n                fontFamily: pointer.textStyle.fontFamily || this.gauge.themeStyle.labelFontFamily,\n                fontWeight: pointer.textStyle.fontWeight,\n                fontStyle: pointer.textStyle.fontStyle\n            };\n        }\n        // eslint-disable-next-line prefer-const\n        pointerElement = ((pointer.markerType === 'Circle' ? this.gauge.renderer.drawCircle(options)\n            : (pointer.markerType === 'Image') ? this.gauge.renderer.drawImage(options) : (pointer.markerType === 'Text') && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointer.text) ? (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(textOptions, style, (gradientMarkerColor) ? gradientMarkerColor : pointerColor, pointer.opacity, parentElement) :\n                this.gauge.renderer.drawPath(options)));\n        if (this.gauge.allowLoadingAnimation) {\n            pointerElement.style.visibility = 'hidden';\n        }\n        parentElement.appendChild(pointerElement);\n        if ((((pointer.animationDuration > 0 || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') && (!this.gauge.allowLoadingAnimation || this.gauge.isPropertyChange)) && (!this.gauge.isPropertyChange || pointer['isPointerAnimation']) && pointer['startValue'] !== pointer.currentValue) && !this.gauge.isPointerAnimationInProgress) {\n            pointer.startValue = !this.gauge.isPropertyChange ? axis.minimum : pointer.startValue;\n            pointer.animationComplete = false;\n            this.performMarkerAnimation(pointerElement, axis, pointer);\n        }\n        if (!this.gauge.allowLoadingAnimation && pointer.animationDuration === 0) {\n            pointer.startValue = pointer.currentValue;\n        }\n        pointerElement.setAttribute('aria-label', pointer.description || 'Pointer:' + Number(pointer.currentValue).toString());\n        pointerElement.setAttribute('role', 'region');\n    };\n    AxisRenderer.prototype.drawBarPointer = function (axis, axisIndex, pointer, pointerIndex, parentElement) {\n        var rectOptions;\n        var clipRectElement;\n        var pointerElement;\n        var path = '';\n        var options;\n        var box;\n        var size = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.Size(this.gauge.availableSize.width, this.gauge.availableSize.height);\n        var pointerID = this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + pointer.type + 'Pointer' + '_' + pointerIndex;\n        var gradientBarColor;\n        if (this.gauge.gradientModule) {\n            gradientBarColor = this.gauge.gradientModule.getGradientColorString(pointer);\n        }\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID) && (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID).childElementCount > 0) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID));\n        }\n        if (this.gauge.container.type === 'Normal' || this.gauge.container.width === 0) {\n            rectOptions = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.RectOption(pointerID, (gradientBarColor) ?\n                gradientBarColor : pointer.color || this.gauge.themeStyle.pointerColor, pointer.border, pointer.opacity, pointer.bounds);\n            box = pointer.bounds;\n            pointerElement = this.gauge.renderer.drawRectangle(rectOptions);\n        }\n        else {\n            path = pointer.value > axis.minimum || this.gauge.container.type === 'Thermometer' ? (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getBox)(pointer.bounds, this.gauge.container.type, this.gauge.orientation, new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.Size(pointer.bounds.width, pointer.bounds.height), 'bar', this.gauge.container.width, axis, pointer.roundedCornerRadius) : '';\n            options = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.PathOption(pointerID, (gradientBarColor) ? gradientBarColor : pointer.color || this.gauge.themeStyle.pointerColor, pointer.border.width, pointer.border.color, pointer.opacity, pointer.border.dashArray, path);\n            pointerElement = this.gauge.renderer.drawPath(options);\n            box = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getPathToRect)(pointerElement.cloneNode(true), size, this.gauge.element);\n        }\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID) && (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID).childElementCount > 0) {\n            var element = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(pointerID).firstElementChild;\n            if (this.gauge.container.type === 'Normal') {\n                element.setAttribute('x', rectOptions.x + '');\n                element.setAttribute('y', rectOptions.y + '');\n                element.setAttribute('width', rectOptions.width + '');\n                element.setAttribute('height', rectOptions.height + '');\n            }\n            else {\n                element.setAttribute('d', options.d);\n            }\n        }\n        else {\n            parentElement.appendChild(pointerElement);\n        }\n        pointerElement.setAttribute('aria-label', pointer.description || 'Pointer:' + Number(pointer.currentValue).toString());\n        pointerElement.setAttribute('role', 'region');\n        if (this.gauge.allowLoadingAnimation) {\n            pointerElement.style.visibility = 'hidden';\n        }\n        if (((pointer.animationDuration > 0 || this.gauge.allowLoadingAnimation || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') && (!this.gauge.isPropertyChange || pointer['isPointerAnimation']) && pointer['startValue'] !== pointer.currentValue) && !this.gauge.isPointerAnimationInProgress) {\n            pointer.startValue = !this.gauge.isPropertyChange ? axis.minimum : pointer.startValue;\n            if (this.gauge.container.type === 'Thermometer' && pointer.startValue === 0 && this.gauge.container.width > 0) {\n                clipRectElement = this.gauge.renderer.drawClipPath(new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.RectOption(this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + '_' + pointer.type + 'ClipRect_' + pointerIndex, 'transparent', { width: 1, color: 'Gray' }, 1, box));\n                parentElement.appendChild(clipRectElement);\n            }\n            if (!this.gauge.allowLoadingAnimation || this.gauge.isPropertyChange) {\n                pointer.isPointerAnimation = false;\n                this.performBarAnimation(pointerElement, axis, pointer);\n            }\n        }\n        if (pointer.animationDuration === 0) {\n            pointer.startValue = pointer.currentValue;\n        }\n    };\n    /**\n     * @param {Axis} axis - Specifies the axis\n     * @param {number} axisIndex - Specifies the axis index\n     * @returns {void}\n     * @private\n     */\n    AxisRenderer.prototype.pointerAnimation = function (axis, axisIndex) {\n        if ((!this.gauge.isPointerAnimationInProgress && this.gauge.allowLoadingAnimation)) {\n            this.gauge.isPointerAnimationInProgress = true;\n            for (var i = 0; i < axis.pointers.length; i++) {\n                var pointer = axis.pointers[i];\n                if (pointer.type === 'Bar') {\n                    var barPointerGroup = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + pointer.type + 'Pointer_' + i);\n                    if (barPointerGroup) {\n                        this.performBarAnimation(barPointerGroup, axis, pointer);\n                    }\n                }\n                else {\n                    var markerPointerGroup = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.gauge.element.id + '_AxisIndex_' + axisIndex + '_' + pointer.type + 'Pointer_' + i);\n                    if (markerPointerGroup) {\n                        this.performMarkerAnimation(markerPointerGroup, axis, pointer);\n                    }\n                }\n            }\n        }\n    };\n    AxisRenderer.prototype.drawRanges = function (axis, axisObject, axisIndex) {\n        var range;\n        var options;\n        var rangeElement = this.gauge.renderer.createGroup({ id: this.gauge.element.id + '_RangesGroup_' + axisIndex });\n        if (this.gauge.allowLoadingAnimation) {\n            rangeElement.classList.add(this.gauge.element.id + 'animation');\n        }\n        for (var j = 0; j < axis.ranges.length; j++) {\n            range = axis.ranges[j];\n            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(range.path))) {\n                options = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.gauge.element.id + '_AxisIndex_' + axisIndex + '_Range_' + j, range.interior, (range.start !== range.end) ? range.border.width : 0, range.border.color, 1, range.border.dashArray, range.path);\n                rangeElement.appendChild(this.gauge.renderer.drawPath(options));\n            }\n        }\n        axisObject.appendChild(rangeElement);\n    };\n    AxisRenderer.prototype.updateTextPointer = function (pointerId, pointer, axis) {\n        var x;\n        var y;\n        var textOptions = new _utils_helper__WEBPACK_IMPORTED_MODULE_2__.TextOption(pointerId, x, y, 'start', pointer.text, null, 'auto');\n        textOptions = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.calculateTextPosition)(pointer.bounds, 'Text', textOptions, this.gauge.orientation, axis, pointer);\n        var textElement = document.getElementById(pointerId);\n        textElement.setAttribute('x', textOptions.x.toString());\n        textElement.setAttribute('y', textOptions.y.toString());\n        textElement.textContent = pointer.text;\n    };\n    /**\n     * @private\n     */\n    AxisRenderer.prototype.destroy = function () {\n        this.htmlObject = null;\n        this.axisObject = null;\n        this.axisElements = [];\n        this.gauge = null;\n    };\n    return AxisRenderer;\n}(_animation__WEBPACK_IMPORTED_MODULE_1__.Animations));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/axis-renderer.js?");

/***/ })

}]);