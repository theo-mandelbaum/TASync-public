"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_data-label_js-6dc8bf4a"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataLabel: () => (/* binding */ DataLabel)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n\n\n\n\n\n/**\n * The `DataLabel` module is used to render data labels for data points.\n */\nvar DataLabel = /** @class */ (function () {\n    /**\n     * Constructor for the data label module.\n     *\n     * @private\n     */\n    function DataLabel(chart) {\n        this.errorHeight = 0;\n        /** @private */\n        this.dataLabelRectCollection = {};\n        this.chart = chart;\n    }\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\n        var transform = '';\n        var clipPath = '';\n        var render = series.chart.renderer;\n        var index = (series.index === undefined) ? series.category : series.index;\n        if (series.chart.chartAreaType === 'Cartesian') {\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n        }\n        if (marker.dataLabel.visible && !this.chart.enableCanvas) {\n            series.shapeElement = render.createGroup({\n                'id': this.chart.element.id + 'ShapeGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n            });\n            series.textElement = render.createGroup({\n                'id': this.chart.element.id + 'TextGroup' + index,\n                'transform': transform,\n                'clip-path': clipPath\n            });\n            series.textElement.setAttribute('aria-hidden', 'true');\n        }\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n    };\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\n        if (!series.errorBar.visible) {\n            return null;\n        }\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n            var direction = series.errorBar.direction;\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\n            if (this.isRectSeries(series)) {\n                if (position === 'Top' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Outer' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Plus') {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n            else {\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Bottom' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n        }\n        else {\n            this.errorHeight = 0;\n        }\n    };\n    DataLabel.prototype.isRectSeries = function (series) {\n        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea';\n    };\n    /**\n     * Render the data label for series.\n     *\n     * @param {Series} series - The series to render.\n     * @param {Chart} chart - The parent chart.\n     * @param {DataLabelSettingsModel} dataLabel - The settings for data labels.\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\n        // initialize the private variable\n        this.initPrivateVariables(series, series.marker);\n        this.inverted = chart.requireInvertedAxis;\n        this.yAxisInversed = series.yAxis.isAxisInverse;\n        var templateId = chart.element.id + '_Series_' +\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n        var element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.createElement)('div', {\n            id: templateId\n        });\n        var visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getVisiblePoints)(series);\n        // Data label point iteration started\n        if (series.visible) {\n            for (var i = 0; i < visiblePoints.length; i++) {\n                this.renderDataLabel(series, visiblePoints[i], element, dataLabel);\n            }\n        }\n        if (element.childElementCount) {\n            if (!chart.enableCanvas) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(chart.enableCanvas, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(chart.element.id + '_Secondary_Element'), element, chart.redraw, false, 'x', 'y', null, '', false, false, null, chart.duration);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(chart.element.id + '_Secondary_Element').appendChild(element);\n            }\n        }\n    };\n    DataLabel.prototype.renderDataLabel = function (series, point, element, dataLabel) {\n        if (!dataLabel.showZero && ((point.y === 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\n            return null;\n        }\n        this.margin = dataLabel.margin;\n        var labelText = [];\n        var labelLength;\n        var xPos;\n        var yPos;\n        var xValue;\n        var yValue;\n        var degree;\n        var rectCenterX;\n        var rectCenterY;\n        var labelLocation = { x: 0, y: 0 };\n        var textSize;\n        var clip = series.clipRect;\n        var shapeRect;\n        var isDataLabelOverlap = false;\n        var dataLabelElement = [];\n        var startLocation;\n        dataLabel.angle = dataLabel.labelIntersectAction === 'Rotate90' ? 90 : dataLabel.angle;\n        dataLabel.enableRotation = dataLabel.labelIntersectAction === 'Rotate90' ? true : dataLabel.enableRotation;\n        var angle = degree = dataLabel.angle;\n        var border = { width: dataLabel.border.width, color: dataLabel.border.color };\n        var argsFont = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.getValue)('properties', dataLabel.font), null, true));\n        if ((point.symbolLocations.length && point.symbolLocations[0]) ||\n            (series.type === 'BoxAndWhisker' && point.regions.length)) {\n            labelText = point.text !== null ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getLabelText)(point, series, this.chart) : [];\n            labelLength = labelText.length;\n            for (var i = 0; i < labelLength; i++) {\n                var argsData = {\n                    cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_2__.textRender, series: series,\n                    point: point, text: labelText[i], border: border,\n                    color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\n                    textSize: (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(labelText[i], dataLabel.font, this.chart.themeStyle.datalabelFont)\n                };\n                this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_2__.textRender, argsData);\n                if (!argsData.cancel) {\n                    this.fontBackground = argsData.color;\n                    this.isDataLabelShape(argsData);\n                    this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\n                    if (argsData.template !== null) {\n                        this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i, this.chart.redraw);\n                    }\n                    else {\n                        if (dataLabel.enableRotation) {\n                            textSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.rotateTextSize)(dataLabel.font, argsData.text, dataLabel.angle, this.chart, this.chart.themeStyle.datalabelFont);\n                        }\n                        else {\n                            textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(argsData.text, dataLabel.font, this.chart.themeStyle.datalabelFont);\n                        }\n                        var rect = this.calculateTextPosition(point, series, textSize, dataLabel, i);\n                        var actualRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n                        //let notOverlapping: boolean;\n                        if (dataLabel.enableRotation) {\n                            var rectCoordinates = this.getRectanglePoints(actualRect);\n                            rectCenterX = rect.x + (rect.width / 2);\n                            rectCenterY = (rect.y + (rect.height / 2));\n                            isDataLabelOverlap = (dataLabel.labelIntersectAction === 'Rotate90' || angle === -90) ? false : this.isDataLabelOverlapWithChartBound(rectCoordinates, this.chart, { x: 0, y: 0, width: 0, height: 0 });\n                            if (!isDataLabelOverlap) {\n                                this.chart.rotatedDataLabelCollections.push(rectCoordinates);\n                                var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                                for (var index = currentPointIndex; index >= 0; index--) {\n                                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\n                                        this.chart.rotatedDataLabelCollections[index - 1] &&\n                                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isRotatedRectIntersect)(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                                        isDataLabelOverlap = true;\n                                        this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            isDataLabelOverlap = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isCollide)(rect, this.chart.dataLabelCollections, clip);\n                        }\n                        if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None')) {\n                            var dataLabelShapeElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(this.commonId + point.index + '_TextShape_' + i);\n                            if (dataLabelShapeElement) {\n                                startLocation = { x: +dataLabelShapeElement.getAttribute('x'), y: +dataLabelShapeElement.getAttribute('y') };\n                            }\n                            this.chart.dataLabelCollections.push(actualRect);\n                            if (this.isShape) {\n                                shapeRect = this.chart.renderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.RectOption(this.commonId + point.index + '_TextShape_' + i, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry, '', dataLabel.border.dashArray), new Int32Array([clip.x, clip.y]));\n                                if (series.shapeElement) {\n                                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(this.chart.enableCanvas, series.shapeElement, shapeRect, this.chart.redraw, true, 'x', 'y', startLocation);\n                                }\n                            }\n                            // Checking the font color\n                            var backgroundColor = this.fontBackground === 'transparent' ? ((this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('HighContrast') > -1) ? 'black' : 'white') : this.fontBackground;\n                            var rgbValue = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertHexToColor)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.colorNameToHex)(backgroundColor));\n                            var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                            xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\n                            yPos = dataLabel.enableRotation && this.chart.chartAreaType !== 'PolarRadar' ? (rect.y + this.margin.top + textSize.height / 2 + textSize.width / 4 + (dataLabel.position === 'Auto' ? point.regions[0].width / 10 : 0)) + labelLocation.y : (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\n                            labelLocation = { x: 0, y: 0 };\n                            if (angle !== 0 && dataLabel.enableRotation) {\n                                // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                                xValue = rectCenterX;\n                                //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                                // (dataLabel.margin.bottom) / 2;\n                                yValue = rectCenterY;\n                                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                            }\n                            else {\n                                degree = 0;\n                                xValue = rect.x;\n                                yValue = rect.y;\n                                xPos -= this.chart.chartAreaType === 'Cartesian' && xPos + (textSize.width / 2) > clip.width ? (!this.chart.requireInvertedAxis && xPos > clip.width) ? 0 : (xPos + textSize.width / 2) - clip.width : 0;\n                                yPos -= (yPos + textSize.height > clip.y + clip.height && !(series.type.indexOf('Bar') > -1)) ? (yPos + textSize.height) - (clip.y + clip.height) : 0;\n                            }\n                            var textAnchor = dataLabel.labelIntersectAction === 'Rotate90' ? (dataLabel.position === 'Top' ? 'start' : (dataLabel.position === 'Middle' ? 'middle' : 'end')) :\n                                ((angle === -90 && dataLabel.enableRotation) ? (dataLabel.position === 'Top' ? 'end' : (dataLabel.position === 'Middle' ? 'middle' : 'start')) : 'middle');\n                            var oldText = void 0;\n                            if (this.chart.redraw && document.getElementById(this.commonId + point.index + '_Text_' + i)) {\n                                oldText = document.getElementById(this.commonId + point.index + '_Text_' + i).textContent;\n                            }\n                            dataLabelElement.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textElement)(this.chart.renderer, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.TextOption(this.commonId + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index) + '_Text_' + i, xPos, yPos, textAnchor, argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color || (this.chart.theme === 'Bootstrap5' ? '#212529' : this.chart.theme === 'Bootstrap5Dark' ? '#DEE2E6' : ((contrast >= 128 || series.type === 'Hilo' || series.type === 'HiloOpenClose') ?\n                                this.chart.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : this.chart.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white')), series.textElement, false, this.chart.redraw, true, false, series.chart.duration, series.clipRect, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.datalabelFont, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(xValue, yValue)));\n                            if (this.isShape && dataLabel.enableRotation) {\n                                shapeRect.setAttribute('transform', 'rotate(' + dataLabel.angle + ', ' + xValue + ', ' + yValue + ')');\n                            }\n                            if (this.chart.stackLabels.visible && series.type.indexOf('Stacking') > -1) {\n                                this.dataLabelRectCollection = !this.dataLabelRectCollection ? {}\n                                    : this.dataLabelRectCollection;\n                                this.dataLabelRectCollection[this.commonId + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index) + '_Text_' + i] = actualRect;\n                                this.dataLabelRectCollection[this.commonId + point.index + '_TextShape_' + i] = actualRect;\n                            }\n                            if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n                                series.textElement.lastChild.id = this.commonId + point.index + '_Text_' + i;\n                            }\n                            if (this.chart.redraw && oldText !== argsData.text) {\n                                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateTextElement)(series.textElement.querySelector('#' + this.commonId + point.index + '_Text_' + i), this.chart.duration, parseFloat(oldText), parseFloat(argsData.text), series.marker.dataLabel.format || series.yAxis.labelFormat);\n                            }\n                        }\n                        else if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(this.commonId + point.index + '_Text_0') && series.chart.redraw && series.currentData) {\n                            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(this.commonId + point.index + '_Text_0').remove();\n                        }\n                    }\n                }\n            }\n        }\n        return dataLabelElement;\n    };\n    /**\n     * Renders the stack labels for the chart.\n     *\n     * This method is responsible for displaying cumulative total values on stacked chart segments.\n     *\n     * @returns {void}\n     */\n    DataLabel.prototype.renderStackLabels = function () {\n        var _this = this;\n        var stackLabelGroup = this.chart.renderer.createGroup({ id: this.chart.element.id + \"_StackLabelGroup\" });\n        this.chart.seriesElements.appendChild(stackLabelGroup);\n        var positivePoints = {};\n        var negativePoints = {};\n        if (this.chart.visibleSeries && this.chart.visibleSeries.length > 0) {\n            for (var seriesIndex = this.chart.visibleSeries.length - 1; seriesIndex >= 0; seriesIndex--) {\n                var series = this.chart.visibleSeries[seriesIndex];\n                if (series.animation.enable && this.chart.animateSeries) {\n                    stackLabelGroup.setAttribute('visibility', 'hidden');\n                }\n                if (series.visible && series.points && series.points.length > 0) {\n                    for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {\n                        var point = series.points[pointIndex];\n                        var pointXValueAsKey = String(point.x);\n                        if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0\n                            && point.visible) {\n                            positivePoints[pointXValueAsKey] = point;\n                        }\n                        if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0\n                            && point.visible) {\n                            negativePoints[pointXValueAsKey] = point;\n                        }\n                    }\n                }\n            }\n        }\n        var stackLabelIndex = 0;\n        [positivePoints, negativePoints].forEach(function (points, index) {\n            if (points) {\n                var totalValue_1 = 0;\n                var currentPoint_1;\n                Object.keys(points).forEach(function (pointXValueAsKey) {\n                    var positiveValue = points[pointXValueAsKey].series\n                        .stackedValues.endValues[points[pointXValueAsKey].index];\n                    var negativeValue = negativePoints[pointXValueAsKey] ?\n                        negativePoints[pointXValueAsKey].series.stackedValues.\n                            endValues[negativePoints[pointXValueAsKey].index] : 0;\n                    if (index === 0) {\n                        // Handle positive points\n                        totalValue_1 = positiveValue + negativeValue;\n                        currentPoint_1 = points[pointXValueAsKey];\n                    }\n                    else if (!positivePoints[pointXValueAsKey]) {\n                        // Handle negative points only if no corresponding positive point\n                        totalValue_1 = positiveValue;\n                        currentPoint_1 = points[pointXValueAsKey];\n                    }\n                    if (currentPoint_1 && currentPoint_1.symbolLocations[0]) {\n                        var series = currentPoint_1.series;\n                        var symbolLocation = currentPoint_1.symbolLocations[0];\n                        var labelFormat = _this.chart.stackLabels.format;\n                        var stackLabeltext = (totalValue_1 % 1 === 0)\n                            ? totalValue_1.toFixed(0)\n                            : (totalValue_1.toFixed(2).slice(-1) === '0' ? totalValue_1.toFixed(1) : totalValue_1.toFixed(2));\n                        if (labelFormat) {\n                            var customLabelFormat = labelFormat.match('{value}') !== null;\n                            stackLabeltext = customLabelFormat\n                                ? labelFormat.replace('{value}', stackLabeltext.toString())\n                                : _this.chart.intl.getNumberFormat({\n                                    format: labelFormat,\n                                    useGrouping: _this.chart.useGroupingSeparator\n                                })(totalValue_1);\n                        }\n                        var textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(stackLabeltext, _this.chart.stackLabels.font, _this.chart.themeStyle.datalabelFont);\n                        // Define padding to maintain a consistent gap from the symbol location values\n                        var padding = 10;\n                        var backgroundColor = _this.chart.stackLabels.fill === 'transparent' && _this.chartBackground === 'transparent' ? ((_this.chart.theme.indexOf('Dark') > -1 || _this.chart.theme.indexOf('HighContrast') > -1) ? 'black' : 'white') : _this.chart.stackLabels.fill !== 'transparent' ? _this.chart.stackLabels.fill : _this.chartBackground;\n                        var rgbValue = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertHexToColor)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.colorNameToHex)(backgroundColor));\n                        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                        var alignmentValue = textSize.width + _this.chart.stackLabels.border.width\n                            + _this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right - padding / 2;\n                        var yOffset = _this.chart.requireInvertedAxis ? padding / 2 :\n                            (_this.chart.primaryYAxis.isInversed ? (index === 0 ? (textSize.height + padding / 2) : -padding)\n                                : (index === 0 ? -padding : (textSize.height + padding / 2)));\n                        var xOffset = _this.chart.requireInvertedAxis ?\n                            ((_this.chart.primaryYAxis.isInversed ? (index === 0 ? -(padding + textSize.width / 2) :\n                                (padding + textSize.width / 2)) : (index === 0 ? (padding + textSize.width / 2) :\n                                -(padding + textSize.width / 2)))) : 0;\n                        xOffset += _this.chart.stackLabels.font.textAlignment === 'Far' ? alignmentValue :\n                            (_this.chart.stackLabels.font.textAlignment === 'Near' ? -alignmentValue : 0);\n                        var xPosition = Math.max(series.clipRect.x + textSize.width, Math.min(xOffset + series.clipRect.x + symbolLocation.x, series.clipRect.x\n                            + series.clipRect.width - textSize.width));\n                        var yPosition = Math.max(series.clipRect.y + textSize.height, Math.min(yOffset + series.clipRect.y + symbolLocation.y -\n                            ((_this.chart.stackLabels.angle > 0 && !_this.chart.requireInvertedAxis) ? textSize.width / 2 : 0), series.clipRect.y + series.clipRect.height - textSize.height));\n                        var rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(xPosition - textSize.width / 2 - _this.chart.stackLabels.margin.left, yPosition - textSize.height - _this.chart.stackLabels.margin.top, textSize.width + (_this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right), textSize.height + padding / 2 + (_this.chart.stackLabels.margin.top + _this.chart.stackLabels.margin.bottom));\n                        var shapeRect = _this.chart.renderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.RectOption(_this.chart.element.id + \"StackLabel_TextShape_\" + stackLabelIndex, _this.chart.stackLabels.fill, _this.chart.stackLabels.border, null, rect, _this.chart.stackLabels.rx, _this.chart.stackLabels.ry, '', null), new Int32Array([symbolLocation.x, symbolLocation.y]));\n                        shapeRect.setAttribute('transform', \"rotate(\" + _this.chart.stackLabels.angle + \", \" + xPosition + \", \" + yPosition + \")\");\n                        stackLabelGroup.appendChild(shapeRect);\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textElement)(_this.chart.renderer, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.TextOption(_this.chart.element.id + \"_StackLabel_\" + stackLabelIndex, xPosition, yPosition, 'middle', stackLabeltext, \"rotate(\" + _this.chart.stackLabels.angle + \", \" + xPosition + \", \" + yPosition + \")\", 'auto', _this.chart.stackLabels.angle), _this.chart.stackLabels.font, (_this.chart.stackLabels.font.color || (_this.chart.theme === 'Bootstrap5' ? '#212529' : _this.chart.theme === 'Bootstrap5Dark' ? '#DEE2E6' : ((contrast >= 128) ?\n                            _this.chart.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : _this.chart.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white'))), stackLabelGroup, null, _this.chart.redraw, true, null, _this.chart.duration, series.clipRect, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.datalabelFont, null);\n                        if (series.type === 'StackingLine' || series.type === 'StackingArea') {\n                            document.querySelectorAll(\"[id^=\\\"\" + _this.chart.element.id + \"_Series_\" + series.index + \"_Point_\" + currentPoint_1.index + \"_Text_\\\"], \\n                                [id^=\\\"\" + _this.chart.element.id + \"_Series_\" + series.index + \"_Point_\" + currentPoint_1.index + \"_TextShape_\\\"]\").forEach(function (element) {\n                                if (element.id) {\n                                    element.style.visibility = 'hidden';\n                                    element.setAttribute('data-collide', 'true');\n                                }\n                            });\n                        }\n                        for (var dataLabelID in _this.dataLabelRectCollection) {\n                            if (Object.prototype.hasOwnProperty.call(_this.dataLabelRectCollection, dataLabelID)) {\n                                var dataLabelRect = _this.dataLabelRectCollection[dataLabelID];\n                                if (dataLabelRect) {\n                                    var isCollided = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isCollide)(rect, [dataLabelRect], { x: 0, y: 0, height: 0, width: 0 });\n                                    if (isCollided) {\n                                        var dataLabelElement = document.getElementById(dataLabelID);\n                                        if (dataLabelElement) {\n                                            dataLabelElement.style.visibility = 'hidden';\n                                            dataLabelElement.setAttribute('data-collide', 'true');\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    stackLabelIndex++;\n                });\n            }\n        });\n    };\n    /**\n     * Retrieves the points of a rectangle.\n     *\n     * @param {Rect} rect - The rectangle whose points are to be retrieved.\n     * @returns {ChartLocation[]} - The points of the rectangle.\n     */\n    DataLabel.prototype.getRectanglePoints = function (rect) {\n        var loc1 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(rect.x, rect.y);\n        var loc2 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(rect.x + rect.width, rect.y);\n        var loc3 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var loc4 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(rect.x, rect.y + rect.height);\n        return [loc1, loc2, loc3, loc4];\n    };\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n        for (var index = 0; index < rectCoordinates.length; index++) {\n            if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInBounds)(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Creates a template for data labels.\n     *\n     * @param {HTMLElement} parentElement - The parent element to which the template will be appended.\n     * @param {Series} series - The series associated with the data label.\n     * @param {DataLabelSettingsModel} dataLabel - The settings for the data label.\n     * @param {Points} point - The data point to which the data label is associated.\n     * @param {ITextRenderEventArgs} data - The event data associated with rendering the data label.\n     * @param {number} labelIndex - The index of the data label.\n     * @param {boolean} redraw - Specifies whether to redraw the template.\n     * @returns {void}\n     */\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        var clip = series.clipRect;\n        var childElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.createTemplate)((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.createElement)('div', {\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\n            styles: 'position: absolute;background-color:' + data.color + ';' +\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getFontStyle)(dataLabel.font, this.chart.themeStyle.datalabelFont) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n        }), point.index, (this.chart.enableHtmlSanitizer ? this.chart.sanitize(data.template) : data.template), this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n    };\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n        var elementRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureElementRect)(childElement, redraw, isReactCallback);\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\n        var clipWidth = 0;\n        var clipHeight = 0;\n        var isOverlap = false;\n        if (isReactCallback) {\n            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call\n            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n        }\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n        if (childElement.childElementCount && !isOverlap && (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isCollide)(rect, this.chart.dataLabelCollections, clip) ||\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\n            (series.type.indexOf('100') > -1 && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n            this.chart.dataLabelCollections.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n                this.doDataLabelAnimation(series, childElement);\n            }\n            else if (this.chart.enableCanvas) {\n                parentElement.appendChild(childElement);\n            }\n        }\n    };\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var location;\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\n        var padding = 5;\n        var clipRect = series.clipRect;\n        // calculating alignment\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n            this.locationX = location.x;\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\n                this.margin.bottom + this.margin.top + padding;\n            location.x = (dataLabel.position === 'Auto') ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n            // calculating position\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n            }\n        }\n        else {\n            this.locationY = location.y;\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n            location.x = dataLabel.position === 'Auto' ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n        }\n        var rect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.calculateRect)(location, textSize, this.margin);\n        // Checking the condition whether data Label has been exist the clip rect\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\n            rect.x = rect.x < 0 ? (series.type === 'StackingColumn' && !this.inverted ? 0 : padding) : rect.x;\n            rect.y = (rect.y < 0 && !this.chart.requireInvertedAxis) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\n                - (clipRect.x + clipRect.width) + padding : 0;\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\n                - (clipRect.y + clipRect.height) + padding : 0;\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        }\n        var dataLabelOutRegion;\n        if (this.inverted && series.isRectSeries && (rect.x + rect.width > labelRegion.x + labelRegion.width)) {\n            dataLabelOutRegion = true;\n        }\n        this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;\n        return rect;\n    };\n    // Calculation label location for polar column draw types\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n        var padding = 5;\n        var columnRadius;\n        var chartWidth = this.chart.availableSize.width;\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n        if (labelIndex === 0) {\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        else {\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        if (series.drawType.indexOf('Stacking') > -1) {\n            position = position === 'Outer' ? 'Top' : position;\n        }\n        else if (series.drawType.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        if (position === 'Outer') {\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\n                columnRadius - 2 * padding - this.markerHeight;\n        }\n        else if (position === 'Middle') {\n            columnRadius = columnRadius / 2 + padding;\n            if (series.drawType === 'StackingColumn') {\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\n                    + padding - (size.height / 2);\n            }\n        }\n        else if (position === 'Top') {\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\n                columnRadius + 2 * padding + this.markerHeight;\n        }\n        else if (position === 'Bottom') {\n            columnRadius = 2 * padding;\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\n        }\n        else {\n            if (labelIndex === 0) {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n            }\n            else {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n            }\n        }\n        columnRadius += (alignmentValue * alignmentSign);\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n        // To change x location based on text anchor for column and stackingcolumn chart\n        if (series.drawType === 'StackingColumn') {\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\n        }\n        else if (series.drawType === 'Column') {\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\n        }\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n        return location;\n    };\n    /**\n     * Gets the location for the data label.\n     *\n     * @param {Points} point - The data point associated with the label.\n     * @param {Series} series - The series associated with the data label.\n     * @param {Size} textSize - The size of the text to be displayed in the data label.\n     * @param {number} labelIndex - The index of the data label.\n     * @returns {ChartLocation} - The location for the data label.\n     */\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n        var location = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(0, 0);\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\n        if (series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var xAxis = series.xAxis;\n        var yAxis = series.yAxis;\n        var isInverted = series.chart.requireInvertedAxis;\n        if (series.type === 'BoxAndWhisker') {\n            this.markerHeight = 0;\n            switch (labelIndex) {\n                case 0:\n                    location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.median, xAxis, yAxis, isInverted);\n                    break;\n                case 1:\n                    location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n                    break;\n                case 2:\n                    location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n                    break;\n                case 3:\n                    location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n                    break;\n                case 4:\n                    location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n                    break;\n                default: {\n                    location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n                    this.markerHeight = series.marker.height / 2;\n                    break;\n                }\n            }\n            if (isInverted) {\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\n            }\n            else {\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\n            }\n        }\n        else if (isInverted && series.type.indexOf('Stacking') > -1 && point.yValue === 0) {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        else if (labelIndex === 0 || labelIndex === 1) {\n            location = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n        }\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n            location = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n        }\n        else if (isInverted) {\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\n        }\n        else {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            if (series.chart.requireInvertedAxis) {\n                var height = labelRegion.height;\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n            else {\n                var width = labelRegion.width;\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n        if (series.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        var padding = 5;\n        var margin = this.margin;\n        var textLength = (series.marker.dataLabel.enableRotation ? textSize.width :\n            (!this.inverted ? textSize.height : textSize.width));\n        if (position === 'Bottom' && series.type === 'StackingColumn' && !this.inverted && rect.height < textSize.height) {\n            this.extraSpace = this.borderWidth + ((Math.abs(rect.height - textSize.height / 2) < padding) ? 0 : padding);\n        }\n        else {\n            this.extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&\n                (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);\n        }\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n            position = (position === 'Outer') ? 'Top' : position;\n        }\n        else if (series.type.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        else if (series.type === 'Waterfall') {\n            position = position === 'Auto' ? 'Middle' : position;\n        }\n        switch (position) {\n            case 'Bottom':\n                labelLocation = !this.inverted ?\n                    isMinus ? (labelLocation + (series.type === 'Waterfall' ? (-this.extraSpace - margin.top - this.markerHeight) : (-rect.height + this.extraSpace + margin.top))) :\n                        (labelLocation + rect.height - this.extraSpace - margin.bottom) :\n                    isMinus ? (labelLocation + (series.type === 'Waterfall' ? (+this.extraSpace + margin.left + this.markerHeight) : (+rect.width - this.extraSpace - margin.left))) :\n                        (labelLocation - rect.width + this.extraSpace + margin.right);\n                break;\n            case 'Middle':\n                labelLocation = labelLocation = !this.inverted ?\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\n                break;\n            case 'Auto':\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n                break;\n            default:\n                this.extraSpace += this.errorHeight;\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, this.extraSpace, isMinus, point);\n                break;\n        }\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\n        this.fontBackground = check ?\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\n        var seriesLength = series.chart.series.length;\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\n            var nextSeries = void 0;\n            var nextSeriesPoint = void 0;\n            for (var i = series.index + 1; i < seriesLength; i++) {\n                nextSeries = series.chart.series[i];\n                nextSeriesPoint = nextSeries.points[point.index];\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\n                        nextSeries.interior) : this.fontBackground;\n                    break;\n                }\n            }\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n        var padding = 5;\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && series.type !== 'RangeStepArea')\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        switch (position) {\n            case 'Top':\n            case 'Outer':\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\n                    this.errorHeight;\n                break;\n            case 'Bottom':\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\n                    this.errorHeight;\n                break;\n            case 'Auto':\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n                break;\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.isDataLabelShape = function (style) {\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\n        this.borderWidth = style.border.width;\n        if (!this.isShape) {\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        }\n    };\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n        var location;\n        var labelRect;\n        var isOverLap = true;\n        var position = 0;\n        var collection = this.chart.dataLabelCollections;\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n        while (isOverLap && position < finalPosition) {\n            var actualPosition = this.getPosition(position);\n            this.fontBackground = series.marker.dataLabel.fill;\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n                actualPosition = 'Top';\n                position++;\n            }\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n            if (!this.inverted) {\n                if (series.marker.dataLabel.enableRotation) {\n                    size.width = size.width - point.regions[0].width / 10;\n                }\n                labelRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.calculateRect)(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(this.locationX, location), size, this.margin);\n                isOverLap = labelRect.y < 0 || (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isCollide)(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n                if (series.marker.dataLabel.template === null && isOverLap !== true) {\n                    isOverLap = labelRect.y / 2 + size.height + (actualPosition === 'Outer' ? point.regions[0].height + this.extraSpace : point.regions[0].height - 2 * this.extraSpace) > series.clipRect.height;\n                }\n            }\n            else {\n                labelRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.calculateRect)(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(location, this.locationY), size, this.margin);\n                isOverLap = labelRect.x < 0 || (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isCollide)(labelRect, collection, series.clipRect) ||\n                    labelRect.x + labelRect.width > series.clipRect.width;\n            }\n            position++;\n        }\n        return location;\n    };\n    // alignment calculation assigned here\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n        switch (alignment) {\n            case 'Far':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\n                    (isMinus ? labelLocation - value : labelLocation + value);\n                break;\n            case 'Near':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\n                    (isMinus ? labelLocation + value : labelLocation - value);\n                break;\n        }\n        return labelLocation;\n    };\n    //calculation for top and outer position of datalabel for rect series\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus, point) {\n        var margin = this.margin;\n        var top;\n        switch (series.type) {\n            case 'RangeColumn':\n            case 'RangeArea':\n            case 'RangeStepArea':\n            case 'SplineRangeArea':\n            case 'Hilo':\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                break;\n            case 'Candle':\n                top = (index === 0 || index === 2) && !this.yAxisInversed\n                    || (index === 1 || index === 3) && this.yAxisInversed;\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n                break;\n            case 'HiloOpenClose':\n                if (index <= 1) {\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                }\n                else {\n                    if (this.yAxisInversed) {\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n                    }\n                    else {\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n                    }\n                }\n                break;\n            default:\n                if (((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) || (position === 'Top' && series.visiblePoints[point.index].yValue === 0)) {\n                    location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? (-rect.height + extraSpace + margin.bottom) : (-extraSpace - margin.bottom - this.markerHeight)) :\n                        location + (isMinus && series.type === 'Waterfall' ? (+rect.width - extraSpace - margin.left) : (+extraSpace + margin.left + this.markerHeight));\n                }\n                else {\n                    location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? (-rect.height - extraSpace - margin.top) : (+extraSpace + margin.top + this.markerHeight)) :\n                        location + (isMinus && series.type === 'Waterfall' ? (+rect.width + extraSpace + margin.top) : (-extraSpace - margin.right - this.markerHeight));\n                }\n                break;\n        }\n        return location;\n    };\n    /**\n     * Updates the location of the data label.\n     *\n     * @param {LabelPosition} position - The position of the data label.\n     * @param {number} location - The initial location of the data label.\n     * @param {number} extraSpace - Extra space to adjust the label position.\n     * @param {MarginModel} margin - The margin for the chart.\n     * @param {Rect} rect - The rectangle associated with the data label.\n     * @param {boolean} top - Indicates whether the label is positioned at the top.\n     * @param {boolean} inside - Indicates whether the label is inside the chart area.\n     * @returns {number} The updated location of the data label.\n     */\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n        if (inside === void 0) { inside = false; }\n        if (!this.inverted) {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\n                    location + extraSpace + margin.top + this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n            }\n        }\n        else {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\n                    location - extraSpace - margin.right - this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n        var points = series.points;\n        var index = point.index;\n        var yValue = points[index].yValue;\n        var position;\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n        var previousPoint = index > 0 ? points[index - 1] : null;\n        var yLocation;\n        var isOverLap = true;\n        var labelRect;\n        var isBottom;\n        var positionIndex;\n        var collection = this.chart.dataLabelCollections;\n        if (series.type === 'Bubble') {\n            position = 'Top';\n        }\n        else if (series.type.indexOf('Step') > -1) {\n            position = 'Top';\n            if (index) {\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (series.type === 'BoxAndWhisker') {\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n            }\n            else if (labelIndex === 2 || labelIndex === 4) {\n                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n            }\n            else {\n                isOverLap = false;\n                position = 'Middle';\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n            }\n        }\n        else {\n            if (index === 0) {\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else if (index === points.length - 1) {\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else {\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n                    position = 'Top';\n                }\n                else if (!nextPoint.visible || !previousPoint) {\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\n                        'Bottom' : 'Top';\n                }\n                else {\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\n                        intersectY < yValue ? 'Bottom' : 'Top';\n                }\n            }\n        }\n        isBottom = position === 'Bottom';\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n        while (isOverLap && positionIndex < 4) {\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n            labelRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.calculateRect)(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(this.locationX, yLocation), size, this.margin);\n            isOverLap = labelRect.y < 0 || (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.isCollide)(labelRect, collection, series.clipRect)\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n            isBottom = false;\n        }\n        return yLocation;\n    };\n    /**\n     * Initiates the animation for data labels.\n     *\n     * @param {Series} series - The series associated with the data labels.\n     * @param {Element} [element] - The element to animate.\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n        var shapeElements = series.shapeElement.childNodes;\n        var textNode = series.textElement.childNodes;\n        var delay = series.animation.delay + series.animation.duration;\n        var duration = series.chart.animated ? series.chart.duration : 200;\n        var location;\n        var length = element ? 1 : textNode.length;\n        var tempElement;\n        for (var i = 0; i < length; i++) {\n            tempElement = textNode[i];\n            if (element) {\n                element.style.visibility = 'hidden';\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.templateAnimate)(element, delay, duration, 'ZoomIn');\n            }\n            else {\n                location = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerAnimate)(tempElement, delay, series.animation.duration, series, null, location, true);\n                if (shapeElements[i]) {\n                    tempElement = shapeElements[i];\n                    location = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerAnimate)(tempElement, delay, series.animation.duration, series, null, location, true);\n                }\n            }\n        }\n    };\n    DataLabel.prototype.getPosition = function (index) {\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    DataLabel.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'DataLabel';\n    };\n    /**\n     * To destroy the dataLabel for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return DataLabel;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js?");

/***/ })

}]);