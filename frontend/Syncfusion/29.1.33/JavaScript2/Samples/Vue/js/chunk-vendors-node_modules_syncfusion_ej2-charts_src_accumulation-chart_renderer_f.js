"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_accumulation-chart_renderer_f"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/funnel-series.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/funnel-series.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunnelSeries: () => (/* binding */ FunnelSeries)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _triangular_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./triangular-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/triangular-base.js\");\n/**\n * Defines the behavior of a funnel series\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `FunnelSeries` module is used to render the `Funnel` Series.\n */\nvar FunnelSeries = /** @class */ (function (_super) {\n    __extends(FunnelSeries, _super);\n    function FunnelSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Defines the path of a funnel segment\n     *\n     * @private\n     * @param {AccPoints} point - The point data.\n     * @param {AccumulationSeries} series - The series for which the segment is rendered.\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @returns {string} - Get segment data.\n     */\n    FunnelSeries.prototype.getSegmentData = function (point, series, chart) {\n        var lineWidth;\n        var topRadius;\n        var bottomRadius;\n        var endTop;\n        var endBottom;\n        var minRadius;\n        var endMin;\n        var bottomY;\n        var area = series.triangleSize;\n        var offset = 0;\n        var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n        var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;\n        var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;\n        //defines the top and bottom of a segment\n        var top = point.yRatio * area.height;\n        var bottom = top + point.heightRatio * area.height;\n        var neckSize = series.neckSize;\n        lineWidth = neckSize.width + (area.width - neckSize.width) * ((area.height - neckSize.height - top) /\n            (area.height - neckSize.height));\n        topRadius = (area.width / 2) - lineWidth / 2;\n        //Calculating the middle slope change and bottom\n        endTop = topRadius + lineWidth;\n        if (bottom > area.height - neckSize.height || area.height === neckSize.height) {\n            lineWidth = neckSize.width;\n        }\n        else {\n            lineWidth = neckSize.width + (area.width - neckSize.width) *\n                ((area.height - neckSize.height - bottom) / (area.height - neckSize.height));\n        }\n        bottomRadius = (area.width / 2) - (lineWidth / 2);\n        endBottom = bottomRadius + lineWidth;\n        if (top >= area.height - neckSize.height) {\n            topRadius = bottomRadius = minRadius = (area.width / 2) - neckSize.width / 2;\n            endTop = endBottom = endMin = (area.width / 2) + neckSize.width / 2;\n        }\n        else if (bottom > (area.height - neckSize.height)) {\n            minRadius = bottomRadius = (area.width / 2) - lineWidth / 2;\n            endMin = endBottom = minRadius + lineWidth;\n            bottomY = area.height - neckSize.height;\n        }\n        top += seriesTop;\n        bottom += seriesTop;\n        bottomY += seriesTop;\n        var line1 = { x: emptySpaceAtLeft + offset + topRadius, y: top };\n        var line2 = { x: emptySpaceAtLeft + offset + endTop, y: top };\n        var line4 = { x: emptySpaceAtLeft + offset + endBottom, y: bottom };\n        var line5 = { x: emptySpaceAtLeft + offset + bottomRadius, y: bottom };\n        var line3 = { x: emptySpaceAtLeft + offset + endBottom, y: bottom };\n        var line6 = { x: emptySpaceAtLeft + offset + bottomRadius, y: bottom };\n        if (bottomY) {\n            line3 = { x: emptySpaceAtLeft + offset + endMin, y: bottomY };\n            line6 = { x: emptySpaceAtLeft + offset + minRadius, y: bottomY };\n        }\n        var polygon = [line1, line2, line3, line4, line5, line6];\n        this.setLabelLocation(series, point, polygon);\n        var direction = this.findPath(polygon, point, series);\n        return direction;\n    };\n    /**\n     * Renders a funnel segment.\n     *\n     * @private\n     * @param {AccPoints} point - The point data.\n     * @param {AccumulationSeries} series - The series for which the segment is rendered.\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @param {PathOption} options - The rendering options for the segment.\n     * @param {Element} seriesGroup - The group element to contain the funnel segments.\n     * @param {boolean} redraw - Specifies whether to redraw the segment.\n     * @param {string} previousRadius - Specifies the previous radius of the pie when animating the individual series point.\n     * @param {Object[]} previousCenter - Specifies the previous center of the pie when animating the individual series point.\n     * @param {boolean} pointAnimation - Specifies whether the point based animation is enabled.\n     * @returns {void}\n     */\n    FunnelSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw, previousRadius, previousCenter, pointAnimation) {\n        if (!point.visible) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(options.id);\n            return null;\n        }\n        var previousDirection;\n        var direction = this.getSegmentData(point, series, chart);\n        point.midAngle = 0;\n        options.d = direction;\n        if (pointAnimation && document.getElementById(options.id)) {\n            previousDirection = document.getElementById(options.id).getAttribute('d');\n        }\n        var element = chart.renderer.drawPath(options);\n        element.setAttribute('role', series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : 'img');\n        element.setAttribute('tabindex', (point.index === 0 && series.accessibility.focusable) ? String(series.accessibility.tabIndex) : '-1');\n        element.setAttribute('aria-label', series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : (point.x + ':' + point.y + '%. ' + series.name));\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, seriesGroup, element, redraw, pointAnimation ? pointAnimation : undefined, pointAnimation ? 'x' : undefined, pointAnimation ? 'y' : undefined, undefined, pointAnimation ? previousDirection : undefined, undefined, undefined, undefined, pointAnimation ? chart.duration : undefined);\n        if (point.isExplode) {\n            chart.accBaseModule.explodePoints(point.index, chart, true);\n        }\n    };\n    /**\n     * Renders the Trapezoidal funnel series in an accumulation chart.\n     *\n     * @param {AccumulationSeries} series - The series data for the Trapezoidal  funnel.\n     * @param {AccPoints[]} points - The data points for the series.\n     * @param {AccumulationChart} chart - The instance of the accumulation chart.\n     * @param {PathOption[]} options - The path options for rendering the Trapezoidal funnel.\n     * @param {Element} seriesGroup - The group element for the series.\n     * @param {boolean} redraw - Specifies whether to redraw the series.\n     * @returns {void} - This method does not return a value.\n     */\n    FunnelSeries.prototype.renderTrapezoidalFunnel = function (series, points, chart, options, seriesGroup, redraw) {\n        var funnelWidth = series.triangleSize.width;\n        var funnelHeight = series.triangleSize.height;\n        var horizontalMargin = (chart.initialClipRect.width - funnelWidth) / 2;\n        var leftMargin = horizontalMargin + chart.initialClipRect.x;\n        var funnelTop = chart.initialClipRect.y + (chart.initialClipRect.height - funnelHeight) / 2;\n        var maxPointValue = Math.max.apply(Math, points.map(function (d) { return d.y; }));\n        var barPadding = 10;\n        var currentVerticalOffset = 0;\n        var polygonGroup = redraw ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_Series_' + series.index + '_Polygon') :\n            chart.renderer.createGroup({ id: chart.element.id + '_Series_' + series.index + '_Polygon' });\n        for (var i = 0; i < series.points.length; i++) {\n            var point = series.points[i];\n            var pathOption = options[point.index];\n            if (!point.visible) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(pathOption.id);\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(pathOption.id + '_polygon');\n                continue;\n            }\n            var availableHeight = funnelHeight - barPadding * (points.length - 1);\n            var barHeight = availableHeight / points.length;\n            var barWidth = funnelWidth * (point.y / maxPointValue);\n            var visiblePointIndex = points.indexOf(point);\n            var nextBarWidth = visiblePointIndex < points.length - 1 ?\n                funnelWidth * (points[visiblePointIndex + 1].y / maxPointValue) : 0;\n            var x = leftMargin + (funnelWidth - barWidth) / 2;\n            var y = funnelTop + currentVerticalOffset;\n            var cornerRadius = Math.min(series.borderRadius, barHeight / 2);\n            var rectPath = 'M' + (x + cornerRadius) + ' ' + y + ' ' +\n                'L' + (x + barWidth - cornerRadius) + ' ' + y + ' ' +\n                'A' + cornerRadius + ' ' + cornerRadius + ' 0 0 1 ' + (x + barWidth) + ' ' + (y + cornerRadius) + ' ' +\n                'L' + (x + barWidth) + ' ' + (y + barHeight - cornerRadius) + ' ' +\n                'A' + cornerRadius + ' ' + cornerRadius + ' 0 0 1 ' + (x + barWidth - cornerRadius) + ' ' + (y + barHeight) + ' ' +\n                'L' + (x + cornerRadius) + ' ' + (y + barHeight) + ' ' +\n                'A' + cornerRadius + ' ' + cornerRadius + ' 0 0 1 ' + x + ' ' + (y + barHeight - cornerRadius) + ' ' +\n                'L' + x + ' ' + (y + cornerRadius) + ' ' +\n                'A' + cornerRadius + ' ' + cornerRadius + ' 0 0 1 ' + (x + cornerRadius) + ' ' + y + ' ' +\n                'Z';\n            point.midAngle = 0;\n            pathOption.d = rectPath;\n            var element = chart.renderer.drawPath(pathOption);\n            element.setAttribute('role', series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : 'img');\n            element.setAttribute('tabindex', (point.index === 0 && series.accessibility.focusable) ? String(series.accessibility.tabIndex) : '-1');\n            element.setAttribute('aria-label', series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : (point.x + ':' + point.y + '%. ' + series.name));\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, seriesGroup, element, redraw);\n            if (visiblePointIndex < points.length - 1) {\n                var polygonOption = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.PathOption(pathOption.id + '_polygon', this.lightenColor(pathOption.fill), pathOption['stroke-width'] * 0.4, this.lightenColor(pathOption.stroke), pathOption.opacity, pathOption['stroke-dasharray'], '');\n                var trapezoidPoints = [\n                    [(funnelWidth - barWidth) / 2 + leftMargin + cornerRadius, y + barHeight],\n                    [(funnelWidth + barWidth) / 2 + leftMargin - cornerRadius, y + barHeight],\n                    [(funnelWidth + nextBarWidth) / 2 + leftMargin, y + barHeight + barPadding],\n                    [(funnelWidth - nextBarWidth) / 2 + leftMargin, y + barHeight + barPadding]\n                ];\n                var trapezoidPath = '' +\n                    'M' + trapezoidPoints[0][0] + ' ' + trapezoidPoints[0][1] + ' ' +\n                    'L' + trapezoidPoints[1][0] + ' ' + trapezoidPoints[1][1] + ' ' +\n                    'L' + trapezoidPoints[2][0] + ' ' + trapezoidPoints[2][1] + ' ' +\n                    'L' + trapezoidPoints[3][0] + ' ' + trapezoidPoints[3][1] + ' ' + 'Z';\n                polygonOption.d = trapezoidPath;\n                var polygon = chart.renderer.drawPath(polygonOption);\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, polygonGroup, polygon, redraw);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(pathOption.id + '_polygon');\n            }\n            currentVerticalOffset += barHeight + barPadding;\n            point.region = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, barWidth, barHeight);\n            point.symbolLocation = {\n                x: point.region.x + point.region.width / 2,\n                y: point.region.y + point.region.height / 2\n            };\n            point.labelOffset = {\n                x: point.symbolLocation.x + point.region.width / 2,\n                y: point.symbolLocation.y + point.region.height / 2\n            };\n            if (point.isExplode) {\n                chart.accBaseModule.explodePoints(point.index, chart, true);\n            }\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, chart.getSeriesElement(), seriesGroup, redraw);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, chart.getSeriesElement(), polygonGroup, redraw);\n    };\n    /**\n     * Function to lighten a color by blending it with white.\n     *\n     * @param {string} color - The main color in hex format (e.g., '#1e90ff').\n     * @returns {string} - The lightened color in hex format.\n     */\n    FunnelSeries.prototype.lightenColor = function (color) {\n        var rgbValue = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.convertHexToColor)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.colorNameToHex)(color));\n        return 'rgb(' + rgbValue.r + ',' + rgbValue.g + ',' + rgbValue.b + ',' + 0.4 + ')';\n    };\n    /**\n     * To get the module name of the funnel series.\n     *\n     * @returns {string} - Get module name.\n     */\n    FunnelSeries.prototype.getModuleName = function () {\n        return 'FunnelSeries';\n    };\n    /**\n     * To destroy the funnel series.\n     *\n     * @returns {void} Destroy method.\n     * @private\n     */\n    FunnelSeries.prototype.destroy = function () {\n        /**\n         * Destroys the funnel series.\n         */\n    };\n    return FunnelSeries;\n}(_triangular_base__WEBPACK_IMPORTED_MODULE_2__.TriangularBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/funnel-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-series.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-series.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PieSeries: () => (/* binding */ PieSeries)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _renderer_pie_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/pie-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-base.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * The `PieSeries` module is used to render the `Pie` series.\n */\nvar PieSeries = /** @class */ (function (_super) {\n    __extends(PieSeries, _super);\n    function PieSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To get path option, degree, symbolLocation from the point.\n     *\n     * @private\n     * @param {AccPoints} point - The point data.\n     * @param {AccumulationSeries} series - The series of the chart.\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @param {PathOption} option - The rendering options for the point.\n     * @param {Element} seriesGroup - The group element to contain the series elements.\n     * @param {boolean} redraw - Specifies whether to redraw the series.\n     * @param {string} previousRadius - Specifies the previous radius of the pie when animating the individual series point.\n     * @param {Object[]} previousCenter - Specifies the previous center of the pie when animating the individual series point.\n     * @param {boolean} pointAnimation - Specifies whether the point based animation is enabled.\n     * @returns {void}\n     */\n    PieSeries.prototype.renderPoint = function (point, series, chart, option, seriesGroup, redraw, previousRadius, previousCenter, pointAnimation) {\n        var sum = series.sumOfPoints;\n        var seriesPoints = this.accumulation.visibleSeries[0].points;\n        var borderRadius = series.borderRadius;\n        point.startAngle = this.startAngle;\n        var yValue = point.visible ? point.y : 0;\n        var degree = (sum) ? ((Math.abs(yValue) / sum) * (this.totalAngle)) : null;\n        var start = Math.PI / 180 * ((90 - (360 - this.startAngle)) - 90);\n        this.radius = this.isRadiusMapped ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(point.sliceRadius, this.seriesRadius) : this.radius;\n        option.d = this.getPathOption(point, degree, this.startAngle % 360, borderRadius, seriesPoints);\n        point.midAngle = (this.startAngle - (degree / 2)) % 360;\n        point.endAngle = this.startAngle % 360;\n        point.symbolLocation = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(point.midAngle, (this.radius + this.innerRadius) / 2, this.center);\n        if (!redraw) {\n            var element = chart.renderer.drawPath(option);\n            element.setAttribute('role', series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : 'img');\n            element.setAttribute('tabindex', (point.index === 0 && series.accessibility.focusable) ? String(series.accessibility.tabIndex) : '-1');\n            element.style.outline = 'none';\n            element.setAttribute('aria-label', series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : (point.x + ': ' + point.y + '%. ' + series.name));\n            seriesGroup.appendChild(element);\n            point.degree = degree;\n            point.start = start;\n        }\n        else {\n            var element = chart.renderer.drawPath(option);\n            if (!point.isExplode && pointAnimation) {\n                element.setAttribute('transform', 'translate(0, 0)');\n            }\n            element.setAttribute('role', series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : 'img');\n            element.setAttribute('tabindex', (point.index === 0 && series.accessibility.focusable) ? String(series.accessibility.tabIndex) : '-1');\n            element.style.outline = 'none';\n            element.setAttribute('aria-label', series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : (point.x + ': ' + point.y + '%. ' + series.name));\n            if (point.degree === undefined) {\n                point.degree = degree;\n                point.start = start;\n            }\n            seriesGroup.appendChild(element);\n            this.refresh(point, degree, start, chart, option, borderRadius, seriesPoints, previousRadius, previousCenter, pointAnimation);\n        }\n    };\n    PieSeries.prototype.findSeries = function (e, borderRadius) {\n        var borderGap = 3; // Gap between pie/doughnut chart and border\n        var width = 2; // width of the border\n        var radius = this.innerRadius === 0 ? this.radius + borderGap : this.innerRadius - borderGap;\n        var innerRadius = this.innerRadius === 0 ? radius + width : radius - width;\n        this.toggleInnerPoint(e, radius, innerRadius, borderRadius);\n    };\n    PieSeries.prototype.toggleInnerPoint = function (event, radius, innerRadius, borderRadius) {\n        var target = event.target;\n        var id = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.indexFinder)(target.id, true);\n        var accumulationId = event.target.id.substring(0, (event.target.id.indexOf('Series') - 1));\n        var borderElement = document.getElementById(this.accumulation.element.id + 'PointHover_Border');\n        var createBorderEle;\n        var seriesPoints = this.accumulation.visibleSeries[0].points;\n        var seriesIndex = id.series;\n        var pointIndex = id.point;\n        var srcElem = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(accumulationId + '_Series_' + seriesIndex + '_Point_' + pointIndex);\n        if (!isNaN(id.series) && srcElem) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(seriesIndex) && !isNaN(seriesIndex) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(pointIndex) && !isNaN(pointIndex)) {\n                var point = this.accumulation.visibleSeries[0].points[pointIndex];\n                var opacity = srcElem.getAttribute('class') === accumulationId + '_ej2_deselected' ?\n                    this.accumulation.tooltip.enable ? 0.5 : 0.3 : this.accumulation.tooltip.enable ? 0.5 : 1;\n                var innerPie = this.getPathArc(this.accumulation.pieSeriesModule.center, point.startAngle % 360, (point.startAngle + point.degree) % 360, radius, innerRadius, borderRadius, true, seriesPoints);\n                // while using annotation as a chart border will appear in both chart.so changed checked the id with target id\n                if ((borderElement) && (accumulationId === this.accumulation.element.id) &&\n                    (borderElement.getAttribute('d') !== innerPie || point.isExplode)) {\n                    borderElement.parentNode.removeChild(borderElement);\n                    borderElement = null;\n                }\n                var seriousGroup = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(accumulationId + '_Series_' + seriesIndex);\n                if (!borderElement && ((!point.isExplode) || (point.isExplode && event.type !== 'click'))) {\n                    var path = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.PathOption(accumulationId + 'PointHover_Border', point.color, 1, point.color, opacity, '', innerPie);\n                    createBorderEle = this.accumulation.renderer.drawPath(path);\n                    createBorderEle.removeAttribute('transform');\n                    if (this.accumulation.selectionMode !== 'None' && event.target.hasAttribute('class')) {\n                        this.accumulation.accumulationSelectionModule.addSvgClass(createBorderEle, event.target.getAttribute('class'));\n                    }\n                    seriousGroup.appendChild(createBorderEle);\n                    if (point.isExplode && createBorderEle) {\n                        var borderExplode = srcElem.getAttribute('transform');\n                        if (borderExplode) {\n                            createBorderEle.setAttribute('transform', borderExplode);\n                        }\n                    }\n                }\n            }\n        }\n        else if (borderElement) {\n            this.removeBorder(borderElement, 1000);\n            borderElement = null;\n        }\n    };\n    PieSeries.prototype.removeBorder = function (borderElement, duration) {\n        if (borderElement) {\n            setTimeout(function () {\n                if (borderElement.parentNode) {\n                    borderElement.parentNode.removeChild(borderElement);\n                }\n            }, duration);\n        }\n    };\n    PieSeries.prototype.refresh = function (point, degree, start, chart, option, borderRadius, seriesPoints, previousRadius, previouCenter, pointAnimation) {\n        var _this = this;\n        var seriesElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(option.id);\n        var duration = chart.duration ? chart.duration : 300;\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.Animation({}).animate((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.createElement)('div'), {\n            duration: duration,\n            delay: 0,\n            progress: function (args) {\n                var curentDegree = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.linear)(args.timeStamp, point.degree, (degree - point.degree), args.duration);\n                var currentStartAngle = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.linear)(args.timeStamp, point.start, start - point.start, args.duration);\n                currentStartAngle = ((currentStartAngle / (Math.PI / 180)) + 360) % 360;\n                if (previousRadius && previouCenter) {\n                    var currentRadius = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.linear)(args.timeStamp, previousRadius, (_this.radius - previousRadius), args.duration);\n                    var previouCenterx = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.linear)(args.timeStamp, previouCenter.x, (_this.center.x - previouCenter.x), args.duration);\n                    var previouCentery = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.linear)(args.timeStamp, previouCenter.y, (_this.center.y - previouCenter.y), args.duration);\n                    seriesElement.setAttribute('d', _this.getPathOption(point, curentDegree, currentStartAngle, borderRadius, seriesPoints, currentRadius, previouCenterx, previouCentery));\n                }\n                else {\n                    seriesElement.setAttribute('d', _this.getPathOption(point, curentDegree, currentStartAngle, borderRadius, seriesPoints));\n                }\n                if (point.isExplode) {\n                    chart.accBaseModule.explodePoints(point.index, chart, true, pointAnimation);\n                }\n                seriesElement.style.visibility = 'visible';\n            },\n            end: function () {\n                seriesElement.style.visibility = point.visible ? 'visible' : 'hidden';\n                seriesElement.setAttribute('d', option.d);\n                point.degree = degree;\n                point.start = start;\n            }\n        });\n    };\n    /**\n     * To get path option from the point.\n     *\n     * @param {AccPoints} point - The point data.\n     * @param {number} degree - The angle of the point.\n     * @param {number} startAngle - The start angle of the slice.\n     * @param {number} borderRadius - The border radius of the arc.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @param {number} previouRadius - The previous radius of the pie.\n     * @param {number} previousCenterX - The previous center x of the pie.\n     * @param {number} previousCenterY - The previous center y of the pie.\n     * @returns {string} - Returns the path option.\n     */\n    PieSeries.prototype.getPathOption = function (point, degree, startAngle, borderRadius, seriesPoints, previouRadius, previousCenterX, previousCenterY) {\n        if (!degree) {\n            return '';\n        }\n        var path = this.getPathArc(previousCenterX ? { x: previousCenterX, y: previousCenterY } : this.center, startAngle % 360, (startAngle + degree) % 360, this.isRadiusMapped ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(point.sliceRadius, this.size / 2) : previouRadius ? previouRadius : this.radius, this.innerRadius, borderRadius, false, seriesPoints);\n        //const path: string = this.getPathArc(this.center, startAngle % 360, (startAngle + degree) % 360, this.radius, this.innerRadius);\n        this.startAngle += degree;\n        return path;\n    };\n    /**\n     * To animate the pie series.\n     *\n     * @private\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @param {AnimationModel} option - The animation options.\n     * @param {AccumulationSeries} series - The pie series.\n     * @param {Element} slice - The slice element to animate.\n     * @param {number} borderRadius - The border radius of the arc.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {void}\n     */\n    PieSeries.prototype.animateSeries = function (accumulation, option, series, slice, borderRadius, seriesPoints) {\n        var groupId = accumulation.element.id + 'SeriesGroup' + series.index;\n        if (((series.animation.enable && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.animationMode !== 'Disable') || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.animationMode === 'Enable') && accumulation.animateSeries) {\n            var clippath = accumulation.renderer.createClipPath({ id: groupId + '_clipPath' });\n            var path = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.PathOption(groupId + '_slice', 'transparent', 1, 'transparent', 1, '', '');\n            var clipslice = accumulation.renderer.drawPath(path);\n            clippath.appendChild(clipslice);\n            accumulation.svgObject.appendChild(clippath);\n            // I263828 pie chart animation issue fixed for safari browser\n            slice.style.cssText = 'clip-path:url(#' + clippath.id + '); -webkit-clip-path:url(#' + clippath.id + ');';\n            this.doAnimation(clipslice, series, slice, borderRadius, seriesPoints);\n        }\n    };\n    /**\n     * To get the module name of the Pie series.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    PieSeries.prototype.getModuleName = function () {\n        return 'PieSeries';\n    };\n    /**\n     * To destroy the pie series.\n     *\n     * @returns {void}\n     * @private\n     */\n    PieSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    return PieSeries;\n}(_renderer_pie_base__WEBPACK_IMPORTED_MODULE_2__.PieBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-series.js?");

/***/ })

}]);