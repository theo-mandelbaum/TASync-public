{"index.css":"/* css */","index.html":"<!DOCTYPE html>\n<html>\n<head>\n    <title>Syncfusion React Sample</title>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\" />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"description\" content=\"Syncfusion React UI Components\" />\n    <meta name=\"author\" content=\"Syncfusion\" />\n    <link href=\"https://cdn.syncfusion.com/ej2/28.1.33/{{theme}}.css\" rel=\"stylesheet\">\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" />\n</head>\n\n<body class=\"{{theme}}\">\n     <style>\n            .control-section\n            {\n                margin-top: 100px;\n            }\n    </style>\n    <div id='sample'>\n</body>\n</html>\n","index.js":"import { createRoot } from 'react-dom/client';\nimport './index.css';\n/**\n * Sample for Candle Series\n */\nimport * as React from \"react\";\nimport { ChartComponent, SeriesCollectionDirective, AnnotationsDirective, AnnotationDirective, CandleSeries, Category, Tooltip, DateTime, Zoom, Logarithmic, ColumnSeries, Crosshair, StripLine, SeriesDirective, Inject, ChartAnnotation } from '@syncfusion/ej2-react-charts';\nimport { SampleBase } from './sample-base';\nimport { Browser } from '@syncfusion/ej2-base';\nlet value = 180;\nlet getData = () => {\n    let series = [];\n    let point;\n    for (let i = 0; i < 30; i++) {\n        let change;\n        if (i < 10 && !(i === 3 || i === 4 || i === 7)) {\n            change = -Math.round(Math.random() * 10);\n        }\n        else if ((i >= 10 || i === 3 || i === 4 || i === 7 || i === 23 || i === 24 || i === 27) && i < 20 && !(i === 13 || i === 14 || i === 17)) {\n            change = Math.round(Math.random() * 10);\n        }\n        else if ((i >= 20 || i === 13 || i === 14 || i === 17) && !(i === 23 || i === 24 || i === 27)) {\n            change = -Math.round(Math.random() * 10);\n        }\n        else {\n            change = 0;\n        }\n        value = value + change;\n        if (value > 240) {\n            value = 240;\n        }\n        if (value < 140) {\n            value = 140;\n        }\n        let open = value + Math.round(Math.random() * 12);\n        let low = Math.min(value, open) - Math.round(Math.random() * 8);\n        let high = Math.max(value, open) + Math.round(Math.random() * 14);\n        point = {\n            x: new Date(2000, 5, 2, 2, 0, i),\n            close: value,\n            open: open,\n            low: low,\n            high: high\n        };\n        series.push(point);\n    }\n    return { series: series };\n};\nlet data = getData().series;\nlet incVal = 0;\nlet updateVal = data.length;\nlet pointAdded = false;\nconst SAMPLE_CSS = `\n    .control-fluid {\n\t\tpadding: 0px !important;\n    }`;\n/**\n * Candle sample\n */\nexport class Candle extends SampleBase {\n    chartInstance;\n    render() {\n        return (<div className='control-pane'>\n                <style>{SAMPLE_CSS}</style>\n                <div className='control-section'>\n                    <div className=\"row\">\n                        <ChartComponent id='stock' ref={chart => this.chartInstance = chart} style={{ textAlign: \"center\" }} load={this.load.bind(this)} primaryXAxis={{ valueType: 'DateTime', interval: 4, crosshairTooltip: { enable: true }, edgeLabelPlacement: Browser.isDevice ? 'None' : 'Shift', majorGridLines: { width: 0 } }} primaryYAxis={{ interval: 20, minimum: 120, opposedPosition: true, lineStyle: { width: 0 }, crosshairTooltip: { enable: true }, majorGridLines: { width: 1 }, majorTickLines: { width: 0 } }} width={Browser.isDevice ? '100%' : '90%'} chartArea={{ border: { width: 0 } }} title=\"AAPL Historical\" crosshair={{ enable: true, dashArray: '5,5' }} pointRender={this.pointRender.bind(this)} axisRangeCalculated={this.axisRangeCalculated.bind(this)}>\n                            <Inject services={[CandleSeries, StripLine, Category, Tooltip, DateTime, Zoom, ColumnSeries, Logarithmic, Crosshair, ChartAnnotation]}/>\n                            <SeriesCollectionDirective>\n                                <SeriesDirective type='Candle' bearFillColor='#2ecd71' bullFillColor='#e74c3d' dataSource={data} columnWidth={0.4} xName='x' low='low' high='high' open='open' close='close'/>\n                            </SeriesCollectionDirective>\n                            <AnnotationsDirective>\n                                <AnnotationDirective content='<div></div>' x={new Date(2000, 5, 2, 2, 0, 1)} y={140} region=\"Series\" coordinateUnits='Point'>\n                                </AnnotationDirective>\n                            </AnnotationsDirective>\n                        </ChartComponent>\n                    </div>\n                </div>\n            </div>);\n    }\n    axisRangeCalculated(args) {\n        if (args.axis.name === 'primaryXAxis') {\n            let lastPoint = args.axis.series[0].points[args.axis.series[0].points.length - 1].x;\n            args.maximum = new Date(Number(lastPoint)).getTime() + 2500;\n            let firstPoint = args.axis.series[0].points[0].x;\n            args.minimum = new Date(Number(firstPoint)).getTime() + 500;\n        }\n    }\n    ;\n    load(args) {\n        let selectedTheme = location.hash.split('/')[1];\n        selectedTheme = selectedTheme ? selectedTheme : 'Fluent2';\n        args.chart.theme = (selectedTheme.charAt(0).toUpperCase() + selectedTheme.slice(1)).\n            replace(/-dark/i, \"Dark\").replace(/contrast/i, 'Contrast').replace(/-highContrast/i, 'HighContrast');\n        setInterval(function () {\n            let newData1 = [];\n            pointAdded = true;\n            for (let i = 0; i < args.chart.series[0].dataSource.length; i++) {\n                newData1.push(Object.assign({}, args.chart.series[0].dataSource[i]));\n            }\n            if (newData1.length > 0) {\n                const lastIndex = newData1.length - 1;\n                const previousClose = newData1[lastIndex].close;\n                newData1[lastIndex].close += (Math.random() < 0.5 ? 1 : -1) * Math.random() * 5;\n                newData1[lastIndex].close = Math.min(Math.min(Math.max(newData1[lastIndex].close, newData1[lastIndex].low + 5), newData1[lastIndex].high - 5), newData1[lastIndex].open - 2);\n                if (previousClose === newData1[lastIndex].close) {\n                    newData1[lastIndex].close -= 1;\n                }\n            }\n            if (incVal < 10) {\n                if (args.chart.series.length > 0) {\n                    args.chart.series[0].setData(newData1);\n                    incVal++;\n                }\n            }\n            else {\n                let change = Math.round((Math.random() < 0.49 ? 1 : -1) * Math.random() * 10);\n                value += change;\n                if (value > 200) {\n                    value = 200;\n                }\n                else if (value < 160) {\n                    value = 160;\n                }\n                let open = value + Math.round(Math.random() * 12);\n                let low = Math.min(value, open) - Math.round(Math.random() * 8);\n                let high = Math.max(value, open) + Math.round(Math.random() * 15);\n                if (args.chart.series.length > 0) {\n                    args.chart.series[0].addPoint({ x: new Date(2000, 5, 2, 2, 0, updateVal), high: high, low: low, open: open, close: value });\n                }\n                incVal = 0;\n                updateVal++;\n            }\n        }, 1000);\n    }\n    ;\n    pointRender(args) {\n        if (args.series.chart.enableRtl) {\n            args.series.chart.annotations[0].x = 0;\n        }\n        if (pointAdded && args.series.points[args.series.points.length - 1] === args.point) {\n            const firstPoint = args.series.chart.enableRtl ? args.series.points[args.series.points.length - 1].x : args.series.points[0].x;\n            args.series.chart.annotations[0].x = new Date(Number(firstPoint)).getTime() + (args.series.chart.enableRtl ? 2000 : 1000);\n            args.series.chart.annotations[0].y = args.point.close;\n            args.series.chart.annotations[0].content = `<div style=\"width: ${args.series.chart.initialClipRect.width}px; height: 0; left: ${Browser.isDevice ? -10 : -16}px; position: absolute;\">\n            <svg width=\"100%\" height=\"2\" style=\"display: block;\">\n              <line x1=\"0\" y1=\"1\" x2=\"${args.series.chart.initialClipRect.width}\" y2=\"1\" \n                style=\"stroke:#868180; stroke-width:0.75; stroke-dasharray:5,5;\" />\n            </svg>\n          </div>\n          <div style=\"width: 40px; height: 18px; background-color: ${args.fill}; border: 1px solid rgba(48, 153, 245, 0.4); color: white; font-size: 11px; text-align: center; line-height: 18px; position: absolute; left: ${(args.series.chart.enableRtl ? -args.series.chart.initialClipRect : args.series.chart.initialClipRect.width - 20)}px; top: -9px;\">\n            ${args.point.close.toFixed(2)}\n          </div> `;\n        }\n    }\n}\n\nconst root = createRoot(document.getElementById('sample'));\nroot.render(<Candle />);","sample-base.js":"import * as React from 'react';\n    {{ripple}}\n    export class SampleBase extends React.PureComponent {\n        rendereComplete() {\n            /**custom render complete function */\n        }\n        componentDidMount() {\n            setTimeout(() => {\n                this.rendereComplete();\n            });\n        }\n    }\n    export function updateSampleSection(){}\n    ","dependencies":"{\"@syncfusion/ej2-base\":\"*\",\"@syncfusion/ej2-react-base\":\"*\",\"@syncfusion/ej2-charts\":\"*\",\"@syncfusion/ej2-react-charts\":\"*\",\"@syncfusion/ej2-icons\":\"*\",\"markdown-spellcheck\":\"^1.3.1\",\"@syncfusion/ej2/base\":\"*\",\"@syncfusion/ej2-charts'; // Import the necessary types from Syncfusion\":\"*\"}"}